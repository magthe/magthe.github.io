<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title><![CDATA[Magnus web site - haskell]]></title>
<description><![CDATA[Magnus web site - haskell]]></description>
<link>https://magnus.therning.org//tag-haskell.html</link>
<lastBuildDate>Sat, 20 Mar 2021 08:20:05 +0100</lastBuildDate>
<item>
  <title><![CDATA[Custom monad with servant and throwing errors]]></title>
  <description><![CDATA[
<p>
In the past I've always used <a href="https://hackage.haskell.org/package/scotty">scotty</a> when writing web services. This was mostly
due to laziness, I found working out how to use scotty a lot easier than
<a href="https://hackage.haskell.org/package/servant">servant</a>, so basically I was being lazy. Fairly quickly I bumped into some
limitations in scotty, but at first the workarounds didn't add too much
complexity and were acceptable. A few weeks ago they started weighing on me
though and I decided to look into servant and since I really liked what I found
I've started moving all projects to use servant.
</p>

<p>
In several of the projects I've used tagless final style and defined a type
based on <code>ReaderT</code> holding configuration over <code>IO</code>, that is something like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unAppM <span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor">ReaderT</span> <span class="org-haskell-constructor">Config</span> <span class="org-haskell-constructor">IO</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span>
    <span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-haskell-constructor">Functor</span>,
      <span class="org-haskell-constructor">Applicative</span>,
      <span class="org-haskell-constructor">Monad</span>,
      <span class="org-haskell-constructor">MonadIO</span>,
      <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Config</span>
    <span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> a
<span class="org-haskell-definition">runAppM</span> app <span class="org-haskell-operator">=</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I found that servant is very well suited to this style through <a href="https://hoogle.haskell.org/?hoogle=hoistServer%20is%3Aexact&amp;scope=set:stackage"><code>hoistServer</code></a> and
there are several examples on how to use it with a <code>ReaderT</code>-based type like
above. The first one I found is in the <a href="https://docs.servant.dev/en/stable/cookbook/using-custom-monad/UsingCustomMonad.html">servant cookbook</a>. However, as I realised
a bit later, using a simple type like this doesn't make it easy to trigger
responses with status other than <code>200 OK</code>. When I looked at the definition of
the type for writing handlers that ships with servant, <a href="https://hoogle.haskell.org/?hoogle=Handler%20package%3Aservant-server%20is%3Aexact&amp;scope=set:stackage"><code>Handler</code></a>, I decided to
try to use the following type in my service
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unAppM <span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor">ReaderT</span> <span class="org-haskell-constructor">Config</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">ExceptT</span> <span class="org-haskell-constructor">ServerError</span> <span class="org-haskell-constructor">IO</span><span class="org-rainbow-delimiters-depth-2">)</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span>
    <span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-haskell-constructor">Functor</span>,
      <span class="org-haskell-constructor">Applicative</span>,
      <span class="org-haskell-constructor">Monad</span>,
      <span class="org-haskell-constructor">MonadIO</span>,
      <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Config</span>
    <span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">ServerError</span> a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">runAppM</span> app <span class="org-haskell-operator">=</span> runExceptT <span class="org-haskell-operator">.</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The natural transformation required by <code>hoistServer</code> can then be written like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">nt</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Handler</span> a
<span class="org-haskell-definition">nt</span> x <span class="org-haskell-operator">=</span>
  liftIO <span class="org-rainbow-delimiters-depth-1">(</span>runAppM x cfg<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
    <span class="org-haskell-constructor">Right</span> v <span class="org-haskell-operator">-&gt;</span> pure v
    <span class="org-haskell-constructor">Left</span> err <span class="org-haskell-operator">-&gt;</span> throwError err
</pre>
</div>

<p>
I particularly like how clearly this suggests a way to add custom errors if I
want that.
</p>

<ol class="org-ol">
<li>Swap out <code>ServerError</code> for my custom error type in <code>AppM</code>.</li>
<li>Write a function to transform my custom error type into a <code>ServerError</code>,
<code>transformCustomError :: CustomError -&gt; ServerError</code>.</li>
<li>use <code>throwError $ transformCustomError err</code> in the <code>Left</code> branch of <code>nt</code>.</li>
</ol>

<div id="outline-container-org656a1f3" class="outline-2">
<h2 id="org656a1f3">A slight complication with <code>MonadUnliftIO</code></h2>
<div class="outline-text-2" id="text-org656a1f3">
<p>
I was using <a href="https://hackage.haskell.org/package/unliftio">unliftio</a> in my service, and as long as I based my monad stack only
on <code>ReaderT</code> that worked fine. I even got the <code>MonadUnliftIO</code> instance for free
through automatic deriving. <code>ExceptT</code> isn't a stateless monad though, so using
unliftio is out of the question, instead I had to switch to <a href="https://hoogle.haskell.org/?hoogle=MonadBaseControl%20package%3Amonad-control&amp;scope=set:stackage"><code>MonadBaseControl</code></a>
and the packages that work with it. Defining and instance of <code>MonadBaseControl</code>
looked a bit daunting, but luckily <code>Handler</code> has an instance of it that I used
as inspiration.
</p>

<p>
First off <code>MonadBaseControl</code> requires the type to also be an instance of
<code>MonadBase</code>. There's an explicit implementation for <code>Handler</code>, but I found that
it can be derived automatically, so I took the lazy route.
</p>

<p>
The instance of <code>MonadBaseControl</code> for <code>AppM</code> ended up looking like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadBaseControl</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  <span class="org-haskell-keyword">type</span> <span class="org-haskell-type">StM</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-type">Either</span> <span class="org-haskell-type">ServerError</span> a

  liftBaseWith f <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">(</span>liftBaseWith <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>g <span class="org-haskell-operator">-&gt;</span> f <span class="org-rainbow-delimiters-depth-3">(</span>g <span class="org-haskell-operator">.</span> unAppM<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
  restoreM <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-haskell-operator">.</span> restoreM
</pre>
</div>

<p>
I can't claim to really understand what's going on in that definition, but I
have Alexis King's article on <a href="https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/">Demystifying MonadBaseControl</a> on my list of things
to read.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-servant.html">servant</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[servant]]></category>
  <link>https://magnus.therning.org/2021-03-19-custom-monad-with-servant-and-throwing-errors.html</link>
  <pubDate>Fri, 19 Mar 2021 22:20:00 +0100</pubDate>
</item>
<item>
  <title><![CDATA[Flycheck and HLS]]></title>
  <description><![CDATA[
<p>
I've been using LSP for most programming languages for a while now. HLS is
really very good now, but I've found that it doesn't warn on quite all things
I'd like it to so I find myself having to swap between the <code>'lsp</code> and
<code>'haskell-ghc</code> checkers. However, since <a href="https://www.flycheck.org/en/latest/">flycheck</a> supports chaining checkers I
thought there must be a way to have both checkers active at the same time.
</p>

<p>
The naive approach didn't work due to load order of things in Spacemacs so I had
to experiment a bit to find something that works.
</p>

<p>
The first issue was to make sure that HLS is available at all. I use <code>shell.nix</code>
together with <a href="https://direnv.net/">direnv</a> extensively and I had noticed that <code>lsp-mode</code> tried to load
HLS before <code>direnv</code> had put it in the <code>$PATH</code>. I think the
<code>'lsp-beforeinitialize-hook</code> is the hook to use for this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>add-hook 'lsp-before-initialize-hook #'direnv-update-environment<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-rainbow-delimiters-unmatched">)</span>
</pre>
</div>

<p>
I made a several attempt to chain the checkers but kept on getting
errors due to the <code>'lsp</code> checker not being defined yet. Another problem
I ran into was that the checkers were chained too late, resulting in
having to manually run <code>flycheck-buffer</code> on the first file I opened.
(Deferred loading is a brilliant thing, but make some things really
difficult to debug.) After quite a bit of experimenting and reading the
description of various hooks I did find something that works:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">with-eval-after-load</span> 'lsp-mode
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">defun</span> <span class="org-function-name">magthe:lsp-next-checker</span> <span class="org-rainbow-delimiters-depth-3">()</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>flycheck-add-next-checker 'lsp '<span class="org-rainbow-delimiters-depth-4">(</span>warning . haskell-ghc<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>add-hook 'lsp-lsp-haskell-after-open-hook
            #'magthe:lsp-next-checker<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Of course I have no idea if this is the easiest or most elegant solution but it
does work for my testcases:
</p>

<ol class="org-ol">
<li>Open a file in a project, <code>SPC p l</code> - choose project - choose a Haskell file.</li>
<li>Open a project, <code>SPC p l</code> followed by <code>C-d</code>, and then open a Haskell file.</li>
</ol>

<p>
Suggestions for improvements are more than welcome, of course.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-flycheck.html">flycheck</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[flycheck]]></category>
  <link>https://magnus.therning.org/2021-03-05-000-flycheck-and-hls.html</link>
  <pubDate>Fri, 05 Mar 2021 21:48:00 +0100</pubDate>
</item>
<item>
  <title><![CDATA[Haskell, Nix and using packages from GitHub]]></title>
  <description><![CDATA[
<p>
The other day I bumped into what turned out to be a <a href="https://mail.haskell.org/pipermail/haskell-cafe/2020-November/133021.html">bug in Amazonka</a> where
sockets weren't closed in a timely fashion and thus the process ran out of file
descriptors. Some more digging and an <a href="https://github.com/brendanhay/amazonka/issues/608">issue</a> later I found that a fix most likely
already in place (mine was possibly a duplicate of an older <a href="https://github.com/brendanhay/amazonka/issues/490">issue</a>). Now I only
had to verify if that was the case by using the most recent, and unreleased code
on the <code>develop</code> branch of Amazonka.
</p>

<p>
My first thought was to attempt to instruct Cabal to build the bits of Amazonka
I need by putting a few <a href="https://cabal.readthedocs.io/en/3.4/cabal-project.html#specifying-packages-from-remote-version-control-locations"><code>source-repository-package</code> stanzas</a> in my config. That
quickly started to look like a bit of a rabbit hole, so I decided to use Nix
instead. After finding the <a href="https://stackoverflow.com/questions/54810851/how-can-i-build-a-haskell-dependency-from-a-github-source-nix-file-using-nix">perfect SO post</a> and looking up yet again how to do
overrides for Haskell I ran <code>cabal2nix</code> for the three packages I need:
</p>

<div class="org-src-container">
<pre class="src src-shell">cabal2nix --no-haddock --no-check --subpath amazonka <span class="org-sh-escaped-newline">\</span>
  git://github.com/brendanhay/amazonka.git &gt; amazonka.nix
cabal2nix --no-haddock --no-check --subpath core <span class="org-sh-escaped-newline">\</span>
  git://github.com/brendanhay/amazonka.git &gt; amazonka-core.nix
cabal2nix --no-haddock --no-check --subpath amazonka-sqs <span class="org-sh-escaped-newline">\</span>
  git://github.com/brendanhay/amazonka.git &gt; amazonka-sqs.nix
</pre>
</div>

<p>
The relevant part of the old Nix expression looked like this:
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-nix-attribute">thePkg</span> = haskellPackages.developPackage <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">root</span> = lib.cleanSource <span class="org-nix-constant">./.</span>;
  <span class="org-nix-attribute">name</span> = name;

  <span class="org-nix-attribute">modifier</span> = <span class="org-rainbow-delimiters-depth-2">(</span>t.flip t.pipe<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">[</span>hl.dontHaddock
     hl.enableStaticLibraries
     hl.justStaticExecutables
     hl.disableLibraryProfiling
     hl.disableExecutableProfiling<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
After adding the overrides it looked like this
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-nix-attribute">hp</span> = haskellPackages.override <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">overrides</span> = self: super: <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-nix-attribute">amazonka-core</span> = self.callPackage <span class="org-nix-constant">./amazonka-core.nix</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
    <span class="org-nix-attribute">amazonka</span> = self.callPackage <span class="org-nix-constant">./amazonka.nix</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
    <span class="org-nix-attribute">amazonka-sqs</span> = self.callPackage <span class="org-nix-constant">./amazonka-sqs.nix</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-nix-attribute">thePkg</span> = hp.developPackage <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">root</span> = lib.cleanSource <span class="org-nix-constant">./.</span>;
  <span class="org-nix-attribute">name</span> = name;

  <span class="org-nix-attribute">modifier</span> = <span class="org-rainbow-delimiters-depth-2">(</span>t.flip t.pipe<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">[</span>hl.dontHaddock
     hl.enableStaticLibraries
     hl.justStaticExecutables
     hl.disableLibraryProfiling
     hl.disableExecutableProfiling<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
After a somewhat longer-than-usual build I could verify that I had indeed bumped
into the same issue and my issue was a duplicate.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[nix]]></category>
  <link>https://magnus.therning.org/2020-11-30-1734-haskell__nix_and_using_packages_from_github.html</link>
  <pubDate>Mon, 30 Nov 2020 17:34:00 +0100</pubDate>
</item>
<item>
  <title><![CDATA[Combining Amazonka and Conduit]]></title>
  <description><![CDATA[
<p>
Combining <a href="https://hackage.haskell.org/package/amazonka">amazonka</a> and <a href="https://hackage.haskell.org/package/conduit">conduit</a> turned out to be easier than I had expected.
</p>

<p>
Here's an SNS sink I put together today
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">snsSink</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadAWS</span> m, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">C.ConduitT</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-type">C.Void</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">snsSink</span> topic <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  C.await <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> pure <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-haskell-constructor">Just</span> msg <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">&lt;-</span> C.lift <span class="org-haskell-operator">$</span> publishSNS topic <span class="org-rainbow-delimiters-depth-1">(</span>TL.toStrict <span class="org-haskell-operator">$</span> TL.decodeUtf8 <span class="org-haskell-operator">$</span> encode msg<span class="org-rainbow-delimiters-depth-1">)</span>
      snsSink topic
</pre>
</div>

<p>
Putting it to use can be done with something like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="org-haskell-operator">...</span>
  awsEnv <span class="org-haskell-operator">&lt;-</span> newEnv <span class="org-haskell-constructor">Discover</span>
  runAWSCond awsEnv <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">&lt;</span>source producing <span class="org-haskell-constructor">Value</span><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-operator">.|</span> snsSink topicArn

  <span class="org-haskell-keyword">where</span>
    runAWSCond awsEnv <span class="org-haskell-operator">=</span> runResourceT <span class="org-haskell-operator">.</span> runAWS awsEnv <span class="org-haskell-operator">.</span> within <span class="org-haskell-constructor">Frankfurt</span> <span class="org-haskell-operator">.</span> C.runConduit
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-amazonka.html">amazonka</a> <a href="https://magnus.therning.org/tag-aws.html">aws</a> <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>]]></description>
  <category><![CDATA[amazonka]]></category>
  <category><![CDATA[aws]]></category>
  <category><![CDATA[conduit]]></category>
  <category><![CDATA[haskell]]></category>
  <link>https://magnus.therning.org/2020-11-11-2222-combining_amazonka_and_conduit.html</link>
  <pubDate>Wed, 11 Nov 2020 22:22:00 +0100</pubDate>
</item>
<item>
  <title><![CDATA[X-Ray and WAI]]></title>
  <description><![CDATA[
<p>
For a while we've been planning on introducing <a href="https://aws.amazon.com/xray/">AWS X-Ray</a> into our system at
work. There's official support for a few languages, but not too surprisingly
Haskell isn't on that list. I found <a href="https://github.com/freckle/aws-xray-client">freckle/aws-xray-client</a> on GitHub, which is
so unofficial that it isn't even published on Hackage. While it looks very good,
I suspect it does more than I need and since it lacks licensing information I
decided to instead implement a version tailored to our needs.
</p>

<p>
As a first step I implemented a WAI <i>middleware</i> that wraps an HTTP request and
reports the time it took to produce a response. Between the <a href="https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html">X-Ray Developer
Guide</a> and the code in Freckle's git repo it turned out to be fairly simple.
</p>

<p>
First off, this is the first step towards X-Ray nirvana, so all I'm aiming for
is minimal support. That means all I want is to send <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html#api-segmentdocuments-fields">minimal X-Ray segment</a>s,
with the small addition that I want to support <code>parent_id</code> from the start.
</p>

<p>
The first step then is to parse the HTTP header containing the X-Ray information
&#x2013; <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader"><code>X-Amzn-Trace-Id</code></a>. For now I'm only interested in two parts, <code>Root</code> and
<code>Parent</code>, so for simplicity's sake I use a tuple to keep them in. The idea is to
take the header's value, split on <code>;</code> to get the parts, then split each part in
two, a key and a value, and put them into an association list (<code>[(Text, Text)]</code>)
for easy lookup using, well <code>lookup</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">parseXRayTraceIdHdr</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">parseXRayTraceIdHdr</span> hdr <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  bits <span class="org-haskell-operator">&lt;-</span> traverse parseHeaderComponent <span class="org-haskell-operator">$</span> T.split <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">==</span> <span class="org-string">';'</span><span class="org-rainbow-delimiters-depth-1">)</span> hdr
  traceId <span class="org-haskell-operator">&lt;-</span> lookup <span class="org-string">"Root"</span> bits
  <span class="org-haskell-keyword">let</span> parent <span class="org-haskell-operator">=</span> lookup <span class="org-string">"Parent"</span> bits
  pure <span class="org-rainbow-delimiters-depth-1">(</span>traceId, parent<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">parseHeaderComponent</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">parseHeaderComponent</span> cmp <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> T.split <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">==</span> <span class="org-string">'='</span><span class="org-rainbow-delimiters-depth-1">)</span> cmp <span class="org-haskell-keyword">of</span>
                            <span class="org-rainbow-delimiters-depth-1">[</span>name, value<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-rainbow-delimiters-depth-1">(</span>name, value<span class="org-rainbow-delimiters-depth-1">)</span>
                            <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
</pre>
</div>

<p>
The start and end times for processing a request are also required. The docs say
that using at least millisecond resolution is a good idea, so I decided to do
exactly that. <code>NominalDiffTime</code>, which is what <code>getPOSIXTime</code> produces, supports
a resolution of picoseconds (though I doubt my system's clock does) which
requires a bit of (type-based) converting.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mkTimeInMilli</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Milli</span>
<span class="org-haskell-definition">mkTimeInMilli</span> <span class="org-haskell-operator">=</span> ndfToMilli <span class="org-haskell-operator">&lt;$&gt;</span> getPOSIXTime
  <span class="org-haskell-keyword">where</span>
    ndfToMilli <span class="org-haskell-operator">=</span> fromRational <span class="org-haskell-operator">.</span> toRational
</pre>
</div>

<p>
The last support function needed is one that creates the segment. Just
building the JSON object, using <i>aeson</i>'s <code>object</code>, is enough at this
point.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mkSegment</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Milli</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Milli</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">mkSegment</span> name id startTime endTime <span class="org-rainbow-delimiters-depth-1">(</span>root, parent<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span>
  object <span class="org-haskell-operator">$</span> <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-string">"name"</span> <span class="org-haskell-operator">.=</span> name
           , <span class="org-string">"id"</span> <span class="org-haskell-operator">.=</span> id
           , <span class="org-string">"trace_id"</span> <span class="org-haskell-operator">.=</span> root
           , <span class="org-string">"start_time"</span> <span class="org-haskell-operator">.=</span> startTime
           , <span class="org-string">"end_time"</span> <span class="org-haskell-operator">.=</span> endTime
           <span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">&lt;&gt;</span> p
  <span class="org-haskell-keyword">where</span>
    p <span class="org-haskell-operator">=</span> maybe <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> v <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"parent_id"</span> <span class="org-haskell-operator">.=</span> v<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> parent
</pre>
</div>

<p>
Armed with all this, I can now put together a WAI middleware that
</p>

<ol class="org-ol">
<li>records the start time of the call</li>
<li>processes the request</li>
<li>sends off the response and keeps the result of it</li>
<li>records the end time</li>
<li>parses the tracing header</li>
<li>builds the segment prepended with the <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-api-sendingdata.html#xray-api-daemon">X-Ray daemon header</a></li>
<li>sends the segment to the X-Ray daemon</li>
</ol>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">traceId</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Middleware</span>
<span class="org-haskell-definition">traceId</span> xrayName app req sendResponse <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  startTime <span class="org-haskell-operator">&lt;-</span> mkTimeInMilli
  app req <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span> res <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
    rr <span class="org-haskell-operator">&lt;-</span> sendResponse res
    endTime <span class="org-haskell-operator">&lt;-</span> mkTimeInMilli
    theId <span class="org-haskell-operator">&lt;-</span> T.pack <span class="org-haskell-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> v <span class="org-haskell-operator">-&gt;</span> showHex v <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;$&gt;</span> randomIO <span class="org-haskell-operator">@</span><span class="org-haskell-constructor">Word64</span>
    <span class="org-haskell-keyword">let</span> traceParts <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>decodeUtf8 <span class="org-haskell-operator">&lt;$&gt;</span> requestHeaderTraceId req<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;=</span> parseXRayTraceIdHdr
        segment <span class="org-haskell-operator">=</span> mkSegment xrayName theId startTime endTime <span class="org-haskell-operator">&lt;$&gt;</span> traceParts
    <span class="org-haskell-keyword">case</span> segment <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> pure <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
      <span class="org-haskell-constructor">Just</span> segment' <span class="org-haskell-operator">-&gt;</span> sendXRayPayload <span class="org-haskell-operator">$</span> toStrict <span class="org-haskell-operator">$</span> prepareXRayPayload segment'
    pure rr

  <span class="org-haskell-keyword">where</span>
    prepareXRayPayload segment <span class="org-haskell-operator">=</span>
      <span class="org-haskell-keyword">let</span> header <span class="org-haskell-operator">=</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"format"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"json"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-string">"version"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
      <span class="org-haskell-keyword">in</span> encode header <span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">"\n"</span> <span class="org-haskell-operator">&lt;&gt;</span> encode segment

    sendXRayPayload payload <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      addrInfos <span class="org-haskell-operator">&lt;-</span> S.getAddrInfo <span class="org-haskell-constructor">Nothing</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Just</span> <span class="org-string">"127.0.0.1"</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Just</span> <span class="org-string">"2000"</span><span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-keyword">case</span> addrInfos <span class="org-haskell-keyword">of</span>
        <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> pure <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-comment-delimiter">-- </span><span class="org-comment">silently skip</span>
        <span class="org-rainbow-delimiters-depth-1">(</span>xrayAddr<span class="org-haskell-constructor">:</span><span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
          sock <span class="org-haskell-operator">&lt;-</span> S.socket <span class="org-rainbow-delimiters-depth-1">(</span>S.addrFamily xrayAddr<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">S.Datagram</span> S.defaultProtocol
          S.connect sock <span class="org-rainbow-delimiters-depth-1">(</span>S.addrAddress xrayAddr<span class="org-rainbow-delimiters-depth-1">)</span>
          sendAll sock payload
          S.close sock
</pre>
</div>

<p>
The next step will be to instrument the actual processing. The service I'm
instrumenting is asynchronous, so all the work happens <i>after</i> the response has
been sent. My plan for this is to use subsegments to record it. That means I'll
have to
</p>

<ul class="org-ul">
<li>keep the <code>Root</code> and ID (<code>theId</code> in <code>traceId</code> above) for use in subsegments</li>
<li>keep the original tracing header, for use in outgoing calls</li>
<li>make sure all outgoing HTTP calls include a tracing header with a proper
<code>Parent</code></li>
<li>wrap all outgoing HTTP calls with time keeping and sending a subsegment to the
X-Ray daemon</li>
</ul>

<p>
I'm saving that work for a rainy day though, or rather, for a day when I'm so
upset at Clojure that I don't want to see another parenthesis.
</p>

<p>
<i>Edit (2020-04-10):</i> Corrected the segment field name for the parent ID, it
should be <code>parent_id</code>.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-aws.html">AWS</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-xray.html">XRay</a> </div>]]></description>
  <category><![CDATA[AWS]]></category>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[XRay]]></category>
  <link>https://magnus.therning.org/2020-04-08-000-xray-and-wai.html</link>
  <pubDate>Wed, 08 Apr 2020 12:00:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[My ghcide build for Nix]]></title>
  <description><![CDATA[
<p>
I was slightly disappointed to find out that not all packages on Hackage that
are marked as present in <a href="https://nixos.org/nixpkgs/">Nix(pkgs)</a> actually are available. Quite a few of them
are marked broken and hence not installable. One of these packages is <a href="https://hackage.haskell.org/package/ghcide">ghcide</a>.
</p>

<p>
There are of course expressions available for getting a working <code>ghcide</code>
executable installed, like <a href="https://github.com/hercules-ci/ghcide-nix">ghcide-nix</a>. However, since I have rather simple needs
for my Haskell projects I thought I'd play with my own approach to it.
</p>

<p>
What I care about is:
</p>

<ol class="org-ol">
<li>availability of the development tools I use, at the moment it's mainly
<code>ghcide</code> but I'm planning on making use of <a href="https://hackage.haskell.org/package/ormolu">ormolu</a> in the near future</li>
<li>pre-built packages</li>
<li>ease of use</li>
</ol>

<p>
So, I put together <a href="https://github.com/magthe/ghcide-for-nix">ghcide-for-nix</a>. It's basically just a constumized Nixpkgs
where the packages needed to un-break <code>ghcide</code> are present.
</p>

<p>
Usage is a simple <code>import</code> away:
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-nix-builtin">import</span> <span class="org-rainbow-delimiters-depth-1">(</span>builtins.fetchGit <span class="org-rainbow-delimiters-depth-2">{</span>
  <span class="org-nix-attribute">name</span> = <span class="org-string">"ghcide-for-nix"</span>;
  <span class="org-nix-attribute">url</span> = <span class="org-nix-constant">https://github.com/magthe/ghcide-for-nix</span>;
  <span class="org-nix-attribute">rev</span> = <span class="org-string">"927a8caa62cece60d9d66dbdfc62b7738d61d75f"</span>;
<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
and it'll give you a superset of Nixpkgs. Pre-built packages are available on
<a href="https://magthe.cachix.org/">Cachix</a>.
</p>

<p>
It's not sophisticated, but it's rather easy to use and suffices for my
purposes.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[nix]]></category>
  <link>https://magnus.therning.org/2020-02-02-000-my-ghcide-build-for-nix.html</link>
  <pubDate>Sun, 02 Feb 2020 12:00:00 +0100</pubDate>
</item>
<item>
  <title><![CDATA[Haskell, ghcide, and Spacemacs]]></title>
  <description><![CDATA[
<p>
The other day I read Chris Penner's post on <a href="https://chrispenner.ca/posts/hie-core">Haskell IDE Support</a> and thought I'd
make an attempt to use it with Spacemacs.
</p>

<p>
After running <code>stack build hie-bios ghcide haskell-lsp --copy-compiler-tool</code> I
had a look at the <a href="https://github.com/haskell/haskell-ide-engine#using-hie-with-spacemacs">instructions on using <code>haskell-ide-engine</code> with Spacemacs</a>.
After a bit of trial and error I came up with these changes to my
<code>~/.spacemacs</code>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">dotspacemacs/layers</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq-default</span>
   dotspacemacs-configuration-layers
   '<span class="org-rainbow-delimiters-depth-3">(</span>
    ...
    lsp
    <span class="org-rainbow-delimiters-depth-4">(</span>haskell <span class="org-builtin">:variables</span>
             haskell-completion-backend 'lsp
             <span class="org-rainbow-delimiters-depth-4">)</span>
    ...<span class="org-rainbow-delimiters-depth-3">)</span>
  <span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">dotspacemacs/user-config</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq</span> lsp-haskell-process-args-hie '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"exec"</span> <span class="org-string">"ghcide"</span> <span class="org-string">"--"</span> <span class="org-string">"--lsp"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        lsp-haskell-process-path-hie <span class="org-string">"stack"</span>
        lsp-haskell-process-wrapper-function <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>argv<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">(</span>cons <span class="org-rainbow-delimiters-depth-5">(</span>car argv<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span>cddr argv<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>add-hook 'haskell-mode-hook
            #'lsp<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The slightly weird looking <code>lsp-haskell-process-wrapper-function</code> is removing
the pesky <code>--lsp</code> inserted by <a href="https://github.com/emacs-lsp/lsp-haskell/blob/64106be79350f9ce6903d22c66b29761dadb5001/lsp-haskell.el#L179">this line</a>.
</p>

<p>
That seems to work. Though I have to say I'm not ready to switch from <a href="https://hackage.haskell.org/package/intero">intero</a>
just yet. Two things in particular didn't work with =ghcide=/LSP:
</p>

<ol class="org-ol">
<li>Switching from one the <code>Main.hs</code> in one executable to the <code>Main.hs</code> of
another executable in the same project didn't work as expected &#x2013; I had hints
and types in the first, but nothing in the second.</li>
<li>Jump to the definition of a function defined in the package didn't work &#x2013;
I'm not willing to use <a href="https://www.gnu.org/software/global/">GNU GLOBAL</a> or some other source tagging system.</li>
</ol>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-lsp.html">lsp</a> <a href="https://magnus.therning.org/tag-spacemacs.html">spacemacs</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[lsp]]></category>
  <category><![CDATA[spacemacs]]></category>
  <link>https://magnus.therning.org/2019-09-19-000-haskell--ghcide--and-spacemacs.html</link>
  <pubDate>Thu, 19 Sep 2019 12:34:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[Hedgehog on a REST API, part 3]]></title>
  <description><![CDATA[
<p>
In my previous post on using Hedgehog on a REST API, <a href="2019-06-23-000-hedgehog-on-a-rest-api--part-2.html">Hedgehog on a REST API,
part 2</a> I ran the test a few times and adjusted the model to deal with the
incorrect assumptions I had initially made. In particular, I had to adjust how I
modelled the <i>User ID</i>. Because of the simplicity of the API that wasn't too
difficult. However, that kind of completely predictable ID isn't found in all
APIs. In fact, it's not uncommon to have completely random IDs in API (often
they are <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>s).
</p>

<p>
So, I set out to try to deal with that. I'm still using the simple API from the
previous posts, but this time I'm pretending that I can't build the ID into the
model myself, or, put another way, I'm capturing the ID from the responses.
</p>

<div id="outline-container-orgca4a77b" class="outline-2">
<h2 id="orgca4a77b">The model state</h2>
<div class="outline-text-2" id="text-orgca4a77b">
<p>
When capturing the ID it's no longer possible to use a simple <code>Map Int Text</code> for
the state, because I don't actually have the ID until I have an HTTP response.
However, the ID is playing an important role in the constructing of a sequence
of actions. The trick is to use <code>Var Int v</code> instead of an ordinary <code>Int</code>. As I
understand it, and I believe that's a good enough understanding to make use of
Hedgehog possible, is that this way the ID is an opaque blob in the construction
phase, and it's turned into a concrete value during execution. When in the
opaque state it implements enough type classes to be useful for my purposes.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Var</span> <span class="org-haskell-constructor">Int</span> v<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge3fe138" class="outline-2">
<h2 id="orge3fe138">The API calls: add user</h2>
<div class="outline-text-2" id="text-orge3fe138">
<p>
When taking a closer look at the <a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#t:Callback"><code>Callback</code></a> type not all the callbacks will get
the state in the same form, opaque or concrete, and one of them, <code>Update</code>
actually receives the state in both states depending on the phase of execution.
This has the most impact on the add user action. To deal with it there's a need
to rearrange the code a bit, to be specific, <code>commandExecute</code> can no longer
return a tuple of both the ID and the status of the HTTP response because the
update function can't reach into the tuple, which it needs to update the state.
</p>

<p>
That means the <code>commandExecute</code> function will have to do tests too. It <i>is</i> nice
to keep all tests in the callbacks, but by sticking a <code>MonadTest m</code> constraint
on the <code>commandExecute</code> it turns into a nice solution anyway.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m, <span class="org-haskell-type">MonadTest</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                           <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.text <span class="org-rainbow-delimiters-depth-1">(</span>Range.linear <span class="org-highlight-numbers-number">0</span> <span class="org-highlight-numbers-number">42</span><span class="org-rainbow-delimiters-depth-1">)</span> Gen.alpha

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      <span class="org-rainbow-delimiters-depth-1">(</span>s, ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
        mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
        addReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/users"</span>
        <span class="org-haskell-keyword">let</span> addReq' <span class="org-haskell-operator">=</span> addReq <span class="org-rainbow-delimiters-depth-1">{</span> requestBody <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RequestBodyLBS</span> <span class="org-rainbow-delimiters-depth-2">(</span>encode <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">User</span> <span class="org-highlight-numbers-number">0</span> n<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>
        addResp <span class="org-haskell-operator">&lt;-</span> httpLbs addReq' mgr
        <span class="org-haskell-keyword">let</span> user <span class="org-haskell-operator">=</span> decode <span class="org-rainbow-delimiters-depth-1">(</span>responseBody addResp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">User</span>
        return <span class="org-rainbow-delimiters-depth-1">(</span>responseStatus addResp, user<span class="org-rainbow-delimiters-depth-1">)</span>
      status201 <span class="org-haskell-operator">===</span> s
      assert <span class="org-haskell-operator">$</span> isJust ui
      <span class="org-rainbow-delimiters-depth-1">(</span>userName <span class="org-haskell-operator">&lt;$&gt;</span> ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">Just</span> n
      return <span class="org-haskell-operator">$</span> userId <span class="org-haskell-operator">$</span> fromJust ui

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.insert o n m<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I found that once I'd come around to folding the <code>Ensure</code> callback into the
<code>commandExecute</code> function the rest fell out from the types.
</p>
</div>
</div>

<div id="outline-container-orgf9cfdae" class="outline-2">
<h2 id="orgf9cfdae">The API calls: delete user</h2>
<div class="outline-text-2" id="text-orgf9cfdae">
<p>
The other actions, deleting a user and getting a user, required only minor
changes and the changes were rather similar in both cases.
</p>

<p>
Not the type for the action needs to take a <code>Var Int v</code> instead of just a plain
<code>Int</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Var</span> <span class="org-haskell-constructor">Int</span> v<span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Which in turn affect the implementation of <code>HTraversable</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-haskell-keyword">where</span>
  htraverse f <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> vi<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> htraverse f vi
</pre>
</div>

<p>
Then the changes to the <code>Command</code> mostly comprise use of <a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#v:concrete"><code>concrete</code></a> in places
where the real ID is needed.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                              , <span class="org-haskell-constructor">Require</span> r
                              , <span class="org-haskell-constructor">Ensure</span> e
                              <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
      ks <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.element ks

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> vi<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      delReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"DELETE http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show <span class="org-rainbow-delimiters-depth-1">(</span>concrete vi<span class="org-rainbow-delimiters-depth-1">)</span>
      delResp <span class="org-haskell-operator">&lt;-</span> httpNoBody delReq mgr
      return <span class="org-haskell-operator">$</span> responseStatus delResp

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.delete i m

    r <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> i <span class="org-haskell-operator">`elem`</span> M.keys m

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> r <span class="org-haskell-operator">=</span> r <span class="org-haskell-operator">===</span> status200
</pre>
</div>
</div>
</div>

<div id="outline-container-org24f01b8" class="outline-2">
<h2 id="org24f01b8">Conclusion</h2>
<div class="outline-text-2" id="text-org24f01b8">
<p>
This post concludes my playing around with state machines in Hedgehog for this
time. I certainly hope I find the time to put it to use on some larger API soon.
In particular I'd love to put it to use at work; I think it'd be an excellent
addition to the integration tests we currently have.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hedgehog.html">hedgehog</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[hedgehog]]></category>
  <category><![CDATA[testing]]></category>
  <link>https://magnus.therning.org/2019-08-19-000-hedgehog-on-a-rest-api--part-3.html</link>
  <pubDate>Mon, 19 Aug 2019 12:34:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[Architecture of a service]]></title>
  <description><![CDATA[
<p>
Early this summer it was finally time to put this one service I've been working
on into our sandbox environment. It's been running without hickups so last week
I turned it on for production as well. In this post I thought I'd document the
how and why of the service in the hope that someone will find it useful.
</p>

<p>
The service functions as an interface to external SMS-sending services, offering
a single place to change if we find that we are unhappy with the service we're
using.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> This service replaces an older one, written in Ruby and no one really
dares touch it. Hopefully the Haskell version will prove to be a joy to work
with over time.
</p>

<div id="outline-container-orga8a66cc" class="outline-2">
<h2 id="orga8a66cc">Overview of the architecture</h2>
<div class="outline-text-2" id="text-orga8a66cc">
<p>
The service is split into two parts, one web server using <a href="https://hackage.haskell.org/package/scotty">scotty</a>, and streaming
data processing using <a href="https://hackage.haskell.org/package/conduit">conduit</a>. Persistent storage is provided by a <a href="https://www.postgresql.org/">PostgreSQL</a>
database. The general idea is that events are picked up from the database, acted
upon, which in turn results in other events which written to the database. Those
are then picked up and round and round we go. The web service accepts requests,
turns them into events and writes the to the database.
</p>

<p>
Hopefully this crude diagram clarifies it somewhat.
</p>


<figure id="org603b78a">
<img src="static/2019-08-10-architecture.png" alt="2019-08-10-architecture.png">

<figcaption><span class="figure-number">Figure 1: </span>Diagram of the service architecture</figcaption>
</figure>

<p>
There are a few things that might need some explanation
</p>

<ul class="org-ul">
<li><p>
In the past we've wanted to have the option to use multiple external SMS
services at the same time. One is randomly chosen as the request comes in.
There's also a possibility to configure the frequency for each external
service.
</p>

<p>
<i>Picker</i> implements the random picking and I've written about that earlier in
<a href="2019-02-17-000-choosing-a-conduit-randomly.html">Choosing a conduit randomly</a>.
</p>

<p>
<i>Success</i> and <i>fail</i> are dummy senders. They don't actually send anything, and
the former succeeds at it while the latter fails. I found them useful for
manual testing.
</p></li>

<li><p>
Successfully sending off a request to an external SMS service, getting status
200 back, doesn't actually mean that the SMS has been sent, or even that it
ever will be. Due to the nature of SMS messaging there are no guarantees of
timeliness at all. Since we are interested in finding out whether an SMS
actually is sent a delayed action is scheduled, which will fetch the status of
a sent SMS after a certain time (currently 2 minutes). If an SMS hasn't been
sent after that time it might as well never be &#x2013; it's too slow for our
end-users.
</p>

<p>
This is what <i>report-fetcher</i> and <i>fetcher-func</i> do.
</p></li>

<li>The <i>queue sink</i> and <i>queue src</i> are actually <a href="https://hackage.haskell.org/package/stm-conduit-4.0.1/docs/Data-Conduit-TQueue.html#v:sourceTQueue"><code>sourceTQueue</code></a> and <a href="https://hackage.haskell.org/package/stm-conduit-4.0.1/docs/Data-Conduit-TQueue.html#v:sinkTQueue"><code>sinkTQueue</code></a>.
Splitting the stream like that makes it trivial to push in events by using
<a href="https://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM-TQueue.html#v:writeTQueue"><code>writeTQueue</code></a>.</li>

<li>I use <a href="https://hackage.haskell.org/package/conduit-1.3.1.1/docs/Data-Conduit.html#v:sequenceConduits"><code>sequenceConduits</code></a> in order to send a single event to multiple
=Conduit=s and then combine all their results back into a single stream. The
ease with which this can be done in <a href="https://hackage.haskell.org/package/conduit">conduit</a> is one of the main reasons why I
choose to use it.<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup></li>
</ul>
</div>
</div>

<div id="outline-container-org495919d" class="outline-2">
<h2 id="org495919d">Effects and tests</h2>
<div class="outline-text-2" id="text-org495919d">
<p>
I started out writing everything based on a type like <code>ReaderT &lt;my cfg type&gt; IO</code>
and using <code>liftIO</code> for effects that needed lifting. This worked nicely while I
was setting up the basic structure of the service, but as soon as I hooked in
the database I really wanted to do some testing also of the effectful code.
</p>

<p>
After reading <a href="https://serokell.io/blog/2018/12/07/tagless-final">Introduction to Tagless Final</a> and
<a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">The ReaderT Design Patter</a>, playing a bit with both approaches, and writing
<a href="2019-01-20-000-tagless-final-and-scotty.html">Tagless final and Scotty</a> and
<a href="2019-02-02-000-the-readert-design-pattern-or-tagless-final-.html">The ReaderT design pattern or tagless final?</a>, I finally chose to go down the route
of <i>tagless final</i>. There's no strong reason for that decision, maybe it was
just because I read about it first and found it very easy to move in that
direction in small steps.
</p>

<p>
There's a split between property tests and unit tests:
</p>

<ul class="org-ul">
<li>Data types, their monad instances (like JSON (de-)serialisation), pure
functions and a few effects are tested using properties. I'm using <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>
for that. I've since looked a little closer at <a href="https://hackage.haskell.org/package/hedgehog">hedgehog</a> and if I were to do a
major overhaul of the property tests I might be tempted to rewrite them using
that library instead.</li>

<li>Most of the =Conduit=s are tested using <a href="https://hackage.haskell.org/package/HUnit">HUnit</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-orged81fcb" class="outline-2">
<h2 id="orged81fcb">Configuration</h2>
<div class="outline-text-2" id="text-orged81fcb">
<p>
The service will be run in a container and we try to follow the <a href="https://12factor.net/">12-factor app
rules</a>, where the third one says that configuration should be stored in the
environment. All previous Haskell projects I've worked on have been command line
tools were configuration is done (mostly) using command line argument. For that
I usually use <a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a>, but it's not applicable in this setting.
</p>

<p>
After a bit of searching on <a href="https://hackage.haskell.org/">hackage</a> I settled on <a href="https://hackage.haskell.org/package/etc">etc</a>. It turned out to be nice
an easy to work with. The configuration is written in JSON and only specifies
environment variables. It's then embedded in the executable using <a href="https://hackage.haskell.org/package/file-embed">file-embed</a>.
The only thing I miss is a <a href="https://hackage.haskell.org/package/aeson/docs/Data-Aeson.html#t:ToJSON"><code>ToJSON</code></a> instance for <a href="https://hackage.haskell.org/package/etc-0.4.1.0/docs/System-Etc.html#t:Config"><code>Config</code></a> &#x2013; we've found it
quite useful to log the active configuration when starting a service and that
log entry would become a bit nicer if the message was JSON rather than the
(somewhat difficult to read) string that <code>Config</code>'s <code>Show</code> instance produces.
</p>
</div>
</div>

<div id="outline-container-orgf3bc0ed" class="outline-2">
<h2 id="orgf3bc0ed">Logging</h2>
<div class="outline-text-2" id="text-orgf3bc0ed">
<p>
There are two requirements we have when it comes to logging
</p>

<ol class="org-ol">
<li>All log entries tied to a request should have a <a href="https://hilton.org.uk/blog/microservices-correlation-id">correlation ID</a>.</li>
<li>Log requests and responses</li>
</ol>

<p>
I've written about correlation ID before, <a href="2018-10-01-000-using-a-configuration-in-scotty.html">Using a configuration in Scotty</a>.
</p>

<p>
Logging requests and responses is an area where I'm not very happy with <a href="https://hackage.haskell.org/package/scotty">scotty</a>.
It feels natural to solve it using middleware (i.e. using <a href="https://hackage.haskell.org/package/scotty/docs/Web-Scotty.html#v:middleware"><code>middleware</code></a>) but the
representation, especially of responses, is a bit complicated so for the time
being I've skipped logging the body of both. I'd be most interested to hear of
libraries that could make that easier.
</p>
</div>
</div>

<div id="outline-container-org5f31ed4" class="outline-2">
<h2 id="org5f31ed4">Data storage and picking up new events</h2>
<div class="outline-text-2" id="text-org5f31ed4">
<p>
The data stream processing depends heavily on being able to pick up when new
events are written to the database. Especially when there are more than one
instance running (we usually have at least two instance running in the
production environment). To get that working I've used <a href="https://hackage.haskell.org/package/postgresql-simple">postgresql-simple</a>'s
support for <a href="https://www.postgresql.org/docs/current/sql-listen.html"><code>LISTEN</code></a> and <a href="https://www.postgresql.org/docs/current/sql-notify.html"><code>NOTIFY</code></a> via the function <a href="https://hackage.haskell.org/package/postgresql-simple-0.6.2/docs/Database-PostgreSQL-Simple-Notification.html#v:getNotification"><code>getNotification</code></a>.
</p>

<p>
When I wrote about this earlier, <a href="2019-03-03-000-conduit-and-postgresql.html">Conduit and PostgreSQL</a> I got some really good
feedback that made my solution more robust.
</p>
</div>
</div>

<div id="outline-container-org04b2853" class="outline-2">
<h2 id="org04b2853">Delayed actions</h2>
<div class="outline-text-2" id="text-org04b2853">
<p>
Some things in Haskell feel almost like cheating. The light-weight threading
makes me confident that a <a href="https://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkIO"><code>forkIO</code></a> followed by a <a href="https://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:threadDelay"><code>threadDelay</code></a> (or in my case,
the ones from <a href="https://hackage.haskell.org/package/unliftio">unliftio</a>) will suffice.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
It has happened in the past that we've changed SMS service after finding
that they weren't living up to our expectations.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
A while ago I was experimenting with other streaming libraries, but I
gave up on getting re-combination to work &#x2013; <a href="2018-10-16-000-zipping-streams.html">Zipping streams</a>
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> <a href="https://magnus.therning.org/tag-scotty.html">scotty</a> <a href="https://magnus.therning.org/tag-postgresql.html">postgresql</a> <a href="https://magnus.therning.org/tag-tagless_final.html">tagless_final</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[conduit]]></category>
  <category><![CDATA[scotty]]></category>
  <category><![CDATA[postgresql]]></category>
  <category><![CDATA[tagless_final]]></category>
  <link>https://magnus.therning.org/2019-08-10-000-architecture-of-a-service.html</link>
  <pubDate>Sat, 10 Aug 2019 12:34:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[Hedgehog on a REST API, part 2]]></title>
  <description><![CDATA[
<p>
This is a short follow-up to <a href="2019-05-30-000-hedgehog-on-a-rest-api.html">Hedgehog on a REST API</a> where I actually run the
tests in that post.
</p>

<div id="outline-container-org27855a2" class="outline-2">
<h2 id="org27855a2">Fixing an issue with the model</h2>
<div class="outline-text-2" id="text-org27855a2">
<p>
The first issue I run into is
</p>

<pre class="example" id="orgdd312b9">
 Main 
   sequential failed after 18 tests and 1 shrink.

         tst/test-01.hs 
     89  getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     90  getUser = Command gen exec [ Require r
     91                             , Ensure e
     92                             ]
     93    where
     94      gen (State m) = case M.keys m of
     95        [] -&gt; Nothing
     96        ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     97 
     98      exec (GetUser i) = liftIO $ do
     99        mgr &lt;- newManager defaultManagerSettings
    100        getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
    101        getResp &lt;- httpLbs getReq mgr
    102        let us = decode $ responseBody getResp :: Maybe [User]
    103        return (status200 == responseStatus getResp, us)
    104 
    105      r (State m) (GetUser i) = i `elem` M.keys m
    106 
    107      e _ _ (GetUser _) (r, us) = do
    108        r === True
    109        assert $ isJust us
    110        (length &lt;$&gt; us) === Just 1
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
                Failed (- lhs =/= + rhs)
                - Just 0
                + Just 1

         tst/test-01.hs 
    118  prop_seq :: Property
    119  prop_seq = property $ do
    120    actions &lt;- forAll $ Gen.sequential (Range.linear 1 10) initialState [addUser, deleteUser, getUser]
            Var 0 = AddUser ""
            Var 1 = GetUser 1
    121    resetWS
    122    executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 17) (Seed 2158538972777046104 (-1442908127347265675)) sequential

   1 failed.
</pre>

<p>
It's easy to verify this using <a href="https://httpie.org/">httpie</a>:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ http -p b POST :3000/users userId:=<span class="org-highlight-numbers-number">0</span> <span class="org-string">"userName="</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-string">"userId"</span>: <span class="org-highlight-numbers-number">0,</span>
    <span class="org-string">"userName"</span>: <span class="org-string">""</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
$ http -p b GET :3000/users/1
<span class="org-rainbow-delimiters-depth-1">[]</span>
</pre>
</div>

<p>
It's clear that my assumption that <i>User ID</i> starts at 1 is wrong. Luckily
fixing that isn't too difficult. Instead of defining the update function for
<code>addUser</code> as
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">u</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> _o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.insert k n m
  <span class="org-haskell-keyword">where</span>
    k <span class="org-haskell-operator">=</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.keys m<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I define it as
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">u</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> _o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.insert k n m
  <span class="org-haskell-keyword">where</span>
    k <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-highlight-numbers-number">0</span>
      ks <span class="org-haskell-operator">-&gt;</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> ks
</pre>
</div>

<p>
The complete code at this point can be found <a href="https://gist.github.com/8cbbfdb130a173bb51c317df0c00aa15">here</a>.
</p>
</div>
</div>

<div id="outline-container-org9c34f53" class="outline-2">
<h2 id="org9c34f53">Fixing another issue with the model</h2>
<div class="outline-text-2" id="text-org9c34f53">
<p>
With that fix in place another issue with the model shows up
</p>

<pre class="example" id="orga71bb89">
 Main 
   sequential failed after 74 tests and 2 shrinks.

         tst/test-01.hs 
     91  getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     92  getUser = Command gen exec [ Require r
     93                             , Ensure e
     94                             ]
     95    where
     96      gen (State m) = case M.keys m of
     97        [] -&gt; Nothing
     98        ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     99 
    100      exec (GetUser i) = liftIO $ do
    101        mgr &lt;- newManager defaultManagerSettings
    102        getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
    103        getResp &lt;- httpLbs getReq mgr
    104        let us = decode $ responseBody getResp :: Maybe [User]
    105        return (status200 == responseStatus getResp, us)
    106 
    107      r (State m) (GetUser i) = i `elem` M.keys m
    108 
    109      e _ _ (GetUser _) (r, us) = do
    110        r === True
    111        assert $ isJust us
    112        (length &lt;$&gt; us) === Just 1
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
                Failed (- lhs =/= + rhs)
                - Just 0
                + Just 1

         tst/test-01.hs 
    120  prop_seq :: Property
    121  prop_seq = property $ do
    122    actions &lt;- forAll $ Gen.sequential (Range.linear 1 10) initialState [addUser, deleteUser, getUser]
            Var 0 = AddUser ""
            Var 1 = DeleteUser 0
            Var 2 = AddUser ""
            Var 3 = GetUser 0
    123    resetWS
    124    executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 73) (Seed 3813043122711576923 (-444438259649958339)) sequential

   1 failed.
</pre>

<p>
Again, verifying this using <a href="https://httpie.org/">httpie</a> shows what the issue is
</p>

<div class="org-src-container">
<pre class="src src-shell">$ http -p b POST :3000/users userId:=<span class="org-highlight-numbers-number">0</span> <span class="org-string">"userName="</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-string">"userId"</span>: <span class="org-highlight-numbers-number">0,</span>
    <span class="org-string">"userName"</span>: <span class="org-string">""</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
$ http -p b DELETE :3000/users/0
$ http -p b POST :3000/users userId:=<span class="org-highlight-numbers-number">0</span> <span class="org-string">"userName="</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-string">"userId"</span>: <span class="org-highlight-numbers-number">1,</span>
    <span class="org-string">"userName"</span>: <span class="org-string">""</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
$ http -p b GET :3000/users/0
<span class="org-rainbow-delimiters-depth-1">[]</span>
</pre>
</div>

<p>
In other words, the model assumes that the 0 <i>User ID</i> get's re-used.
</p>

<p>
To fix this I need a bigger change. The central bit is that the state is changed
to keep track of the index more explicitly. That is, it changes from
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
to
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-constructor">Int</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That change does, quite obviously, require a bunch of other changes in the other
functions dealing with the state. The complete file can be viewed <a href="https://gist.github.com/e3c3f4a3c35ab8a529045f90f9f4ba71">here</a>.
</p>
</div>
</div>

<div id="outline-container-org5f32fc1" class="outline-2">
<h2 id="org5f32fc1">All is well, or is it?</h2>
<div class="outline-text-2" id="text-org5f32fc1">
<p>
After this the tests pass, so all is good in the world, right?
</p>

<p>
In the test I defined the <a href="2019-05-30-000-hedgehog-on-a-rest-api.html#MissingReference">property</a> over rather short sequences of commands. What
happens if I increase the (maximum) length of the sequences a bit? Instead using
<code>Range.linear 1 10</code> I'll use <code>Range.linear 1 1000</code>. Well, besides taking
slightly longer to run I get another sequence of commands that triggers an
issue:
</p>

<pre class="example" id="org112d5bd">
 Main 
   sequential failed after 13 tests and 29 shrinks.

         tst/test-01.hs 
     87  getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     88  getUser = Command gen exec [ Require r
     89                             , Ensure e
     90                             ]
     91    where
     92      gen (State _ m) = case M.keys m of
     93        [] -&gt; Nothing
     94        ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     95 
     96      exec (GetUser i) = liftIO $ do
     97        mgr &lt;- newManager defaultManagerSettings
     98        getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
     99        getResp &lt;- httpLbs getReq mgr
    100        let us = decode $ responseBody getResp :: Maybe [User]
    101        return (status200 == responseStatus getResp, us)
    102 
    103      r (State _ m) (GetUser i) = i `elem` M.keys m
    104 
    105      e _ _ (GetUser _) (r, us) = do
    106        r === True
    107        assert $ isJust us
    108        (length &lt;$&gt; us) === Just 1
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
                Failed (- lhs =/= + rhs)
                - Just 0
                + Just 1

         tst/test-01.hs 
    116  prop_seq :: Property
    117  prop_seq = property $ do
    118    actions &lt;- forAll $ Gen.sequential (Range.linear 1 1000) initialState [addUser, deleteUser, getUser]
            Var 0 = AddUser ""
            Var 2 = AddUser ""
            Var 5 = AddUser ""
            Var 7 = AddUser ""
            Var 9 = AddUser ""
            Var 11 = AddUser ""
            Var 20 = AddUser ""
            Var 28 = AddUser ""
            Var 30 = AddUser ""
            Var 32 = AddUser ""
            Var 33 = AddUser ""
            Var 34 = AddUser ""
            Var 37 = AddUser ""
            Var 38 = AddUser ""
            Var 41 = AddUser ""
            Var 45 = AddUser ""
            Var 47 = GetUser 15
    119    resetWS
    120    executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 12) (Seed 2976784816810995551 (-47094630645854485)) sequential

   1 failed.
</pre>

<p>
That is, after inserting 16 users, we don't see any user when trying to get that
16th user (<i>User ID</i> 15). That's a proper bug in the server.
</p>

<p>
As a matter of fact, this is the bug I put into the server and was hoping to
find. In particular, I wanted <i>hedgehog</i> to find the minimal sequence leading to
this bug.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> Which it clearly has!
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
If you recall from the <a href="2019-05-30-000-hedgehog-on-a-rest-api.html">previous post</a>, I was interested in the integrated
shrinking offered by <i>hedgehog</i>.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hedgehog.html">hedgehog</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[hedgehog]]></category>
  <category><![CDATA[testing]]></category>
  <link>https://magnus.therning.org/2019-06-23-000-hedgehog-on-a-rest-api--part-2.html</link>
  <pubDate>Sun, 23 Jun 2019 12:34:00 +0200</pubDate>
</item>
</channel>
</rss>
