<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://magnus.therning.org/feed.xml"
      title="RSS feed for https://magnus.therning.org/">
<title>Magnus web site</title>
<meta name="author" content="Magnus Therning"><meta name="referrer" content="no-referrer"><link href= "static/style.css" rel="stylesheet" type="text/css" /><link href= "static/htmlize.css" rel="stylesheet" type="text/css" /><link href= "static/extra_style.css" rel="stylesheet" type="text/css" /></head>
<body>
<div id="preamble" class="status"><div class="nav-bar"><a class="nav-link" href="./index.html">Top</a><a class="nav-link" href="./archive.html">Archive</a><a class="nav-link align-right" href="./feed.xml"><img src="static/rss-feed-icon.png" style="height: 24px;" /></a></div></div>
<div id="content">
<h1 class="title">Posts tagged "haskell":</h1>
<div class="post-date">13 Mar 2022</div><h1 class="post-title"><a href="https://magnus.therning.org/2022-03-13-simple-nix-flake-for-haskell-development.html">Simple nix flake for Haskell development</a></h1>
<p>
Recently I've moved over to using <a href="https://nixos.wiki/wiki/Flakes">flakes</a> in my Haskell development projects. It
took me a little while to arrive at a pattern a flake for Haskell development
that I like. I'm hoping sharing it might help others when doing the same change
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">inputs</span> = <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-nix-attribute">nixpkgs.url</span> = <span class="org-string">"github:nixos/nixpkgs"</span>;
    <span class="org-nix-attribute">flake-utils.url</span> = <span class="org-string">"github:numtide/flake-utils"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-nix-attribute">outputs</span> = <span class="org-rainbow-delimiters-depth-2">{</span> self, nixpkgs, flake-utils <span class="org-rainbow-delimiters-depth-2">}</span>:
    flake-utils.lib.eachDefaultSystem <span class="org-rainbow-delimiters-depth-2">(</span>system:
      <span class="org-nix-keyword">with</span> nixpkgs.legacyPackages.$<span class="org-rainbow-delimiters-depth-3">{</span>system<span class="org-rainbow-delimiters-depth-3">}</span>;
      <span class="org-nix-keyword">let</span>
        <span class="org-nix-attribute">t</span> = lib.trivial;
        <span class="org-nix-attribute">hl</span> = haskell.lib;

        <span class="org-nix-attribute">name</span> = <span class="org-string">"project-name"</span>;

        <span class="org-nix-attribute">project</span> = devTools: <span class="org-comment"># [1]</span>
          <span class="org-nix-keyword">let</span> <span class="org-nix-attribute">addBuildTools</span> = <span class="org-rainbow-delimiters-depth-3">(</span>t.flip hl.addBuildTools<span class="org-rainbow-delimiters-depth-3">)</span> devTools;
          <span class="org-nix-keyword">in</span> haskellPackages.developPackage <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-nix-attribute">root</span> = lib.sourceFilesBySuffices <span class="org-nix-constant">./.</span> <span class="org-rainbow-delimiters-depth-4">[</span> <span class="org-string">".cabal"</span> <span class="org-string">".hs"</span> <span class="org-rainbow-delimiters-depth-4">]</span>;
            <span class="org-nix-attribute">name</span> = name;
            <span class="org-nix-attribute">returnShellEnv</span> = !<span class="org-rainbow-delimiters-depth-4">(</span>devTools == <span class="org-rainbow-delimiters-depth-5">[</span> <span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-comment"># [2]</span>

            <span class="org-nix-attribute">modifier</span> = <span class="org-rainbow-delimiters-depth-4">(</span>t.flip t.pipe<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">[</span>
              addBuildTools
              hl.dontHaddock
              hl.enableStaticLibraries
              hl.justStaticExecutables
              hl.disableLibraryProfiling
              hl.disableExecutableProfiling
            <span class="org-rainbow-delimiters-depth-4">]</span>;
          <span class="org-rainbow-delimiters-depth-3">}</span>;

      <span class="org-nix-keyword">in</span> <span class="org-rainbow-delimiters-depth-3">{</span>
        <span class="org-nix-attribute">packages.pkg</span> = project <span class="org-rainbow-delimiters-depth-4">[</span> <span class="org-rainbow-delimiters-depth-4">]</span>; <span class="org-comment"># [3]</span>

        <span class="org-nix-attribute">defaultPackage</span> = self.packages.$<span class="org-rainbow-delimiters-depth-4">{</span>system<span class="org-rainbow-delimiters-depth-4">}</span>.walloper;

        <span class="org-nix-attribute">devShell</span> = project <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-nix-keyword">with</span> haskellPackages; <span class="org-rainbow-delimiters-depth-5">[</span> <span class="org-comment"># [4]</span>
          cabal-fmt
          cabal-install
          haskell-language-server
          hlint
        <span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The main issue I ran into is getting a development shell out of
<code>haskellPackages.developPackage</code>, it requires <code>returnShellEnv</code> to be <code>true</code>.
Something that isn't too easy to find out. This means that the only solution
I've found to getting a development shell is to have separate expressions for
building and getting a shell. In the above flake the build expression, <i>[3]</i>,
passes an empty list of development tools, the argument <code>devTools</code> at <i>[1]</i>,
while the development shell expression, <i>[4]</i>, passes in a list of tools needed
for development only. The decision of whether the expression is for building or
for a development shell, <i>[2]</i>, then looks at the list of development tools
passed in.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>
<div class="post-date">27 Nov 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-11-27-fallback-of-actions.html">Fallback of actions</a></h1>
<p>
In a tool I'm writing I want to load a file that may reside on the local disk,
but if it isn't there I want to fetch it from the web. Basically it's very
similar to having a cache and dealing with a miss, except in my case I don't
populate the cache.
</p>

<p>
Let me first define the functions to play with
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">loadFromDisk</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">loadFromDisk</span> k<span class="org-haskell-operator">@</span><span class="org-string">"bad key"</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"local: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
    pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Left</span> <span class="org-haskell-operator">$</span> <span class="org-string">"no such local key: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
<span class="org-haskell-definition">loadFromDisk</span> k <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"local: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
    pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">$</span> length k

<span class="org-haskell-definition">loadFromWeb</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">loadFromWeb</span> k<span class="org-haskell-operator">@</span><span class="org-string">"bad key"</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"web: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
    pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Left</span> <span class="org-haskell-operator">$</span> <span class="org-string">"no such remote key: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
<span class="org-haskell-definition">loadFromWeb</span> k <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"web: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
    pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">$</span> length k
</pre>
</div>

<div id="outline-container-org92749a7" class="outline-2">
<h2 id="org92749a7">Discarded solution: using the <code>Alternative</code> of <code>IO</code> directly</h2>
<div class="outline-text-2" id="text-org92749a7">
<p>
It's fairly easy to get the desired behaviour but <code>Alternative</code> of <code>IO</code> is based
on exceptions which doesn't strike me as a good idea unless one is using <code>IO</code>
directly. That is fine in a smallish application, but in my case it makes sense
to use tagless style (or <code>ReaderT</code> pattern) so I'll skip exploring this option
completely.
</p>
</div>
</div>

<div id="outline-container-org27ee1de" class="outline-2">
<h2 id="org27ee1de">First attempt: lifting into the <code>Alternative</code> of <code>Either e</code></h2>
<div class="outline-text-2" id="text-org27ee1de">
<p>
There's an instance of <code>Alternative</code> for <code>Either e</code> in version 0.5 of
<a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Error.html#section.orphans">transformers</a>. It's deprecated and it's gone in newer versions of the library as
one really should use <code>Except</code> or <code>ExceptT</code> instead. Even if I don't think it's
where I want to end up, it's not an altogether bad place to start.
</p>

<p>
Now let's define a function using <code>liftA2 (&lt;|&gt;)</code> to make it easy to see what the
behaviour is
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">::</span>
    <span class="org-haskell-type">Applicative</span> m <span class="org-haskell-operator">=&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> res<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">=</span> liftA2 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">&lt;|&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example" id="org487a7ea">
λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "good key"
local: bad key
web: good key
Right 8

λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "bad key"
local: bad key
web: bad key
Left "no such remote key: bad key"
</pre>

<p>
The first example shows that it falls back to loading form the web, and the
second one shows that it's only the last failure that survives. The latter part,
that only the last failure survives, isn't ideal but I think I can live with
that. If I were interested in collecting all failures I would reach for
<code>Validation</code> from <a href="https://hackage.haskell.org/package/validation-selective"><code>validation-selective</code></a> (there's one in <a href="https://hackage.haskell.org/package/validation-selective"><code>validation</code></a> that
should work too).
</p>

<p>
So far so good, but the next example shows a behaviour I don't want
</p>

<pre class="example" id="org18412e0">
λ&gt; loadFromDisk "good key" `fallBack` loadFromWeb "good key"
local: good key
web: good key
Right 8
</pre>

<p>
or to make it even more explicit
</p>

<pre class="example" id="org2cb8b01">
λ&gt; loadFromDisk "good key" `fallBack` undefined
local: good key
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err
  undefined, called at &lt;interactive&gt;:451:36 in interactive:Ghci4
</pre>

<p>
There's no short-circuiting!<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<p>
The behaviour I want is of course that if the first action is successful, then
the second action shouldn't take place at all.
</p>

<p>
It looks like either <code>&lt;|&gt;</code> is strict in its second argument, or maybe it's
<code>liftA2</code> that forces it. I've not bothered digging into the details, it's enough
to observe it to realise that this approach isn't good enough.
</p>
</div>
</div>

<div id="outline-container-second-attempt" class="outline-2">
<h2 id="second-attempt">Second attempt: cutting it short, manually</h2>
<div class="outline-text-2" id="text-second-attempt">
<p>
Fixing the lack of short-circuiting the evaluation after the first success isn't
too difficult to do manually. Something like this does it
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">::</span>
    <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">fallBack</span> first other <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    first <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
        r<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Right</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> pure r
        r<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Left</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>r <span class="org-haskell-operator">&lt;|&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;$&gt;</span> other
</pre>
</div>

<p>
It does indeed show the behaviour I want
</p>

<pre class="example" id="orgc4fcdad">
λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "good key"
local: bad key
web: good key
Right 8

λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "bad key"
local: bad key
web: bad key
Left "no such remote key: bad key"

λ&gt; loadFromDisk "good key" `fallBack` undefined
local: good key
Right 8
</pre>

<p>
Excellent! And to switch over to use <code>Validation</code> one just have to switch
constructors, <code>Right</code> becomes <code>Success</code> and <code>Left</code> becomes <code>Failure</code>. Though
collecting the failures by concatenating strings isn't the best idea of course.
Switching to some other <code>Monoid</code> (that's the constraint on the failure type)
isn't too difficult.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">::</span>
    <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Monad</span> m, <span class="org-haskell-type">Monoid</span> e<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Validation</span> e a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Validation</span> e a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Validation</span> e a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">fallBack</span> first other <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    first <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
        r<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Success</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> pure r
        r<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Failure</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>r <span class="org-haskell-operator">&lt;|&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;$&gt;</span> other
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfcd9b93" class="outline-2">
<h2 id="orgfcd9b93">Third attempt: pulling failures out to <code>MonadPlus</code></h2>
<div class="outline-text-2" id="text-orgfcd9b93">
<p>
After writing the <code>fallBack</code> function I still wanted to explore other solutions.
There's almost always something more out there in the Haskell eco system, right?
So I asked in the <i>#haskell-beginners</i> channel on the Functional Programming
Slack. The way I asked the question resulted in answers that iterates over a
list of actions and cutting at the first success.
</p>

<p>
The first suggestion had me a little confused at first, but once I re-organised
the helper function a little it made more sense to me.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mFromRight</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadPlus</span> m <span class="org-haskell-operator">=&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> m res
<span class="org-haskell-definition">mFromRight</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>either <span class="org-rainbow-delimiters-depth-2">(</span>const mzero<span class="org-rainbow-delimiters-depth-2">)</span> return <span class="org-haskell-operator">=&lt;&lt;</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
To use it put the actions in a list, map the helper above, and finally run
<code>asum</code> on it all<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>. I think it makes it a little clearer what happens if
it's rewritten like this.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">firstRightM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadPlus</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>m <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> m res
<span class="org-haskell-definition">firstRightM</span> <span class="org-haskell-operator">=</span> asum <span class="org-haskell-operator">.</span> fmap go
  <span class="org-haskell-keyword">where</span>
    go m <span class="org-haskell-operator">=</span> m <span class="org-haskell-operator">&gt;&gt;=</span> either <span class="org-rainbow-delimiters-depth-1">(</span>const mzero<span class="org-rainbow-delimiters-depth-1">)</span> return
</pre>
</div>

<pre class="example" id="orgc7c1789">
λ&gt; firstRightM [loadFromDisk "bad key", loadFromWeb "good key"]
local: bad key
web: good key
8

λ&gt; firstRightM [loadFromDisk "good key", undefined]
local: good key
8
</pre>

<p>
So far so good, but I left out the case where both fail, because that's sort of
the fly in the ointment here
</p>

<pre class="example" id="orge0f6d87">
λ&gt; firstRightM [loadFromDisk "bad key", loadFromWeb "bad key"]
local: bad key
web: bad key
*** Exception: user error (mzero)
</pre>

<p>
It's not nice to be back to deal with exceptions, but it's possible to recover,
e.g. by appending <code>&lt;|&gt; pure 0</code>.
</p>

<pre class="example" id="org1370a54">
λ&gt; firstRightM [loadFromDisk "bad key", loadFromWeb "bad key"] &lt;|&gt; pure 0
local: bad key
web: bad key
0
</pre>

<p>
However that removes the ability to deal with the situation where all actions
fail. Not nice! Add to that the difficulty of coming up with a <i>good</i>
<code>MonadPlus</code> instance for an application monad; one basically have to resort to
the same thing as for <code>IO</code>, i.e. to throw an exception. Also not nice!
</p>
</div>
</div>

<div id="outline-container-fourth-attempt" class="outline-2">
<h2 id="fourth-attempt">Fourth attempt: wrapping in <code>ExceptT</code> to get its <code>Alternative</code> behaviour</h2>
<div class="outline-text-2" id="text-fourth-attempt">
<p>
This was another suggestion from the Slack channel, and it is the one I like the
most. Again it was suggested as a way to stop at the first successful action in
a list of actions.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">firstRightM</span> <span class="org-haskell-operator">::</span>
    <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Foldable</span> t, <span class="org-haskell-type">Functor</span> t, <span class="org-haskell-type">Monad</span> m, <span class="org-haskell-type">Monoid</span> err<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span>
    t <span class="org-rainbow-delimiters-depth-1">(</span>m <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">firstRightM</span> <span class="org-haskell-operator">=</span> runExceptT <span class="org-haskell-operator">.</span> asum <span class="org-haskell-operator">.</span> fmap <span class="org-haskell-constructor">ExceptT</span>
</pre>
</div>

<p>
Which can be used similarly to the previous one. It's also easy to write a
variant of <code>fallBack</code> for it.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">::</span>
    <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Monad</span> m, <span class="org-haskell-type">Monoid</span> err<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">fallBack</span> first other <span class="org-haskell-operator">=</span> runExceptT <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">ExceptT</span> first <span class="org-haskell-operator">&lt;|&gt;</span> <span class="org-haskell-constructor">ExceptT</span> other
</pre>
</div>

<pre class="example" id="org4634f2c">
λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "good key"
local: bad key
web: good key
Right 8

λ&gt; loadFromDisk "good key" `fallBack` undefined
local: good key
Right 8

λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "bad key"
local: bad key
web: bad key
Left "no such local key: bad keyno such remote key: bad key"
</pre>

<p>
Yay! This solution has the short-circuiting behaviour I want, as well as
collecting all errors on failure.
</p>
</div>
</div>

<div id="outline-container-org8c1dc5a" class="outline-2">
<h2 id="org8c1dc5a">Conclusion</h2>
<div class="outline-text-2" id="text-org8c1dc5a">
<p>
I'm still a little disappointed that <code>liftA2 (&lt;|&gt;)</code> isn't short-circuiting as I
still think it's the easiest of the approaches. However, it's a problem that one
has to rely on a deprecated instance of <code>Alternative</code> for <code>Either String</code>,
but switching to use <code>Validation</code> would be only a minor change.
</p>

<p>
Manually writing the <code>fallBack</code> function, as I did in the <a href="#second-attempt">second attempt</a>,
results in very explicit code which is nice as it often reduces the cognitive
load for the reader. It's a contender, but using the deprecated <code>Alternative</code>
instance is problematic and introducing <code>Validition</code>, an arguably not very
common type, takes away a little of the appeal.
</p>

<p>
In the end I prefer the <a href="#fourth-attempt">fourth attempt</a>. It behaves exactly like I want and even
though <code>ExpectT</code> lives in <i>transformers</i> I feel that it (I pull it in via <i>mtl</i>)
is in such wide use that most Haskell programmers will be familiar with it.
</p>

<p>
One final thing to add is that the <a href="https://hackage.haskell.org/package/validation-selective-0.1.0.1/docs/Validation.html">documentation of <code>Validation</code></a> is an excellent
inspiration when it comes to the behaviour of its instances. I wish that the
documentation of other packages, in particular commonly used ones like <i>base</i>,
<i>transformers</i>, and <i>mtl</i>, would be more like it.
</p>
</div>
</div>

<div id="outline-container-org7bea582" class="outline-2">
<h2 id="org7bea582">Comments, feedback, and questions</h2>
<div class="outline-text-2" id="text-org7bea582">
</div>
<div id="outline-container-org3eb4528" class="outline-3">
<h3 id="org3eb4528"><span class="timestamp-wrapper"><span class="timestamp">[2021-11-28 Sun] </span></span> Dustin Sallings</h3>
<div class="outline-text-3" id="text-org3eb4528">
<div class="notes" id="orgdacc0c2">
<p>
Dustin sent me a comment via email a while ago, it's now March 2022 so it's
taken me embarrassingly long to publish it here.
</p>

<p>
I removed a bit from the beginning of the email as it doesn't relate to this
post.
</p>

</div>

<p>
&#x2026; a thing I've written code for before that I was reasonably pleased with. I
have a suite of software for managing my GoPro media which involves doing some
metadata extraction from images and video. There will be multiple transcodings
of each medium with each that contains the metadata having it completely intact
(i.e., low quality encodings do not lose metadata fidelity). I also run this on
multiple machines and store a cache of Metadata in S3.
</p>

<p>
Sometimes, I've already processed the metadata on another machine. Often, I can
get it from the lowest quality. Sometimes, there's no metadata at all. The core
of my extraction looks like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell">ms <span class="org-haskell-operator">&lt;-</span> asum <span class="org-rainbow-delimiters-depth-1">[</span>
  <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">.</span> BL.toStrict <span class="org-haskell-operator">&lt;$&gt;</span> getMetaBlob mid,
  fv <span class="org-string">"mp4_low"</span> <span class="org-rainbow-delimiters-depth-2">(</span>fn <span class="org-string">"low"</span><span class="org-rainbow-delimiters-depth-2">)</span>,
  fv <span class="org-string">"high_res_proxy_mp4"</span> <span class="org-rainbow-delimiters-depth-2">(</span>fn <span class="org-string">"high"</span><span class="org-rainbow-delimiters-depth-2">)</span>,
  fv <span class="org-string">"source"</span> <span class="org-rainbow-delimiters-depth-2">(</span>fn <span class="org-string">"src"</span><span class="org-rainbow-delimiters-depth-2">)</span>,
  pure <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
The first version grabs the processed blob from S3. The next three fetch (and
process) increasingly larger variants of the uploaded media. The last one just
gives up and says there's no metadata available (and memoizes that in the local
DB and S3).
</p>

<p>
Some of these objects are in the tens of gigs, and I had a really bad internet
connection when I first wrote this software, so I needed it to work.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I'm not sure if it's a good term to use in this case as <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">Wikipedia</a> says
it's for Boolean operators. I hope it's not too far a stretch to use it in this
context too.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
In the version of <i>base</i> I'm using there is no <code>asum</code>, so I simply copied
the implementation from a later version:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">asum</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Foldable</span> t, <span class="org-haskell-type">Alternative</span> f<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> t <span class="org-rainbow-delimiters-depth-1">(</span>f a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> f a
<span class="org-haskell-definition">asum</span> <span class="org-haskell-operator">=</span> foldr <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">&lt;|&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> empty
</pre>
</div></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-alternative_typeclass.html">alternative_typeclass</a> <a href="https://magnus.therning.org/tag-caching.html">caching</a> <a href="https://magnus.therning.org/tag-fallback.html">fallback</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>
<div class="post-date">28 Sep 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-09-28-using-lens-to-set-a-value-based-on-another.html">Using lens to set a value based on another</a></h1>
<p>
I started writing a small tool for work that consumes YAML files and combines
the data into a single YAML file. To be specific it consumes YAML files
containing snippets of service specification for <a href="https://docs.docker.com/compose/">Docker Compose</a> and it produces
a YAML file for use with <code>docker-compose</code>. Besides being useful to me, I thought
it'd also be a good way to get some experience with <a href="https://hackage.haskell.org/package/lens">lens</a>.
</p>

<p>
The first transformation I wanted to write was one that puts in the correct
image name. So, only slightly simplified, it is transforming
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span class="org-variable-name">panda</span>:
    <span class="org-variable-name">x-image</span>: panda
<span class="org-variable-name">goat</span>:
    <span class="org-variable-name">x-image</span>: goat
<span class="org-variable-name">tapir</span>:
    <span class="org-variable-name">image</span>: incorrent
    <span class="org-variable-name">x-image</span>: tapir
</pre>
</div>

<p>
into
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span class="org-variable-name">panda</span>:
    <span class="org-variable-name">image</span>: panda:latest
    <span class="org-variable-name">x-image</span>: panda
<span class="org-variable-name">goat</span>:
    <span class="org-variable-name">image</span>: goat:latest
    <span class="org-variable-name">x-image</span>: goat
<span class="org-variable-name">tapir</span>:
    <span class="org-variable-name">image</span>: tapir:latest
    <span class="org-variable-name">x-image</span>: tapir
</pre>
</div>

<p>
That is, it creates a new key/value pair in each object based on the value of
<code>x-image</code> in the same object.
</p>

<div id="outline-container-org3bb936a" class="outline-2">
<h2 id="org3bb936a">First approach</h2>
<div class="outline-text-2" id="text-org3bb936a">
<p>
The first approach I came up with was to traverse the sub-objects and apply a
function that adds the <code>image</code> key.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">setImage</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">setImage</span> y <span class="org-haskell-operator">=</span> y <span class="org-haskell-operator">&amp;</span> members <span class="org-haskell-operator">%~</span> setImg
  <span class="org-haskell-keyword">where</span>
    setImg o <span class="org-haskell-operator">=</span>
        o
            <span class="org-haskell-operator">&amp;</span> _Object <span class="org-haskell-operator">.</span> at <span class="org-string">"image"</span>
            <span class="org-haskell-operator">?~</span> <span class="org-haskell-constructor">String</span> <span class="org-rainbow-delimiters-depth-1">(</span>o <span class="org-haskell-operator">^.</span> key <span class="org-string">"x-image"</span> <span class="org-haskell-operator">.</span> _String <span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">":latest"</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
It did make me wonder if this kind of problem, setting a value based on another
value, isn't so common that there's a nicer solution to it. Perhaps coded up in
a combinator that isn't mentioned in <a href="https://leanpub.com/optics-by-example">Optics By Example</a> (or mabye I've forgot it
was mentioned). That lead me to ask around a bit, which leads to approach two.
</p>
</div>
</div>

<div id="outline-container-orgf55f462" class="outline-2">
<h2 id="orgf55f462">Second approach</h2>
<div class="outline-text-2" id="text-orgf55f462">
<p>
Arguably there isn't much difference, it's still traversing the sub-objects and
applying a function. The function makes use of <code>view</code> being run in a monad and
<code>ASetter</code> being defined with <code>Identity</code> (a monad).
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">setImage'</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">setImage'</span> y <span class="org-haskell-operator">=</span>
    y
        <span class="org-haskell-operator">&amp;</span> members <span class="org-haskell-operator">.</span> _Object
        <span class="org-haskell-operator">%~</span> <span class="org-rainbow-delimiters-depth-1">(</span>set <span class="org-rainbow-delimiters-depth-2">(</span>at <span class="org-string">"image"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">.</span> <span class="org-rainbow-delimiters-depth-2">(</span>_Just <span class="org-haskell-operator">.</span> _String <span class="org-haskell-operator">%~</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">":latest"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&lt;&lt;</span> view <span class="org-rainbow-delimiters-depth-2">(</span>at <span class="org-string">"x-image"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I haven't made up my mind on whether I like this better than the first. It's
disappointingly similar to the first one.
</p>
</div>
</div>

<div id="outline-container-orge880fe2" class="outline-2">
<h2 id="orge880fe2">Third approach</h2>
<div class="outline-text-2" id="text-orge880fe2">
<p>
Then I it might be nice to split the fetching of <code>x-image</code> values from the
addition of <code>image</code> key/value pairs. By extracting with an index it's possible
to keep track of what sub-object each <code>x-image</code> value comes from. Then two steps
can be combined using <code>foldl</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">setImage''</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">setImage''</span> y <span class="org-haskell-operator">=</span> foldl setOne y vals
  <span class="org-haskell-keyword">where</span>
    vals <span class="org-haskell-operator">=</span> y <span class="org-haskell-operator">^@..</span> members <span class="org-haskell-operator">&lt;.</span> key <span class="org-string">"x-image"</span> <span class="org-haskell-operator">.</span> _String
    setOne y' <span class="org-rainbow-delimiters-depth-1">(</span>objKey, value<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span>
        y'
            <span class="org-haskell-operator">&amp;</span> key objKey <span class="org-haskell-operator">.</span> _Object <span class="org-haskell-operator">.</span> at <span class="org-string">"image"</span>
            <span class="org-haskell-operator">?~</span> <span class="org-haskell-constructor">String</span> <span class="org-rainbow-delimiters-depth-1">(</span>value <span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">":latest"</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I'm not convinced though. I guess I'm still holding out for a brilliant
combinator that fits my problem perfectly.
</p>

<p>
Please point me to "the perfect solution" if you have one, or if you just have
some general tips on optics that would make my code clearer, or shorter, or more
elegant, or maybe just more lens-y.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-lens.html">lens</a> <a href="https://magnus.therning.org/tag-optics.html">optics</a> </div>
<div class="post-date">03 Jul 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-07-03-the-timeout-manager-exception.html">The timeout manager exception</a></h1>
<p>
The other day I bumped the dependencies of a Haskell project at work and noticed
a new exception being thrown:
</p>

<blockquote>
<p>
Thread killed by timeout manager
</p>
</blockquote>

<p>
After a couple of false starts (it wasn't the <a href="https://hackage.haskell.org/package/resource-pool">connection pool</a>, nor was it
<a href="https://hackage.haskell.org/package/servant">servant</a>) I realised that a better approach would be to look at the list of
packages that were updated as part of the dependency bumping.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> Most of them
I thought would be <span class="underline">very</span> unlikely sources of it, but two in the list stood out:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Package</th>
<th scope="col" class="org-right">Pre</th>
<th scope="col" class="org-right">Post</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="https://hackage.haskell.org/package/unliftio">unliftio</a></td>
<td class="org-right">0.2.14</td>
<td class="org-right">0.2.18</td>
</tr>

<tr>
<td class="org-left"><a href="https://hackage.haskell.org/package/warp">warp</a></td>
<td class="org-right">3.3.15</td>
<td class="org-right">3.3.16</td>
</tr>
</tbody>
</table>

<p>
<code>warp</code> since the exception seemed to be thrown shortly after handling an HTTP
request, and <code>unliftio</code> since the exception was caught by the handler for
uncaught exceptions and its description contains "thread". Also, when looking at
the code changes in <code>warp</code> on GitHub<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> I found that some of the changes
introduced was increased use of <code>unliftio</code> for async stuff. The changes contain
mentions of <code>TimeoutThread</code> and <code>System.TimeManager</code>. That sounded promising,
and it lead me to the <a href="https://hackage.haskell.org/package/time-manager-0.0.0/docs/System-TimeManager.html#t:TimeoutThread">TimeoutThread</a> exception in <a href="https://hackage.haskell.org/package/time-manager">time-manager</a>.
</p>

<p>
With that knowledge I could quickly adjust the handler for uncaught exceptions
to not log <code>TimeoutThread</code> as fatal:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">lastExceptionHandler</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">SomeException</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">lastExceptionHandler</span> logger e
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-constructor">TimeoutThread</span> <span class="org-haskell-operator">&lt;-</span> fromException e <span class="org-haskell-operator">=</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
  <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      logFatalIoS logger <span class="org-haskell-operator">$</span> pack <span class="org-haskell-operator">$</span> <span class="org-string">"uncaught exception: "</span> <span class="org-haskell-operator">&lt;&gt;</span> displayException e
      flushLogStr logger
</pre>
</div>

<p>
I have to say it was a bit more work to arrive at this than I'd have liked. I
reckon there are easier ways to track down the information I needed. So I'd love
to hear what tricks and tips others have.
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
As a bonus it gave me a good reason to reach for <a href="https://man7.org/linux/man-pages/man1/comm.1.html"><code>comm</code></a>, a command that I
rarely use but for some reason always enjoy.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
GitHub's compare feature isn't very easy to discover, but a URL like this
<a href="https://github.com/yesodweb/wai/compare/warp-3.3.15...warp-3.3.16">https://github.com/yesodweb/wai/compare/warp-3.3.15&#x2026;warp-3.3.16</a> (note the 3
dots!) does the trick.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-warp.html">warp</a> <a href="https://magnus.therning.org/tag-servant.html">servant</a> </div>
<div class="post-date">27 Jun 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-06-27-a-first-look-at-hmock.html">A first look at HMock</a></h1>
<p>
The other day I found Chris Smith's <a href="https://itnext.io/hmock-first-rate-mocks-in-haskell-e59d7c3b066c">HMock: First Rate Mocks in Haskell</a> (<a href="https://hackage.haskell.org/package/HMock">link to
hackage</a>) and thought it could be nice see if it can clear up some of the tests I
have in a few of the Haskell projects at work. All the projects follow the
pattern of defining custom monads for effects (something like final tagless)
with instances implemented on a stack of monads from MTL. It's a pretty standard
thing in Haskell I'd say, especially since the monad stack very often ends up
being <code>ReaderT MyConfig IO</code>.
</p>

<p>
I decided to try it first on a single such custom monad, one for making HTTP
requests:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadHttpClient</span> m <span class="org-haskell-keyword">where</span>
  mHttpGet <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Status</span>, <span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span>
  mHttpPost <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Typeable</span> a, <span class="org-haskell-type">Postable</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Status</span>, <span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Yes, the underlying implementation uses <a href="https://hackage.haskell.org/package/wreq">wreq</a>, but I'm not too bothered by that
shining through. Also, initially I didn't have that <code>Typeable a</code> constraint on
<code>mHttpPost</code>, it got added after a short <a href="https://github.com/cdsmith/HMock/issues/1">exchange about <code>KnownSymbol</code></a> with Chris.
</p>

<p>
To dip a toe in the water I thought I'd simply write tests for the two effects
themselves. First of all there's an impressive list of extensions needed, and
then the monad needs to be made mockable:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE DataKinds #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE GADTs #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE ImportQualifiedPost #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE RankNTypes #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeApplications #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeFamilies #-}</span>

<span class="org-haskell-definition">makeMockable</span> ''<span class="org-haskell-constructor">MonadHttpClient</span>
</pre>
</div>

<p>
After that, writing a test with HMock for <code>mHttpGet</code> was fairly straight
forward, I could simply follow the examples in the package's documentation. I'm
using <a href="https://hackage.haskell.org/package/tasty">tasty</a> for organising the tests though:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">httpGetTest</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">TestTree</span>
<span class="org-haskell-definition">httpGetTest</span> <span class="org-haskell-operator">=</span> testCase <span class="org-string">"Get"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  <span class="org-rainbow-delimiters-depth-1">(</span>s, b<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> runMockT <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    expect <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MHttpGet</span> <span class="org-string">"url"</span> <span class="org-haskell-operator">|-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>status200, <span class="org-string">"result"</span><span class="org-rainbow-delimiters-depth-1">)</span>
    mHttpGet <span class="org-string">"url"</span>
  status200 <span class="org-haskell-operator">@=?</span> s
  <span class="org-string">"result"</span> <span class="org-haskell-operator">@=?</span> b
</pre>
</div>

<p>
The effect for sending a <code>POST</code> request was slightly trickier, as can be seen in
the issue linked above, but with some help I came up with the following:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">httpPostTest</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">TestTree</span>
<span class="org-haskell-definition">httpPostTest</span> <span class="org-haskell-operator">=</span> testCase <span class="org-string">"Post"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  <span class="org-rainbow-delimiters-depth-1">(</span>s, b<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> runMockT <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    expect <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MHttpPost_</span> <span class="org-rainbow-delimiters-depth-1">(</span>eq <span class="org-string">"url"</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>typed <span class="org-haskell-operator">@</span><span class="org-haskell-constructor">ByteString</span> anything<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">|-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>status201, <span class="org-string">"result"</span><span class="org-rainbow-delimiters-depth-1">)</span>
    mHttpPost <span class="org-string">"url"</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span>
  status201 <span class="org-haskell-operator">@=?</span> s
  <span class="org-string">"result"</span> <span class="org-haskell-operator">@=?</span> b
</pre>
</div>

<div id="outline-container-org07a2709" class="outline-2">
<h2 id="org07a2709">Next step</h2>
<div class="outline-text-2" id="text-org07a2709">
<p>
My hope is that using HMock will remove the need for creating a bunch of test
implementations for the various custom monads for effects<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> in the projects,
thereby reducing the amount of test code overall. I also suspect that it will
make the tests clearer and easier to read, as the behaviour of the mocks are
closer to the tests using the mocks.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Basically they could be looked at as hand-written mocks.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> <a href="https://magnus.therning.org/tag-mocks.html">mocks</a> </div>
<div class="post-date">07 May 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-05-07-working-with-hedis.html">Working with Hedis</a></h1>
<p>
I'm now writing the second Haskell service using <a href="https://redis.io/commands/incrby">Redis</a> to store data. There are
a few packages on <a href="https://hackage.haskell.org/">Hackage</a> related to Redis but I only found 2 client libraries,
<a href="https://hackage.haskell.org/package/redis-io">redis-io</a> and <a href="https://hackage.haskell.org/package/hedis">hedis</a>. I must say I like the API of redis-io better, but it breaks
a rule I hold very dear:
</p>

<blockquote>
<p>
Libraries should never log, that's the responsibility of the application.
</p>
</blockquote>

<p>
So, hedis it is. I tried using the API as is, but found it really cumbersome so
looked around and after some inspiration from <a href="https://hackage.haskell.org/package/hedis-simple">hedis-simple</a> I came up with the
following functions.
</p>

<p>
First a wrapper around a Redis function that put everything into <code>ExceptionT</code>
with a function that transforms a <code>reply</code> into an <code>Exception</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">lpush</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Exception</span> e <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Reply</span> <span class="org-haskell-operator">-&gt;</span> e<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ExceptionT</span> <span class="org-haskell-type">Redis</span> <span class="org-haskell-type">Integer</span>
<span class="org-haskell-definition">lpush</span> mapper key element <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ExceptionT</span> <span class="org-haskell-operator">$</span> replyToExc <span class="org-haskell-operator">&lt;$&gt;</span> R.lpush key element
  <span class="org-haskell-keyword">where</span>
    replyToExc <span class="org-haskell-operator">=</span> first <span class="org-rainbow-delimiters-depth-1">(</span>toException <span class="org-haskell-operator">.</span> mapper<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I found wrapping up functions like this is simple, but repetitive.
</p>

<p>
Finally I need a way to run the whole thing and unwrap it all back to <code>IO</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">runRedis</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Connection</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ExceptionT</span> <span class="org-haskell-type">Redis</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">SomeException</span> a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">runRedis</span> conn <span class="org-haskell-operator">=</span> R.runRedis conn <span class="org-haskell-operator">.</span> runExceptionT
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-redis.html">redis</a> </div>
<div class="post-date">21 Apr 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-04-21-first-contribution-to-nixpkgs.haskellpackages.html">First contribution to nixpkgs.haskellPackages</a></h1>
<p>
Nothing much to be proud of, but yesterday I found out that <a href="https://hackage.haskell.org/package/servant-docs">servant-docs</a> was
marked broken in <span class="underline">nixpkgs</span> even though it builds just fine and this morning I
decided to do something about it.
</p>

<p>
So, with the help of a <a href="https://discourse.nixos.org/t/call-to-action-for-updating-haskell-packages-after-bump-to-lts-15/6071">post on the NixOS discourse</a> I put together my first <a href="https://github.com/NixOS/nixpkgs/pull/120026">PR</a>.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-nix.html">nix</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>
<div class="post-date">20 Mar 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-03-20-barbie-and-json.html">Barbie and <strike>Ken</strike>JSON</a></h1>
<p>
After higher-kinded data (HKD) and <a href="https://hackage.haskell.org/package/barbies">barbies</a> were mentioned in <a href="https://haskellweekly.news/episode/35.html">episode 35 of
Haskell Weekly</a> I've been wondering if it could be used in combination with <a href="https://hackage.haskell.org/package/aeson">aeson</a>
to do validation when implementing web services.
</p>

<p>
TLDR; I think it'd work, but I have a feeling I'd have to spend some more time
on it to get an API with nice ergonomics.
</p>

<div id="outline-container-orga9a9fc9" class="outline-2">
<h2 id="orga9a9fc9">Defining a type to play with</h2>
<div class="outline-text-2" id="text-orga9a9fc9">
<p>
I opted to use <a href="https://hackage.haskell.org/package/barbies-th">barbies-th</a> to save on the typing a bit. Defining a simple type
holding a name and an age can then look like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">declareBareB</span>
  <span class="org-rainbow-delimiters-depth-1">[</span>d<span class="org-haskell-operator">|</span>
   <span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Person</span> <span class="org-rainbow-delimiters-depth-2">{</span>name <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span>, age <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-haskell-operator">|</span><span class="org-rainbow-delimiters-depth-1">]</span>

<span class="org-haskell-keyword">deriving</span> <span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Show</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">deriving</span> <span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Show</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">deriving</span> <span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Show</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The two functions from the <code>Barbies</code> module documentation, <code>addDefaults</code> and
<code>check</code>, can then be written like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">addDefaults</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span>
<span class="org-haskell-definition">addDefaults</span> <span class="org-haskell-operator">=</span> bzipWith trans
  <span class="org-haskell-keyword">where</span>
    trans m d <span class="org-haskell-operator">=</span> maybe d pure m

<span class="org-haskell-definition">check</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Either</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">check</span> pe <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> btraverse <span class="org-rainbow-delimiters-depth-1">(</span>either <span class="org-rainbow-delimiters-depth-2">(</span>const <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">.</span> <span class="org-haskell-constructor">Identity</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> pe <span class="org-haskell-keyword">of</span>
  <span class="org-haskell-constructor">Just</span> pin <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Right</span> pin
  <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Left</span> <span class="org-haskell-operator">$</span> bfoldMap <span class="org-rainbow-delimiters-depth-1">(</span>either <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-3">[]</span></span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>const <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-3">[]</span></span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> pe
</pre>
</div>

<p>
I found it straight forward to define some instances and play with those
functions a bit.
</p>
</div>
</div>

<div id="outline-container-orgc68301e" class="outline-2">
<h2 id="orgc68301e">Adding in JSON</h2>
<div class="outline-text-2" id="text-orgc68301e">
<p>
The bit that wasn't immediately obvious to me was how to use aeson to parse into
a type like <code>Person Covered (Either Text)</code>.
</p>

<p>
First off I needed some data to test things out with.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">bs0, bs1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span>
<span class="org-haskell-definition">bs0</span> <span class="org-haskell-operator">=</span> <span class="org-string">"{\"name\": \"the name\", \"age\": 17}"</span>
<span class="org-haskell-definition">bs1</span> <span class="org-haskell-operator">=</span> <span class="org-string">"{\"name\": \"the name\", \"age\": true}"</span>
</pre>
</div>

<p>
To keep things simple I took baby steps, first I tried parsing into <code>Person
Covered Identity</code>. It turns out that the <code>FromJSON</code> instance from that doesn't
need much thought at all. (It's a bit of a pain to have to specify types in GHCi
all the time, so I'm throwing in a specialised decoding function for each type
too.)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">FromJSON</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  parseJSON <span class="org-haskell-operator">=</span> withObject <span class="org-string">"Person"</span> <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">\</span>o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Person</span> <span class="org-haskell-operator">&lt;$&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"name"</span>
      <span class="org-haskell-operator">&lt;*&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"age"</span>

<span class="org-haskell-definition">decodePI</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">decodePI</span> <span class="org-haskell-operator">=</span> decode
</pre>
</div>

<p>
Trying it out on the test data gives the expected results
</p>

<pre class="example" id="orgbe631ca">
λ&gt; let i0 = decodePI bs0
λ&gt; i0
Just (Person {name = Identity "the name", age = Identity 17})
λ&gt; let i1 = decodePI bs1
λ&gt; i1
Nothing
</pre>

<p>
So far so good! Moving onto <code>Person Covered Maybe</code>. I spent some time trying to
use the combinators in <code>Data.Aeson</code> for dealing with parser failures, but in the
end I had to resort to using <code>&lt;|&gt;</code> from <code>Alternative</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">FromJSON</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  parseJSON <span class="org-haskell-operator">=</span> withObject <span class="org-string">"Person"</span> <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">\</span>o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Person</span> <span class="org-haskell-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>o <span class="org-haskell-operator">.:</span> <span class="org-string">"name"</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-operator">&lt;*&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>o <span class="org-haskell-operator">.:</span> <span class="org-string">"age"</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">decodePM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">decodePM</span> <span class="org-haskell-operator">=</span> decode
</pre>
</div>

<p>
Trying that out I saw exactly the behaviour I expected, i.e. that parsing won't
fail. (Well, at least not as long as it's a valid JSON object to being with.)
</p>

<pre class="example" id="orgec185e3">
λ&gt; let m0 = decodePM bs0
λ&gt; m0
Just (Person {name = Just "the name", age = Just 17})
λ&gt; let m1 = decodePM bs1
λ&gt; m1
Just (Person {name = Just "the name", age = Nothing})
</pre>

<p>
With that done I found that the instance for <code>Person Covered (Either Text)</code>
followed quite naturally. I had to spend a little time on getting the types
right to parse the fields properly. Somewhat disappointingly I didn't get type
errors when the behaviour of the code turned out to be wrong. I'm gussing
aeson's <code>Parser</code> was a little too willing to give me parser failures. Anyway, I
ended up with this instance
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">FromJSON</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  parseJSON <span class="org-haskell-operator">=</span> withObject <span class="org-string">"Person"</span> <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">\</span>o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Person</span> <span class="org-haskell-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">&lt;$&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"name"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Left</span> <span class="org-string">"A name is most needed"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-operator">&lt;*&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">&lt;$&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"age"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Left</span> <span class="org-string">"An integer age is needed"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">decodePE</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">decodePE</span> <span class="org-haskell-operator">=</span> decode
</pre>
</div>

<p>
That does exhibit the behaviour I want
</p>

<pre class="example" id="orgb5a080b">
λ&gt; let e0 = decodePE bs0
λ&gt; e0
Just (Person {name = Right "the name", age = Right 17})
λ&gt; let e1 = decodePE bs1
λ&gt; e1
Just (Person {name = Right "the name", age = Left "An integer age is needed"})
</pre>
</div>
</div>

<div id="outline-container-orgcfdacc1" class="outline-2">
<h2 id="orgcfdacc1">In closing</h2>
<div class="outline-text-2" id="text-orgcfdacc1">
<p>
I think everyone will agree that the <code>FromJSON</code> instances are increasingly
messy. I think that can be fixed by putting some thought into what a more
pleasing API should look like.
</p>

<p>
I'd also like to mix in validation beyond what aeson offers out-of-the-box,
which really only is "is the field present?" and "does the value have the
correct type?". For instance, Once we know there is a field called <code>age</code>, and
that it's an <code>Int</code>, then we might want to make sure it's non-negitive, or that
the person is at least 18. I'm guessing that wouldn't be too difficult.
</p>

<p>
Finally, I'd love to see examples of using HKDs for parsing/validation in the
wild. It's probably easiest to reach me at <a href="https://mastodon.technology/@magthe">@magthe@mastodon.technology</a>.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hkd.html">hkd</a> <a href="https://magnus.therning.org/tag-json.html">json</a> </div>
<div class="post-date">19 Mar 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-03-19-custom-monad-with-servant-and-throwing-errors.html">Custom monad with servant and throwing errors</a></h1>
<p>
In the past I've always used <a href="https://hackage.haskell.org/package/scotty">scotty</a> when writing web services. This was mostly
due to laziness, I found working out how to use scotty a lot easier than
<a href="https://hackage.haskell.org/package/servant">servant</a>, so basically I was being lazy. Fairly quickly I bumped into some
limitations in scotty, but at first the workarounds didn't add too much
complexity and were acceptable. A few weeks ago they started weighing on me
though and I decided to look into servant and since I really liked what I found
I've started moving all projects to use servant.
</p>

<p>
In several of the projects I've used tagless final style and defined a type
based on <code>ReaderT</code> holding configuration over <code>IO</code>, that is something like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unAppM <span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor">ReaderT</span> <span class="org-haskell-constructor">Config</span> <span class="org-haskell-constructor">IO</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span>
    <span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-haskell-constructor">Functor</span>,
      <span class="org-haskell-constructor">Applicative</span>,
      <span class="org-haskell-constructor">Monad</span>,
      <span class="org-haskell-constructor">MonadIO</span>,
      <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Config</span>
    <span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> a
<span class="org-haskell-definition">runAppM</span> app <span class="org-haskell-operator">=</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I found that servant is very well suited to this style through <a href="https://hoogle.haskell.org/?hoogle=hoistServer%20is%3Aexact&amp;scope=set:stackage"><code>hoistServer</code></a> and
there are several examples on how to use it with a <code>ReaderT</code>-based type like
above. The first one I found is in the <a href="https://docs.servant.dev/en/stable/cookbook/using-custom-monad/UsingCustomMonad.html">servant cookbook</a>. However, as I realised
a bit later, using a simple type like this doesn't make it easy to trigger
responses with status other than <code>200 OK</code>. When I looked at the definition of
the type for writing handlers that ships with servant, <a href="https://hoogle.haskell.org/?hoogle=Handler%20package%3Aservant-server%20is%3Aexact&amp;scope=set:stackage"><code>Handler</code></a>, I decided to
try to use the following type in my service
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unAppM <span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor">ReaderT</span> <span class="org-haskell-constructor">Config</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">ExceptT</span> <span class="org-haskell-constructor">ServerError</span> <span class="org-haskell-constructor">IO</span><span class="org-rainbow-delimiters-depth-2">)</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span>
    <span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-haskell-constructor">Functor</span>,
      <span class="org-haskell-constructor">Applicative</span>,
      <span class="org-haskell-constructor">Monad</span>,
      <span class="org-haskell-constructor">MonadIO</span>,
      <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Config</span>
    <span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">ServerError</span> a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">runAppM</span> app <span class="org-haskell-operator">=</span> runExceptT <span class="org-haskell-operator">.</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The natural transformation required by <code>hoistServer</code> can then be written like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">nt</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Handler</span> a
<span class="org-haskell-definition">nt</span> x <span class="org-haskell-operator">=</span>
  liftIO <span class="org-rainbow-delimiters-depth-1">(</span>runAppM x cfg<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
    <span class="org-haskell-constructor">Right</span> v <span class="org-haskell-operator">-&gt;</span> pure v
    <span class="org-haskell-constructor">Left</span> err <span class="org-haskell-operator">-&gt;</span> throwError err
</pre>
</div>

<p>
I particularly like how clearly this suggests a way to add custom errors if I
want that.
</p>

<ol class="org-ol">
<li>Swap out <code>ServerError</code> for my custom error type in <code>AppM</code>.</li>
<li>Write a function to transform my custom error type into a <code>ServerError</code>,
<code>transformCustomError :: CustomError -&gt; ServerError</code>.</li>
<li>use <code>throwError $ transformCustomError err</code> in the <code>Left</code> branch of <code>nt</code>.</li>
</ol>

<div id="outline-container-org656a1f3" class="outline-2">
<h2 id="org656a1f3">A slight complication with <code>MonadUnliftIO</code></h2>
<div class="outline-text-2" id="text-org656a1f3">
<p>
I was using <a href="https://hackage.haskell.org/package/unliftio">unliftio</a> in my service, and as long as I based my monad stack only
on <code>ReaderT</code> that worked fine. I even got the <code>MonadUnliftIO</code> instance for free
through automatic deriving. <code>ExceptT</code> isn't a stateless monad though, so using
unliftio is out of the question, instead I had to switch to <a href="https://hoogle.haskell.org/?hoogle=MonadBaseControl%20package%3Amonad-control&amp;scope=set:stackage"><code>MonadBaseControl</code></a>
and the packages that work with it. Defining and instance of <code>MonadBaseControl</code>
looked a bit daunting, but luckily <code>Handler</code> has an instance of it that I used
as inspiration.
</p>

<p>
First off <code>MonadBaseControl</code> requires the type to also be an instance of
<code>MonadBase</code>. There's an explicit implementation for <code>Handler</code>, but I found that
it can be derived automatically, so I took the lazy route.
</p>

<p>
The instance of <code>MonadBaseControl</code> for <code>AppM</code> ended up looking like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadBaseControl</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  <span class="org-haskell-keyword">type</span> <span class="org-haskell-type">StM</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-type">Either</span> <span class="org-haskell-type">ServerError</span> a

  liftBaseWith f <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">(</span>liftBaseWith <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>g <span class="org-haskell-operator">-&gt;</span> f <span class="org-rainbow-delimiters-depth-3">(</span>g <span class="org-haskell-operator">.</span> unAppM<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
  restoreM <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-haskell-operator">.</span> restoreM
</pre>
</div>

<p>
I can't claim to really understand what's going on in that definition, but I
have Alexis King's article on <a href="https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/">Demystifying MonadBaseControl</a> on my list of things
to read.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-servant.html">servant</a> </div>
<div class="post-date">05 Mar 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-03-05-000-flycheck-and-hls.html">Flycheck and HLS</a></h1>
<p>
I've been using LSP for most programming languages for a while now. HLS is
really very good now, but I've found that it doesn't warn on quite all things
I'd like it to so I find myself having to swap between the <code>'lsp</code> and
<code>'haskell-ghc</code> checkers. However, since <a href="https://www.flycheck.org/en/latest/">flycheck</a> supports chaining checkers I
thought there must be a way to have both checkers active at the same time.
</p>

<p>
The naive approach didn't work due to load order of things in Spacemacs so I had
to experiment a bit to find something that works.
</p>

<p>
The first issue was to make sure that HLS is available at all. I use <code>shell.nix</code>
together with <a href="https://direnv.net/">direnv</a> extensively and I had noticed that <code>lsp-mode</code> tried to load
HLS before <code>direnv</code> had put it in the <code>$PATH</code>. I think the
<code>'lsp-beforeinitialize-hook</code> is the hook to use for this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>add-hook 'lsp-before-initialize-hook #'direnv-update-environment<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-rainbow-delimiters-unmatched">)</span>
</pre>
</div>

<p>
I made a several attempt to chain the checkers but kept on getting
errors due to the <code>'lsp</code> checker not being defined yet. Another problem
I ran into was that the checkers were chained too late, resulting in
having to manually run <code>flycheck-buffer</code> on the first file I opened.
(Deferred loading is a brilliant thing, but make some things really
difficult to debug.) After quite a bit of experimenting and reading the
description of various hooks I did find something that works:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">with-eval-after-load</span> 'lsp-mode
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">defun</span> <span class="org-function-name">magthe:lsp-next-checker</span> <span class="org-rainbow-delimiters-depth-3">()</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>flycheck-add-next-checker 'lsp '<span class="org-rainbow-delimiters-depth-4">(</span>warning . haskell-ghc<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>add-hook 'lsp-lsp-haskell-after-open-hook
            #'magthe:lsp-next-checker<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Of course I have no idea if this is the easiest or most elegant solution but it
does work for my testcases:
</p>

<ol class="org-ol">
<li>Open a file in a project, <code>SPC p l</code> - choose project - choose a Haskell file.</li>
<li>Open a project, <code>SPC p l</code> followed by <code>C-d</code>, and then open a Haskell file.</li>
</ol>

<p>
Suggestions for improvements are more than welcome, of course.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-flycheck.html">flycheck</a> </div>
<div class="post-date">30 Nov 2020</div><h1 class="post-title"><a href="https://magnus.therning.org/2020-11-30-1734-haskell__nix_and_using_packages_from_github.html">Haskell, Nix and using packages from GitHub</a></h1>
<p>
The other day I bumped into what turned out to be a <a href="https://mail.haskell.org/pipermail/haskell-cafe/2020-November/133021.html">bug in Amazonka</a> where
sockets weren't closed in a timely fashion and thus the process ran out of file
descriptors. Some more digging and an <a href="https://github.com/brendanhay/amazonka/issues/608">issue</a> later I found that a fix most likely
already in place (mine was possibly a duplicate of an older <a href="https://github.com/brendanhay/amazonka/issues/490">issue</a>). Now I only
had to verify if that was the case by using the most recent, and unreleased code
on the <code>develop</code> branch of Amazonka.
</p>

<p>
My first thought was to attempt to instruct Cabal to build the bits of Amazonka
I need by putting a few <a href="https://cabal.readthedocs.io/en/3.4/cabal-project.html#specifying-packages-from-remote-version-control-locations"><code>source-repository-package</code> stanzas</a> in my config. That
quickly started to look like a bit of a rabbit hole, so I decided to use Nix
instead. After finding the <a href="https://stackoverflow.com/questions/54810851/how-can-i-build-a-haskell-dependency-from-a-github-source-nix-file-using-nix">perfect SO post</a> and looking up yet again how to do
overrides for Haskell I ran <code>cabal2nix</code> for the three packages I need:
</p>

<div class="org-src-container">
<pre class="src src-shell">cabal2nix --no-haddock --no-check --subpath amazonka <span class="org-sh-escaped-newline">\</span>
  git://github.com/brendanhay/amazonka.git &gt; amazonka.nix
cabal2nix --no-haddock --no-check --subpath core <span class="org-sh-escaped-newline">\</span>
  git://github.com/brendanhay/amazonka.git &gt; amazonka-core.nix
cabal2nix --no-haddock --no-check --subpath amazonka-sqs <span class="org-sh-escaped-newline">\</span>
  git://github.com/brendanhay/amazonka.git &gt; amazonka-sqs.nix
</pre>
</div>

<p>
The relevant part of the old Nix expression looked like this:
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-nix-attribute">thePkg</span> = haskellPackages.developPackage <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">root</span> = lib.cleanSource <span class="org-nix-constant">./.</span>;
  <span class="org-nix-attribute">name</span> = name;

  <span class="org-nix-attribute">modifier</span> = <span class="org-rainbow-delimiters-depth-2">(</span>t.flip t.pipe<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">[</span>hl.dontHaddock
     hl.enableStaticLibraries
     hl.justStaticExecutables
     hl.disableLibraryProfiling
     hl.disableExecutableProfiling<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
After adding the overrides it looked like this
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-nix-attribute">hp</span> = haskellPackages.override <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">overrides</span> = self: super: <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-nix-attribute">amazonka-core</span> = self.callPackage <span class="org-nix-constant">./amazonka-core.nix</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
    <span class="org-nix-attribute">amazonka</span> = self.callPackage <span class="org-nix-constant">./amazonka.nix</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
    <span class="org-nix-attribute">amazonka-sqs</span> = self.callPackage <span class="org-nix-constant">./amazonka-sqs.nix</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-nix-attribute">thePkg</span> = hp.developPackage <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">root</span> = lib.cleanSource <span class="org-nix-constant">./.</span>;
  <span class="org-nix-attribute">name</span> = name;

  <span class="org-nix-attribute">modifier</span> = <span class="org-rainbow-delimiters-depth-2">(</span>t.flip t.pipe<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">[</span>hl.dontHaddock
     hl.enableStaticLibraries
     hl.justStaticExecutables
     hl.disableLibraryProfiling
     hl.disableExecutableProfiling<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
After a somewhat longer-than-usual build I could verify that I had indeed bumped
into the same issue and my issue was a duplicate.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>
<div class="post-date">11 Nov 2020</div><h1 class="post-title"><a href="https://magnus.therning.org/2020-11-11-2222-combining_amazonka_and_conduit.html">Combining Amazonka and Conduit</a></h1>
<p>
Combining <a href="https://hackage.haskell.org/package/amazonka">amazonka</a> and <a href="https://hackage.haskell.org/package/conduit">conduit</a> turned out to be easier than I had expected.
</p>

<p>
Here's an SNS sink I put together today
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">snsSink</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadAWS</span> m, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">C.ConduitT</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-type">C.Void</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">snsSink</span> topic <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  C.await <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> pure <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-haskell-constructor">Just</span> msg <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">&lt;-</span> C.lift <span class="org-haskell-operator">$</span> publishSNS topic <span class="org-rainbow-delimiters-depth-1">(</span>TL.toStrict <span class="org-haskell-operator">$</span> TL.decodeUtf8 <span class="org-haskell-operator">$</span> encode msg<span class="org-rainbow-delimiters-depth-1">)</span>
      snsSink topic
</pre>
</div>

<p>
Putting it to use can be done with something like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="org-haskell-operator">...</span>
  awsEnv <span class="org-haskell-operator">&lt;-</span> newEnv <span class="org-haskell-constructor">Discover</span>
  runAWSCond awsEnv <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">&lt;</span>source producing <span class="org-haskell-constructor">Value</span><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-operator">.|</span> snsSink topicArn

  <span class="org-haskell-keyword">where</span>
    runAWSCond awsEnv <span class="org-haskell-operator">=</span> runResourceT <span class="org-haskell-operator">.</span> runAWS awsEnv <span class="org-haskell-operator">.</span> within <span class="org-haskell-constructor">Frankfurt</span> <span class="org-haskell-operator">.</span> C.runConduit
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-amazonka.html">amazonka</a> <a href="https://magnus.therning.org/tag-aws.html">aws</a> <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>
<div class="post-date">08 Apr 2020</div><h1 class="post-title"><a href="https://magnus.therning.org/2020-04-08-000-xray-and-wai.html">X-Ray and WAI</a></h1>
<p>
For a while we've been planning on introducing <a href="https://aws.amazon.com/xray/">AWS X-Ray</a> into our system at
work. There's official support for a few languages, but not too surprisingly
Haskell isn't on that list. I found <a href="https://github.com/freckle/aws-xray-client">freckle/aws-xray-client</a> on GitHub, which is
so unofficial that it isn't even published on Hackage. While it looks very good,
I suspect it does more than I need and since it lacks licensing information I
decided to instead implement a version tailored to our needs.
</p>

<p>
As a first step I implemented a WAI <i>middleware</i> that wraps an HTTP request and
reports the time it took to produce a response. Between the <a href="https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html">X-Ray Developer
Guide</a> and the code in Freckle's git repo it turned out to be fairly simple.
</p>

<p>
First off, this is the first step towards X-Ray nirvana, so all I'm aiming for
is minimal support. That means all I want is to send <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html#api-segmentdocuments-fields">minimal X-Ray segment</a>s,
with the small addition that I want to support <code>parent_id</code> from the start.
</p>

<p>
The first step then is to parse the HTTP header containing the X-Ray information
&#x2013; <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader"><code>X-Amzn-Trace-Id</code></a>. For now I'm only interested in two parts, <code>Root</code> and
<code>Parent</code>, so for simplicity's sake I use a tuple to keep them in. The idea is to
take the header's value, split on <code>;</code> to get the parts, then split each part in
two, a key and a value, and put them into an association list (<code>[(Text, Text)]</code>)
for easy lookup using, well <code>lookup</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">parseXRayTraceIdHdr</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">parseXRayTraceIdHdr</span> hdr <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  bits <span class="org-haskell-operator">&lt;-</span> traverse parseHeaderComponent <span class="org-haskell-operator">$</span> T.split <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">==</span> <span class="org-string">';'</span><span class="org-rainbow-delimiters-depth-1">)</span> hdr
  traceId <span class="org-haskell-operator">&lt;-</span> lookup <span class="org-string">"Root"</span> bits
  <span class="org-haskell-keyword">let</span> parent <span class="org-haskell-operator">=</span> lookup <span class="org-string">"Parent"</span> bits
  pure <span class="org-rainbow-delimiters-depth-1">(</span>traceId, parent<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">parseHeaderComponent</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">parseHeaderComponent</span> cmp <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> T.split <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">==</span> <span class="org-string">'='</span><span class="org-rainbow-delimiters-depth-1">)</span> cmp <span class="org-haskell-keyword">of</span>
                            <span class="org-rainbow-delimiters-depth-1">[</span>name, value<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-rainbow-delimiters-depth-1">(</span>name, value<span class="org-rainbow-delimiters-depth-1">)</span>
                            <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
</pre>
</div>

<p>
The start and end times for processing a request are also required. The docs say
that using at least millisecond resolution is a good idea, so I decided to do
exactly that. <code>NominalDiffTime</code>, which is what <code>getPOSIXTime</code> produces, supports
a resolution of picoseconds (though I doubt my system's clock does) which
requires a bit of (type-based) converting.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mkTimeInMilli</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Milli</span>
<span class="org-haskell-definition">mkTimeInMilli</span> <span class="org-haskell-operator">=</span> ndfToMilli <span class="org-haskell-operator">&lt;$&gt;</span> getPOSIXTime
  <span class="org-haskell-keyword">where</span>
    ndfToMilli <span class="org-haskell-operator">=</span> fromRational <span class="org-haskell-operator">.</span> toRational
</pre>
</div>

<p>
The last support function needed is one that creates the segment. Just
building the JSON object, using <i>aeson</i>'s <code>object</code>, is enough at this
point.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mkSegment</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Milli</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Milli</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">mkSegment</span> name id startTime endTime <span class="org-rainbow-delimiters-depth-1">(</span>root, parent<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span>
  object <span class="org-haskell-operator">$</span> <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-string">"name"</span> <span class="org-haskell-operator">.=</span> name
           , <span class="org-string">"id"</span> <span class="org-haskell-operator">.=</span> id
           , <span class="org-string">"trace_id"</span> <span class="org-haskell-operator">.=</span> root
           , <span class="org-string">"start_time"</span> <span class="org-haskell-operator">.=</span> startTime
           , <span class="org-string">"end_time"</span> <span class="org-haskell-operator">.=</span> endTime
           <span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">&lt;&gt;</span> p
  <span class="org-haskell-keyword">where</span>
    p <span class="org-haskell-operator">=</span> maybe <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> v <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"parent_id"</span> <span class="org-haskell-operator">.=</span> v<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> parent
</pre>
</div>

<p>
Armed with all this, I can now put together a WAI middleware that
</p>

<ol class="org-ol">
<li>records the start time of the call</li>
<li>processes the request</li>
<li>sends off the response and keeps the result of it</li>
<li>records the end time</li>
<li>parses the tracing header</li>
<li>builds the segment prepended with the <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-api-sendingdata.html#xray-api-daemon">X-Ray daemon header</a></li>
<li>sends the segment to the X-Ray daemon</li>
</ol>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">traceId</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Middleware</span>
<span class="org-haskell-definition">traceId</span> xrayName app req sendResponse <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  startTime <span class="org-haskell-operator">&lt;-</span> mkTimeInMilli
  app req <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span> res <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
    rr <span class="org-haskell-operator">&lt;-</span> sendResponse res
    endTime <span class="org-haskell-operator">&lt;-</span> mkTimeInMilli
    theId <span class="org-haskell-operator">&lt;-</span> T.pack <span class="org-haskell-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> v <span class="org-haskell-operator">-&gt;</span> showHex v <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;$&gt;</span> randomIO <span class="org-haskell-operator">@</span><span class="org-haskell-constructor">Word64</span>
    <span class="org-haskell-keyword">let</span> traceParts <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>decodeUtf8 <span class="org-haskell-operator">&lt;$&gt;</span> requestHeaderTraceId req<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;=</span> parseXRayTraceIdHdr
        segment <span class="org-haskell-operator">=</span> mkSegment xrayName theId startTime endTime <span class="org-haskell-operator">&lt;$&gt;</span> traceParts
    <span class="org-haskell-keyword">case</span> segment <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> pure <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
      <span class="org-haskell-constructor">Just</span> segment' <span class="org-haskell-operator">-&gt;</span> sendXRayPayload <span class="org-haskell-operator">$</span> toStrict <span class="org-haskell-operator">$</span> prepareXRayPayload segment'
    pure rr

  <span class="org-haskell-keyword">where</span>
    prepareXRayPayload segment <span class="org-haskell-operator">=</span>
      <span class="org-haskell-keyword">let</span> header <span class="org-haskell-operator">=</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"format"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"json"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-string">"version"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
      <span class="org-haskell-keyword">in</span> encode header <span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">"\n"</span> <span class="org-haskell-operator">&lt;&gt;</span> encode segment

    sendXRayPayload payload <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      addrInfos <span class="org-haskell-operator">&lt;-</span> S.getAddrInfo <span class="org-haskell-constructor">Nothing</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Just</span> <span class="org-string">"127.0.0.1"</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Just</span> <span class="org-string">"2000"</span><span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-keyword">case</span> addrInfos <span class="org-haskell-keyword">of</span>
        <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> pure <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-comment-delimiter">-- </span><span class="org-comment">silently skip</span>
        <span class="org-rainbow-delimiters-depth-1">(</span>xrayAddr<span class="org-haskell-constructor">:</span><span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
          sock <span class="org-haskell-operator">&lt;-</span> S.socket <span class="org-rainbow-delimiters-depth-1">(</span>S.addrFamily xrayAddr<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">S.Datagram</span> S.defaultProtocol
          S.connect sock <span class="org-rainbow-delimiters-depth-1">(</span>S.addrAddress xrayAddr<span class="org-rainbow-delimiters-depth-1">)</span>
          sendAll sock payload
          S.close sock
</pre>
</div>

<p>
The next step will be to instrument the actual processing. The service I'm
instrumenting is asynchronous, so all the work happens <i>after</i> the response has
been sent. My plan for this is to use subsegments to record it. That means I'll
have to
</p>

<ul class="org-ul">
<li>keep the <code>Root</code> and ID (<code>theId</code> in <code>traceId</code> above) for use in subsegments</li>
<li>keep the original tracing header, for use in outgoing calls</li>
<li>make sure all outgoing HTTP calls include a tracing header with a proper
<code>Parent</code></li>
<li>wrap all outgoing HTTP calls with time keeping and sending a subsegment to the
X-Ray daemon</li>
</ul>

<p>
I'm saving that work for a rainy day though, or rather, for a day when I'm so
upset at Clojure that I don't want to see another parenthesis.
</p>

<p>
<i>Edit (2020-04-10):</i> Corrected the segment field name for the parent ID, it
should be <code>parent_id</code>.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-aws.html">AWS</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-xray.html">XRay</a> </div>
<div class="post-date">02 Feb 2020</div><h1 class="post-title"><a href="https://magnus.therning.org/2020-02-02-000-my-ghcide-build-for-nix.html">My ghcide build for Nix</a></h1>
<p>
I was slightly disappointed to find out that not all packages on Hackage that
are marked as present in <a href="https://nixos.org/nixpkgs/">Nix(pkgs)</a> actually are available. Quite a few of them
are marked broken and hence not installable. One of these packages is <a href="https://hackage.haskell.org/package/ghcide">ghcide</a>.
</p>

<p>
There are of course expressions available for getting a working <code>ghcide</code>
executable installed, like <a href="https://github.com/hercules-ci/ghcide-nix">ghcide-nix</a>. However, since I have rather simple needs
for my Haskell projects I thought I'd play with my own approach to it.
</p>

<p>
What I care about is:
</p>

<ol class="org-ol">
<li>availability of the development tools I use, at the moment it's mainly
<code>ghcide</code> but I'm planning on making use of <a href="https://hackage.haskell.org/package/ormolu">ormolu</a> in the near future</li>
<li>pre-built packages</li>
<li>ease of use</li>
</ol>

<p>
So, I put together <a href="https://github.com/magthe/ghcide-for-nix">ghcide-for-nix</a>. It's basically just a constumized Nixpkgs
where the packages needed to un-break <code>ghcide</code> are present.
</p>

<p>
Usage is a simple <code>import</code> away:
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-nix-builtin">import</span> <span class="org-rainbow-delimiters-depth-1">(</span>builtins.fetchGit <span class="org-rainbow-delimiters-depth-2">{</span>
  <span class="org-nix-attribute">name</span> = <span class="org-string">"ghcide-for-nix"</span>;
  <span class="org-nix-attribute">url</span> = <span class="org-nix-constant">https://github.com/magthe/ghcide-for-nix</span>;
  <span class="org-nix-attribute">rev</span> = <span class="org-string">"927a8caa62cece60d9d66dbdfc62b7738d61d75f"</span>;
<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
and it'll give you a superset of Nixpkgs. Pre-built packages are available on
<a href="https://magthe.cachix.org/">Cachix</a>.
</p>

<p>
It's not sophisticated, but it's rather easy to use and suffices for my
purposes.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>
<div class="post-date">19 Sep 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-09-19-000-haskell--ghcide--and-spacemacs.html">Haskell, ghcide, and Spacemacs</a></h1>
<p>
The other day I read Chris Penner's post on <a href="https://chrispenner.ca/posts/hie-core">Haskell IDE Support</a> and thought I'd
make an attempt to use it with Spacemacs.
</p>

<p>
After running <code>stack build hie-bios ghcide haskell-lsp --copy-compiler-tool</code> I
had a look at the <a href="https://github.com/haskell/haskell-ide-engine#using-hie-with-spacemacs">instructions on using <code>haskell-ide-engine</code> with Spacemacs</a>.
After a bit of trial and error I came up with these changes to my
<code>~/.spacemacs</code>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">dotspacemacs/layers</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq-default</span>
   dotspacemacs-configuration-layers
   '<span class="org-rainbow-delimiters-depth-3">(</span>
    ...
    lsp
    <span class="org-rainbow-delimiters-depth-4">(</span>haskell <span class="org-builtin">:variables</span>
             haskell-completion-backend 'lsp
             <span class="org-rainbow-delimiters-depth-4">)</span>
    ...<span class="org-rainbow-delimiters-depth-3">)</span>
  <span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">dotspacemacs/user-config</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq</span> lsp-haskell-process-args-hie '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"exec"</span> <span class="org-string">"ghcide"</span> <span class="org-string">"--"</span> <span class="org-string">"--lsp"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        lsp-haskell-process-path-hie <span class="org-string">"stack"</span>
        lsp-haskell-process-wrapper-function <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>argv<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">(</span>cons <span class="org-rainbow-delimiters-depth-5">(</span>car argv<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span>cddr argv<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>add-hook 'haskell-mode-hook
            #'lsp<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The slightly weird looking <code>lsp-haskell-process-wrapper-function</code> is removing
the pesky <code>--lsp</code> inserted by <a href="https://github.com/emacs-lsp/lsp-haskell/blob/64106be79350f9ce6903d22c66b29761dadb5001/lsp-haskell.el#L179">this line</a>.
</p>

<p>
That seems to work. Though I have to say I'm not ready to switch from <a href="https://hackage.haskell.org/package/intero">intero</a>
just yet. Two things in particular didn't work with =ghcide=/LSP:
</p>

<ol class="org-ol">
<li>Switching from one the <code>Main.hs</code> in one executable to the <code>Main.hs</code> of
another executable in the same project didn't work as expected &#x2013; I had hints
and types in the first, but nothing in the second.</li>
<li>Jump to the definition of a function defined in the package didn't work &#x2013;
I'm not willing to use <a href="https://www.gnu.org/software/global/">GNU GLOBAL</a> or some other source tagging system.</li>
</ol>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-lsp.html">lsp</a> <a href="https://magnus.therning.org/tag-spacemacs.html">spacemacs</a> </div>
<div class="post-date">19 Aug 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-08-19-000-hedgehog-on-a-rest-api--part-3.html">Hedgehog on a REST API, part 3</a></h1>
<p>
In my previous post on using Hedgehog on a REST API, <a href="2019-06-23-000-hedgehog-on-a-rest-api--part-2.html">Hedgehog on a REST API,
part 2</a> I ran the test a few times and adjusted the model to deal with the
incorrect assumptions I had initially made. In particular, I had to adjust how I
modelled the <i>User ID</i>. Because of the simplicity of the API that wasn't too
difficult. However, that kind of completely predictable ID isn't found in all
APIs. In fact, it's not uncommon to have completely random IDs in API (often
they are <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>s).
</p>

<p>
So, I set out to try to deal with that. I'm still using the simple API from the
previous posts, but this time I'm pretending that I can't build the ID into the
model myself, or, put another way, I'm capturing the ID from the responses.
</p>

<div id="outline-container-orgca4a77b" class="outline-2">
<h2 id="orgca4a77b">The model state</h2>
<div class="outline-text-2" id="text-orgca4a77b">
<p>
When capturing the ID it's no longer possible to use a simple <code>Map Int Text</code> for
the state, because I don't actually have the ID until I have an HTTP response.
However, the ID is playing an important role in the constructing of a sequence
of actions. The trick is to use <code>Var Int v</code> instead of an ordinary <code>Int</code>. As I
understand it, and I believe that's a good enough understanding to make use of
Hedgehog possible, is that this way the ID is an opaque blob in the construction
phase, and it's turned into a concrete value during execution. When in the
opaque state it implements enough type classes to be useful for my purposes.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Var</span> <span class="org-haskell-constructor">Int</span> v<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge3fe138" class="outline-2">
<h2 id="orge3fe138">The API calls: add user</h2>
<div class="outline-text-2" id="text-orge3fe138">
<p>
When taking a closer look at the <a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#t:Callback"><code>Callback</code></a> type not all the callbacks will get
the state in the same form, opaque or concrete, and one of them, <code>Update</code>
actually receives the state in both states depending on the phase of execution.
This has the most impact on the add user action. To deal with it there's a need
to rearrange the code a bit, to be specific, <code>commandExecute</code> can no longer
return a tuple of both the ID and the status of the HTTP response because the
update function can't reach into the tuple, which it needs to update the state.
</p>

<p>
That means the <code>commandExecute</code> function will have to do tests too. It <i>is</i> nice
to keep all tests in the callbacks, but by sticking a <code>MonadTest m</code> constraint
on the <code>commandExecute</code> it turns into a nice solution anyway.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m, <span class="org-haskell-type">MonadTest</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                           <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.text <span class="org-rainbow-delimiters-depth-1">(</span>Range.linear <span class="org-highlight-numbers-number">0</span> <span class="org-highlight-numbers-number">42</span><span class="org-rainbow-delimiters-depth-1">)</span> Gen.alpha

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      <span class="org-rainbow-delimiters-depth-1">(</span>s, ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
        mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
        addReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/users"</span>
        <span class="org-haskell-keyword">let</span> addReq' <span class="org-haskell-operator">=</span> addReq <span class="org-rainbow-delimiters-depth-1">{</span> requestBody <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RequestBodyLBS</span> <span class="org-rainbow-delimiters-depth-2">(</span>encode <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">User</span> <span class="org-highlight-numbers-number">0</span> n<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>
        addResp <span class="org-haskell-operator">&lt;-</span> httpLbs addReq' mgr
        <span class="org-haskell-keyword">let</span> user <span class="org-haskell-operator">=</span> decode <span class="org-rainbow-delimiters-depth-1">(</span>responseBody addResp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">User</span>
        return <span class="org-rainbow-delimiters-depth-1">(</span>responseStatus addResp, user<span class="org-rainbow-delimiters-depth-1">)</span>
      status201 <span class="org-haskell-operator">===</span> s
      assert <span class="org-haskell-operator">$</span> isJust ui
      <span class="org-rainbow-delimiters-depth-1">(</span>userName <span class="org-haskell-operator">&lt;$&gt;</span> ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">Just</span> n
      return <span class="org-haskell-operator">$</span> userId <span class="org-haskell-operator">$</span> fromJust ui

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.insert o n m<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I found that once I'd come around to folding the <code>Ensure</code> callback into the
<code>commandExecute</code> function the rest fell out from the types.
</p>
</div>
</div>

<div id="outline-container-orgf9cfdae" class="outline-2">
<h2 id="orgf9cfdae">The API calls: delete user</h2>
<div class="outline-text-2" id="text-orgf9cfdae">
<p>
The other actions, deleting a user and getting a user, required only minor
changes and the changes were rather similar in both cases.
</p>

<p>
Not the type for the action needs to take a <code>Var Int v</code> instead of just a plain
<code>Int</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Var</span> <span class="org-haskell-constructor">Int</span> v<span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Which in turn affect the implementation of <code>HTraversable</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-haskell-keyword">where</span>
  htraverse f <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> vi<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> htraverse f vi
</pre>
</div>

<p>
Then the changes to the <code>Command</code> mostly comprise use of <a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#v:concrete"><code>concrete</code></a> in places
where the real ID is needed.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                              , <span class="org-haskell-constructor">Require</span> r
                              , <span class="org-haskell-constructor">Ensure</span> e
                              <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
      ks <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.element ks

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> vi<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      delReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"DELETE http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show <span class="org-rainbow-delimiters-depth-1">(</span>concrete vi<span class="org-rainbow-delimiters-depth-1">)</span>
      delResp <span class="org-haskell-operator">&lt;-</span> httpNoBody delReq mgr
      return <span class="org-haskell-operator">$</span> responseStatus delResp

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.delete i m

    r <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> i <span class="org-haskell-operator">`elem`</span> M.keys m

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> r <span class="org-haskell-operator">=</span> r <span class="org-haskell-operator">===</span> status200
</pre>
</div>
</div>
</div>

<div id="outline-container-org24f01b8" class="outline-2">
<h2 id="org24f01b8">Conclusion</h2>
<div class="outline-text-2" id="text-org24f01b8">
<p>
This post concludes my playing around with state machines in Hedgehog for this
time. I certainly hope I find the time to put it to use on some larger API soon.
In particular I'd love to put it to use at work; I think it'd be an excellent
addition to the integration tests we currently have.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hedgehog.html">hedgehog</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>
<div class="post-date">10 Aug 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-08-10-000-architecture-of-a-service.html">Architecture of a service</a></h1>
<p>
Early this summer it was finally time to put this one service I've been working
on into our sandbox environment. It's been running without hickups so last week
I turned it on for production as well. In this post I thought I'd document the
how and why of the service in the hope that someone will find it useful.
</p>

<p>
The service functions as an interface to external SMS-sending services, offering
a single place to change if we find that we are unhappy with the service we're
using.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> This service replaces an older one, written in Ruby and no one really
dares touch it. Hopefully the Haskell version will prove to be a joy to work
with over time.
</p>

<div id="outline-container-orga8a66cc" class="outline-2">
<h2 id="orga8a66cc">Overview of the architecture</h2>
<div class="outline-text-2" id="text-orga8a66cc">
<p>
The service is split into two parts, one web server using <a href="https://hackage.haskell.org/package/scotty">scotty</a>, and streaming
data processing using <a href="https://hackage.haskell.org/package/conduit">conduit</a>. Persistent storage is provided by a <a href="https://www.postgresql.org/">PostgreSQL</a>
database. The general idea is that events are picked up from the database, acted
upon, which in turn results in other events which written to the database. Those
are then picked up and round and round we go. The web service accepts requests,
turns them into events and writes the to the database.
</p>

<p>
Hopefully this crude diagram clarifies it somewhat.
</p>


<figure id="org603b78a">
<img src="static/2019-08-10-architecture.png" alt="2019-08-10-architecture.png">

<figcaption><span class="figure-number">Figure 1: </span>Diagram of the service architecture</figcaption>
</figure>

<p>
There are a few things that might need some explanation
</p>

<ul class="org-ul">
<li><p>
In the past we've wanted to have the option to use multiple external SMS
services at the same time. One is randomly chosen as the request comes in.
There's also a possibility to configure the frequency for each external
service.
</p>

<p>
<i>Picker</i> implements the random picking and I've written about that earlier in
<a href="2019-02-17-000-choosing-a-conduit-randomly.html">Choosing a conduit randomly</a>.
</p>

<p>
<i>Success</i> and <i>fail</i> are dummy senders. They don't actually send anything, and
the former succeeds at it while the latter fails. I found them useful for
manual testing.
</p></li>

<li><p>
Successfully sending off a request to an external SMS service, getting status
200 back, doesn't actually mean that the SMS has been sent, or even that it
ever will be. Due to the nature of SMS messaging there are no guarantees of
timeliness at all. Since we are interested in finding out whether an SMS
actually is sent a delayed action is scheduled, which will fetch the status of
a sent SMS after a certain time (currently 2 minutes). If an SMS hasn't been
sent after that time it might as well never be &#x2013; it's too slow for our
end-users.
</p>

<p>
This is what <i>report-fetcher</i> and <i>fetcher-func</i> do.
</p></li>

<li>The <i>queue sink</i> and <i>queue src</i> are actually <a href="https://hackage.haskell.org/package/stm-conduit-4.0.1/docs/Data-Conduit-TQueue.html#v:sourceTQueue"><code>sourceTQueue</code></a> and <a href="https://hackage.haskell.org/package/stm-conduit-4.0.1/docs/Data-Conduit-TQueue.html#v:sinkTQueue"><code>sinkTQueue</code></a>.
Splitting the stream like that makes it trivial to push in events by using
<a href="https://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM-TQueue.html#v:writeTQueue"><code>writeTQueue</code></a>.</li>

<li>I use <a href="https://hackage.haskell.org/package/conduit-1.3.1.1/docs/Data-Conduit.html#v:sequenceConduits"><code>sequenceConduits</code></a> in order to send a single event to multiple
=Conduit=s and then combine all their results back into a single stream. The
ease with which this can be done in <a href="https://hackage.haskell.org/package/conduit">conduit</a> is one of the main reasons why I
choose to use it.<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup></li>
</ul>
</div>
</div>

<div id="outline-container-org495919d" class="outline-2">
<h2 id="org495919d">Effects and tests</h2>
<div class="outline-text-2" id="text-org495919d">
<p>
I started out writing everything based on a type like <code>ReaderT &lt;my cfg type&gt; IO</code>
and using <code>liftIO</code> for effects that needed lifting. This worked nicely while I
was setting up the basic structure of the service, but as soon as I hooked in
the database I really wanted to do some testing also of the effectful code.
</p>

<p>
After reading <a href="https://serokell.io/blog/2018/12/07/tagless-final">Introduction to Tagless Final</a> and
<a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">The ReaderT Design Patter</a>, playing a bit with both approaches, and writing
<a href="2019-01-20-000-tagless-final-and-scotty.html">Tagless final and Scotty</a> and
<a href="2019-02-02-000-the-readert-design-pattern-or-tagless-final-.html">The ReaderT design pattern or tagless final?</a>, I finally chose to go down the route
of <i>tagless final</i>. There's no strong reason for that decision, maybe it was
just because I read about it first and found it very easy to move in that
direction in small steps.
</p>

<p>
There's a split between property tests and unit tests:
</p>

<ul class="org-ul">
<li>Data types, their monad instances (like JSON (de-)serialisation), pure
functions and a few effects are tested using properties. I'm using <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>
for that. I've since looked a little closer at <a href="https://hackage.haskell.org/package/hedgehog">hedgehog</a> and if I were to do a
major overhaul of the property tests I might be tempted to rewrite them using
that library instead.</li>

<li>Most of the =Conduit=s are tested using <a href="https://hackage.haskell.org/package/HUnit">HUnit</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-orged81fcb" class="outline-2">
<h2 id="orged81fcb">Configuration</h2>
<div class="outline-text-2" id="text-orged81fcb">
<p>
The service will be run in a container and we try to follow the <a href="https://12factor.net/">12-factor app
rules</a>, where the third one says that configuration should be stored in the
environment. All previous Haskell projects I've worked on have been command line
tools were configuration is done (mostly) using command line argument. For that
I usually use <a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a>, but it's not applicable in this setting.
</p>

<p>
After a bit of searching on <a href="https://hackage.haskell.org/">hackage</a> I settled on <a href="https://hackage.haskell.org/package/etc">etc</a>. It turned out to be nice
an easy to work with. The configuration is written in JSON and only specifies
environment variables. It's then embedded in the executable using <a href="https://hackage.haskell.org/package/file-embed">file-embed</a>.
The only thing I miss is a <a href="https://hackage.haskell.org/package/aeson/docs/Data-Aeson.html#t:ToJSON"><code>ToJSON</code></a> instance for <a href="https://hackage.haskell.org/package/etc-0.4.1.0/docs/System-Etc.html#t:Config"><code>Config</code></a> &#x2013; we've found it
quite useful to log the active configuration when starting a service and that
log entry would become a bit nicer if the message was JSON rather than the
(somewhat difficult to read) string that <code>Config</code>'s <code>Show</code> instance produces.
</p>
</div>
</div>

<div id="outline-container-orgf3bc0ed" class="outline-2">
<h2 id="orgf3bc0ed">Logging</h2>
<div class="outline-text-2" id="text-orgf3bc0ed">
<p>
There are two requirements we have when it comes to logging
</p>

<ol class="org-ol">
<li>All log entries tied to a request should have a <a href="https://hilton.org.uk/blog/microservices-correlation-id">correlation ID</a>.</li>
<li>Log requests and responses</li>
</ol>

<p>
I've written about correlation ID before, <a href="2018-10-01-000-using-a-configuration-in-scotty.html">Using a configuration in Scotty</a>.
</p>

<p>
Logging requests and responses is an area where I'm not very happy with <a href="https://hackage.haskell.org/package/scotty">scotty</a>.
It feels natural to solve it using middleware (i.e. using <a href="https://hackage.haskell.org/package/scotty/docs/Web-Scotty.html#v:middleware"><code>middleware</code></a>) but the
representation, especially of responses, is a bit complicated so for the time
being I've skipped logging the body of both. I'd be most interested to hear of
libraries that could make that easier.
</p>
</div>
</div>

<div id="outline-container-org5f31ed4" class="outline-2">
<h2 id="org5f31ed4">Data storage and picking up new events</h2>
<div class="outline-text-2" id="text-org5f31ed4">
<p>
The data stream processing depends heavily on being able to pick up when new
events are written to the database. Especially when there are more than one
instance running (we usually have at least two instance running in the
production environment). To get that working I've used <a href="https://hackage.haskell.org/package/postgresql-simple">postgresql-simple</a>'s
support for <a href="https://www.postgresql.org/docs/current/sql-listen.html"><code>LISTEN</code></a> and <a href="https://www.postgresql.org/docs/current/sql-notify.html"><code>NOTIFY</code></a> via the function <a href="https://hackage.haskell.org/package/postgresql-simple-0.6.2/docs/Database-PostgreSQL-Simple-Notification.html#v:getNotification"><code>getNotification</code></a>.
</p>

<p>
When I wrote about this earlier, <a href="2019-03-03-000-conduit-and-postgresql.html">Conduit and PostgreSQL</a> I got some really good
feedback that made my solution more robust.
</p>
</div>
</div>

<div id="outline-container-org04b2853" class="outline-2">
<h2 id="org04b2853">Delayed actions</h2>
<div class="outline-text-2" id="text-org04b2853">
<p>
Some things in Haskell feel almost like cheating. The light-weight threading
makes me confident that a <a href="https://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkIO"><code>forkIO</code></a> followed by a <a href="https://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:threadDelay"><code>threadDelay</code></a> (or in my case,
the ones from <a href="https://hackage.haskell.org/package/unliftio">unliftio</a>) will suffice.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
It has happened in the past that we've changed SMS service after finding
that they weren't living up to our expectations.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
A while ago I was experimenting with other streaming libraries, but I
gave up on getting re-combination to work &#x2013; <a href="2018-10-16-000-zipping-streams.html">Zipping streams</a>
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> <a href="https://magnus.therning.org/tag-scotty.html">scotty</a> <a href="https://magnus.therning.org/tag-postgresql.html">postgresql</a> <a href="https://magnus.therning.org/tag-tagless_final.html">tagless_final</a> </div>
<div class="post-date">23 Jun 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-06-23-000-hedgehog-on-a-rest-api--part-2.html">Hedgehog on a REST API, part 2</a></h1>
<p>
This is a short follow-up to <a href="2019-05-30-000-hedgehog-on-a-rest-api.html">Hedgehog on a REST API</a> where I actually run the
tests in that post.
</p>

<div id="outline-container-org27855a2" class="outline-2">
<h2 id="org27855a2">Fixing an issue with the model</h2>
<div class="outline-text-2" id="text-org27855a2">
<p>
The first issue I run into is
</p>

<pre class="example" id="orgdd312b9">
━━━ Main ━━━
  ✗ sequential failed after 18 tests and 1 shrink.

        ┏━━ tst/test-01.hs ━━━
     89 ┃ getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     90 ┃ getUser = Command gen exec [ Require r
     91 ┃                            , Ensure e
     92 ┃                            ]
     93 ┃   where
     94 ┃     gen (State m) = case M.keys m of
     95 ┃       [] -&gt; Nothing
     96 ┃       ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     97 ┃
     98 ┃     exec (GetUser i) = liftIO $ do
     99 ┃       mgr &lt;- newManager defaultManagerSettings
    100 ┃       getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
    101 ┃       getResp &lt;- httpLbs getReq mgr
    102 ┃       let us = decode $ responseBody getResp :: Maybe [User]
    103 ┃       return (status200 == responseStatus getResp, us)
    104 ┃
    105 ┃     r (State m) (GetUser i) = i `elem` M.keys m
    106 ┃
    107 ┃     e _ _ (GetUser _) (r, us) = do
    108 ┃       r === True
    109 ┃       assert $ isJust us
    110 ┃       (length &lt;$&gt; us) === Just 1
        ┃       ^^^^^^^^^^^^^^^^^^^^^^^^^^
        ┃       │ Failed (- lhs =/= + rhs)
        ┃       │ - Just 0
        ┃       │ + Just 1

        ┏━━ tst/test-01.hs ━━━
    118 ┃ prop_seq :: Property
    119 ┃ prop_seq = property $ do
    120 ┃   actions &lt;- forAll $ Gen.sequential (Range.linear 1 10) initialState [addUser, deleteUser, getUser]
        ┃   │ Var 0 = AddUser ""
        ┃   │ Var 1 = GetUser 1
    121 ┃   resetWS
    122 ┃   executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 17) (Seed 2158538972777046104 (-1442908127347265675)) sequential

  ✗ 1 failed.
</pre>

<p>
It's easy to verify this using <a href="https://httpie.org/">httpie</a>:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ http -p b POST :3000/users userId:=<span class="org-highlight-numbers-number">0</span> <span class="org-string">"userName="</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-string">"userId"</span>: <span class="org-highlight-numbers-number">0,</span>
    <span class="org-string">"userName"</span>: <span class="org-string">""</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
$ http -p b GET :3000/users/1
<span class="org-rainbow-delimiters-depth-1">[]</span>
</pre>
</div>

<p>
It's clear that my assumption that <i>User ID</i> starts at 1 is wrong. Luckily
fixing that isn't too difficult. Instead of defining the update function for
<code>addUser</code> as
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">u</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> _o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.insert k n m
  <span class="org-haskell-keyword">where</span>
    k <span class="org-haskell-operator">=</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.keys m<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I define it as
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">u</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> _o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.insert k n m
  <span class="org-haskell-keyword">where</span>
    k <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-highlight-numbers-number">0</span>
      ks <span class="org-haskell-operator">-&gt;</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> ks
</pre>
</div>

<p>
The complete code at this point can be found <a href="https://gist.github.com/8cbbfdb130a173bb51c317df0c00aa15">here</a>.
</p>
</div>
</div>

<div id="outline-container-org9c34f53" class="outline-2">
<h2 id="org9c34f53">Fixing another issue with the model</h2>
<div class="outline-text-2" id="text-org9c34f53">
<p>
With that fix in place another issue with the model shows up
</p>

<pre class="example" id="orga71bb89">
━━━ Main ━━━
  ✗ sequential failed after 74 tests and 2 shrinks.

        ┏━━ tst/test-01.hs ━━━
     91 ┃ getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     92 ┃ getUser = Command gen exec [ Require r
     93 ┃                            , Ensure e
     94 ┃                            ]
     95 ┃   where
     96 ┃     gen (State m) = case M.keys m of
     97 ┃       [] -&gt; Nothing
     98 ┃       ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     99 ┃
    100 ┃     exec (GetUser i) = liftIO $ do
    101 ┃       mgr &lt;- newManager defaultManagerSettings
    102 ┃       getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
    103 ┃       getResp &lt;- httpLbs getReq mgr
    104 ┃       let us = decode $ responseBody getResp :: Maybe [User]
    105 ┃       return (status200 == responseStatus getResp, us)
    106 ┃
    107 ┃     r (State m) (GetUser i) = i `elem` M.keys m
    108 ┃
    109 ┃     e _ _ (GetUser _) (r, us) = do
    110 ┃       r === True
    111 ┃       assert $ isJust us
    112 ┃       (length &lt;$&gt; us) === Just 1
        ┃       ^^^^^^^^^^^^^^^^^^^^^^^^^^
        ┃       │ Failed (- lhs =/= + rhs)
        ┃       │ - Just 0
        ┃       │ + Just 1

        ┏━━ tst/test-01.hs ━━━
    120 ┃ prop_seq :: Property
    121 ┃ prop_seq = property $ do
    122 ┃   actions &lt;- forAll $ Gen.sequential (Range.linear 1 10) initialState [addUser, deleteUser, getUser]
        ┃   │ Var 0 = AddUser ""
        ┃   │ Var 1 = DeleteUser 0
        ┃   │ Var 2 = AddUser ""
        ┃   │ Var 3 = GetUser 0
    123 ┃   resetWS
    124 ┃   executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 73) (Seed 3813043122711576923 (-444438259649958339)) sequential

  ✗ 1 failed.
</pre>

<p>
Again, verifying this using <a href="https://httpie.org/">httpie</a> shows what the issue is
</p>

<div class="org-src-container">
<pre class="src src-shell">$ http -p b POST :3000/users userId:=<span class="org-highlight-numbers-number">0</span> <span class="org-string">"userName="</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-string">"userId"</span>: <span class="org-highlight-numbers-number">0,</span>
    <span class="org-string">"userName"</span>: <span class="org-string">""</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
$ http -p b DELETE :3000/users/0
$ http -p b POST :3000/users userId:=<span class="org-highlight-numbers-number">0</span> <span class="org-string">"userName="</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-string">"userId"</span>: <span class="org-highlight-numbers-number">1,</span>
    <span class="org-string">"userName"</span>: <span class="org-string">""</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
$ http -p b GET :3000/users/0
<span class="org-rainbow-delimiters-depth-1">[]</span>
</pre>
</div>

<p>
In other words, the model assumes that the 0 <i>User ID</i> get's re-used.
</p>

<p>
To fix this I need a bigger change. The central bit is that the state is changed
to keep track of the index more explicitly. That is, it changes from
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
to
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-constructor">Int</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That change does, quite obviously, require a bunch of other changes in the other
functions dealing with the state. The complete file can be viewed <a href="https://gist.github.com/e3c3f4a3c35ab8a529045f90f9f4ba71">here</a>.
</p>
</div>
</div>

<div id="outline-container-org5f32fc1" class="outline-2">
<h2 id="org5f32fc1">All is well, or is it?</h2>
<div class="outline-text-2" id="text-org5f32fc1">
<p>
After this the tests pass, so all is good in the world, right?
</p>

<p>
In the test I defined the <a href="2019-05-30-000-hedgehog-on-a-rest-api.html#MissingReference">property</a> over rather short sequences of commands. What
happens if I increase the (maximum) length of the sequences a bit? Instead using
<code>Range.linear 1 10</code> I'll use <code>Range.linear 1 1000</code>. Well, besides taking
slightly longer to run I get another sequence of commands that triggers an
issue:
</p>

<pre class="example" id="org112d5bd">
━━━ Main ━━━
  ✗ sequential failed after 13 tests and 29 shrinks.

        ┏━━ tst/test-01.hs ━━━
     87 ┃ getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     88 ┃ getUser = Command gen exec [ Require r
     89 ┃                            , Ensure e
     90 ┃                            ]
     91 ┃   where
     92 ┃     gen (State _ m) = case M.keys m of
     93 ┃       [] -&gt; Nothing
     94 ┃       ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     95 ┃
     96 ┃     exec (GetUser i) = liftIO $ do
     97 ┃       mgr &lt;- newManager defaultManagerSettings
     98 ┃       getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
     99 ┃       getResp &lt;- httpLbs getReq mgr
    100 ┃       let us = decode $ responseBody getResp :: Maybe [User]
    101 ┃       return (status200 == responseStatus getResp, us)
    102 ┃
    103 ┃     r (State _ m) (GetUser i) = i `elem` M.keys m
    104 ┃
    105 ┃     e _ _ (GetUser _) (r, us) = do
    106 ┃       r === True
    107 ┃       assert $ isJust us
    108 ┃       (length &lt;$&gt; us) === Just 1
        ┃       ^^^^^^^^^^^^^^^^^^^^^^^^^^
        ┃       │ Failed (- lhs =/= + rhs)
        ┃       │ - Just 0
        ┃       │ + Just 1

        ┏━━ tst/test-01.hs ━━━
    116 ┃ prop_seq :: Property
    117 ┃ prop_seq = property $ do
    118 ┃   actions &lt;- forAll $ Gen.sequential (Range.linear 1 1000) initialState [addUser, deleteUser, getUser]
        ┃   │ Var 0 = AddUser ""
        ┃   │ Var 2 = AddUser ""
        ┃   │ Var 5 = AddUser ""
        ┃   │ Var 7 = AddUser ""
        ┃   │ Var 9 = AddUser ""
        ┃   │ Var 11 = AddUser ""
        ┃   │ Var 20 = AddUser ""
        ┃   │ Var 28 = AddUser ""
        ┃   │ Var 30 = AddUser ""
        ┃   │ Var 32 = AddUser ""
        ┃   │ Var 33 = AddUser ""
        ┃   │ Var 34 = AddUser ""
        ┃   │ Var 37 = AddUser ""
        ┃   │ Var 38 = AddUser ""
        ┃   │ Var 41 = AddUser ""
        ┃   │ Var 45 = AddUser ""
        ┃   │ Var 47 = GetUser 15
    119 ┃   resetWS
    120 ┃   executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 12) (Seed 2976784816810995551 (-47094630645854485)) sequential

  ✗ 1 failed.
</pre>

<p>
That is, after inserting 16 users, we don't see any user when trying to get that
16th user (<i>User ID</i> 15). That's a proper bug in the server.
</p>

<p>
As a matter of fact, this is the bug I put into the server and was hoping to
find. In particular, I wanted <i>hedgehog</i> to find the minimal sequence leading to
this bug.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> Which it clearly has!
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
If you recall from the <a href="2019-05-30-000-hedgehog-on-a-rest-api.html">previous post</a>, I was interested in the integrated
shrinking offered by <i>hedgehog</i>.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hedgehog.html">hedgehog</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>
<div class="post-date">30 May 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-05-30-000-hedgehog-on-a-rest-api.html">Hedgehog on a REST API</a></h1>
<p>
Last year I wrote a little bit about my attempt to use <a href="2018-07-14-000-quickcheck-on-a-rest-api.html"><i>QuickCheck</i> to test a
REST API</a>. Back then I got as far as generating test programs, running them, and
validating an in-test model against the observed behaviour of the web service
under test. One thing that I didn't implement was shrinking. I had some ideas,
and got some better ideas in a comment on that post, but I've not taken the time
to actually sit down and work it out. Then, during this spring, a couple of blog
posts from Oskar Wickström (<a href="https://wickstrom.tech/programming/2019/03/02/property-based-testing-in-a-screencast-editor-introduction.html">intro</a>, <a href="https://wickstrom.tech/programming/2019/03/24/property-based-testing-in-a-screencast-editor-case-study-1.html">part 1</a>, <a href="https://wickstrom.tech/programming/2019/04/17/property-based-testing-in-a-screencast-editor-case-study-2.html">part 2</a>) made me aware of another
library for doing property-based testing, <a href="https://hackage.haskell.org/package/hedgehog"><i>hedgehog</i></a>. It differs quite a bit
from <a href="https://hackage.haskell.org/package/QuickCheck"><i>QuickCheck</i></a>, most notably the way it uses to generate random data, and,
this is the bit that made me sit up and pay attention, it has integrated
shrinking.
</p>

<p>
My first plan was to use the same approach as I used with <i>QuickCheck</i>, but
after finding out that there's explicit support for <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#g:5">state machine tests</a>
everything turned out to be a bit easier than I had expected.
</p>

<p>
Well, it still wasn't exactly easy to work out the details, but the <a href="https://github.com/hedgehogqa/haskell-hedgehog/blob/master/hedgehog-example/src/Test/Example/Registry.hs">registry
example</a> in the <i>hedgehog</i> source repo together with a (slightly dated) <a href="https://teh.id.au/posts/2017/07/15/state-machine-testing/index.html">example</a> I
managed to work it out (I think).
</p>

<div id="outline-container-org2176560" class="outline-2">
<h2 id="org2176560">The REST API</h2>
<div class="outline-text-2" id="text-org2176560">
<p>
The API is the same as in the <a href="http://magnus.therning.org/posts/2018-07-14-000-quickcheck-on-a-rest-api.html">post on using <i>QuickCheck</i></a>, with one little
difference, I've been lazy when implementing <code>GET /users/:id</code> and return a list
of users (that makes it easy to represent a missing <code>:id</code>).
</p>


<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Method</th>
<th scope="col" class="org-left">Route</th>
<th scope="col" class="org-left">Example in</th>
<th scope="col" class="org-left">Example out</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>POST</code></td>
<td class="org-left"><code>/users</code></td>
<td class="org-left"><code>{"userId": 0, "userName": "Yogi Berra"}</code></td>
<td class="org-left"><code>{"userId": 42, "userName": "Yogi Berra"}</code></td>
</tr>

<tr>
<td class="org-left"><code>DELETE</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>[0,3,7]</code></td>
</tr>

<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>[{"userId": 42, "userName": "Yogi Berra"}]</code></td>
</tr>

<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>[]</code> (when there's no user with <code>:id</code>)</td>
</tr>

<tr>
<td class="org-left"><code>POST</code></td>
<td class="org-left"><code>/reset</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org1474dbe" class="outline-2">
<h2 id="org1474dbe">The model state</h2>
<div class="outline-text-2" id="text-org1474dbe">
<p>
Just like last time I'm using as simple a model as I think I can get away with,
based on the API above:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">initialState</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> v
<span class="org-haskell-definition">initialState</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> M.empty
</pre>
</div>

<p>
That extra <code>v</code> is something that <i>hedgehog</i> requires. Why? I don't really know,
and luckily I don't have to care to make it all work. One thing though, the
language pragma <code>KindSignatures</code> is necessary to use that kind of syntax.
</p>
</div>
</div>

<div id="outline-container-org31f59b7" class="outline-2">
<h2 id="org31f59b7">Representing API calls</h2>
<div class="outline-text-2" id="text-org31f59b7">
<p>
Representing an API call requires three things
</p>

<ol class="org-ol">
<li>a type</li>
<li>an implementation of <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:HTraversable"><code>HTraversable</code></a> for the type</li>
<li>a function producing a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Command"><code>Command</code></a> for the type</li>
</ol>

<p>
I represent the three API calls with these three types
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AddUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-constructor">Text</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-constructor">Int</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">GetUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">GetUser</span> <span class="org-haskell-constructor">Int</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Again that <code>v</code> pops up, but as with the model state, there's no need to pay any
attention to it.
</p>

<p>
For the implementation of <code>HTraversable</code> I was greatly helped by the <a href="https://github.com/hedgehogqa/haskell-hedgehog/blob/master/hedgehog-example/src/Test/Example/Registry.hs">registry
example</a>. Their implementations are fairly straight forward, which is a good
thing since the need for them is internal to <i>hedgehog</i>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">AddUser</span> <span class="org-haskell-keyword">where</span>
  htraverse <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> pure n

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-haskell-keyword">where</span>
  htraverse <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> pure i

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">GetUser</span> <span class="org-haskell-keyword">where</span>
  htraverse <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">GetUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">GetUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> pure i
</pre>
</div>

<p>
Once these two things are out of the way we get to the meat of the
implementation of the API calls, a function creating a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Command"><code>Command</code></a> instance for
each type of API call. The exact type for all three functions will be
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">MonadGen</span> n, <span class="org-haskell-constructor">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-constructor">Command</span> n m <span class="org-haskell-constructor">State</span>
</pre>
</div>

<p>
which doesn't say a whole lot, I think. After reading the documentation I found
it a little clearer, but the two examples, <a href="https://teh.id.au/posts/2017/07/15/state-machine-testing/index.html">state machine testing</a> and <a href="https://github.com/hedgehogqa/haskell-hedgehog/blob/master/hedgehog-example/src/Test/Example/Registry.hs">registry</a>,
was what cleared things up for me.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> In an attempt at being overly explicit I
wrote these functions in the same style. This is what it ended up looking like
for the <code>AddUser</code> type:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                           , <span class="org-haskell-constructor">Ensure</span> e
                           <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.text <span class="org-rainbow-delimiters-depth-1">(</span>Range.linear <span class="org-highlight-numbers-number">0</span> <span class="org-highlight-numbers-number">42</span><span class="org-rainbow-delimiters-depth-1">)</span> Gen.alpha

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      addReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/users"</span>
      <span class="org-haskell-keyword">let</span> addReq' <span class="org-haskell-operator">=</span> addReq <span class="org-rainbow-delimiters-depth-1">{</span> requestBody <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RequestBodyLBS</span> <span class="org-rainbow-delimiters-depth-2">(</span>encode <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">User</span> <span class="org-highlight-numbers-number">0</span> n<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>
      addResp <span class="org-haskell-operator">&lt;-</span> httpLbs addReq' mgr
      <span class="org-haskell-keyword">let</span> user <span class="org-haskell-operator">=</span> decode <span class="org-rainbow-delimiters-depth-1">(</span>responseBody addResp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">User</span>
      return <span class="org-rainbow-delimiters-depth-1">(</span>responseStatus addResp, user<span class="org-rainbow-delimiters-depth-1">)</span>

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> _o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.insert k n m
      <span class="org-haskell-keyword">where</span>
        k <span class="org-haskell-operator">=</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.keys m<span class="org-rainbow-delimiters-depth-1">)</span>

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>r, ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      r <span class="org-haskell-operator">===</span> status201
      assert <span class="org-haskell-operator">$</span> isJust ui
      <span class="org-rainbow-delimiters-depth-1">(</span>userName <span class="org-haskell-operator">&lt;$&gt;</span> ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">Just</span> n
</pre>
</div>

<p>
Piece by piece:
</p>

<ol class="org-ol">
<li><code>gen</code> is the generator of data. It takes one argument, the current state, but
for <code>AddUser</code> I have no use for it. The user name is generated using a
generator for <code>Text</code>, and rather arbitrarily I limit the names to 42
characters.</li>
<li><code>exec</code> is the action that calls the web service. Here I'm using <a href="https://hackage.haskell.org/package/http-client">http-client</a>
to make the call and <a href="https://hackage.haskell.org/package/aeson">aeson</a> to parse the response into a <code>User</code>. It produces
<i>output</i>.</li>
<li><code>u</code> is a function for updating the model state. It's given the current state,
the command and the <i>output</i>. All I need to to do for <code>AddUser</code> is to pick a
<code>userId</code> and associate it with the generated name.</li>
<li><code>e</code> is a function for checking post-conditions, in other words checking
properties that must hold after <code>exec</code> has run and the state has been
updated. It's given four arguments, the previous state, the updated state,
the command and the <i>output</i>. The tests here are on the HTTP response code
and the returned user name. I think that will do for the time being.</li>
</ol>

<p>
The function for <code>DeleteUser</code> follows the same pattern
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                              , <span class="org-haskell-constructor">Require</span> r
                              , <span class="org-haskell-constructor">Ensure</span> e
                              <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
      ks <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.element ks

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      delReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"DELETE http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show i
      delResp <span class="org-haskell-operator">&lt;-</span> httpNoBody delReq mgr
      return <span class="org-haskell-operator">$</span> responseStatus delResp

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.delete i m

    r <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> i <span class="org-haskell-operator">`elem`</span> M.keys m

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> r <span class="org-haskell-operator">=</span> r <span class="org-haskell-operator">===</span> status200
</pre>
</div>

<p>
I think only two pieces need further explanation:
</p>

<ol class="org-ol">
<li><code>gen</code> only returns a <code>DeleteUser</code> with an index actually present in the model
state. If there are no users in the model then <code>Nothing</code> is returned. As far
as I understand that means that generated programs will only make calls to
delete existing users.<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup></li>
<li><code>r</code> is a pre-condition that programs only delete users that exist. At first I
had skipped this pre-condition, thinking that it'd be enough to have <code>gen</code>
only create delete calls for existing users. However, after reading the
documentation of <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Command"><code>Command</code></a> and <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Callback"><code>Callback</code></a> a bit more closely I realised that
I might need a pre-condition to make sure that this holds true also while
shrinking.</li>
</ol>

<p>
The final function, for <code>GetUser</code> requires no further explanation so I only
present it here
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">getUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">getUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Require</span> r
                           , <span class="org-haskell-constructor">Ensure</span> e
                           <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
      ks <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">GetUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.element ks

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">GetUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      getReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"GET http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show i
      getResp <span class="org-haskell-operator">&lt;-</span> httpLbs getReq mgr
      <span class="org-haskell-keyword">let</span> us <span class="org-haskell-operator">=</span> decode <span class="org-haskell-operator">$</span> responseBody getResp <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">User</span><span class="org-rainbow-delimiters-depth-1">]</span>
      return <span class="org-rainbow-delimiters-depth-1">(</span>status200 <span class="org-haskell-operator">==</span> responseStatus getResp, us<span class="org-rainbow-delimiters-depth-1">)</span>

    r <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">GetUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> i <span class="org-haskell-operator">`elem`</span> M.keys m

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">GetUser</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>r, us<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      r <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">True</span>
      assert <span class="org-haskell-operator">$</span> isJust us
      <span class="org-rainbow-delimiters-depth-1">(</span>length <span class="org-haskell-operator">&lt;$&gt;</span> us<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">Just</span> <span class="org-highlight-numbers-number">1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org17f0c42" class="outline-2">
<h2 id="org17f0c42">The property and test</h2>
<div class="outline-text-2" id="text-org17f0c42">
<p>
It looks like there are two obvious top-level properties
</p>

<ol class="org-ol">
<li>the web service works as expected when all calls are made one at a time
(sequential), and</li>
<li>the web service works as expected when all calls are made in parallel.</li>
</ol>

<p>
<i>Hedgehog</i> provides two pairs of functions for this
</p>

<ol class="org-ol">
<li>a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog-Gen.html#v:sequential"><code>sequential</code> generator</a> with <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#v:executeSequential"><code>executeSequential</code></a>, and</li>
<li>a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog-Gen.html#v:parallel"><code>parallel</code> generator</a> with <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#v:executeParallel"><code>executeParallel</code></a>.</li>
</ol>

<p>
I started with the former only
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">prop_seq</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Property</span>
<span class="org-haskell-definition">prop_seq</span> <span class="org-haskell-operator">=</span> property <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  actions <span class="org-haskell-operator">&lt;-</span> forAll <span class="org-haskell-operator">$</span> Gen.sequential <span class="org-rainbow-delimiters-depth-1">(</span>Range.linear <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-1">)</span> initialState <span class="org-rainbow-delimiters-depth-1">[</span>addUser, deleteUser, getUser<span class="org-rainbow-delimiters-depth-1">]</span>
  resetWS
  executeSequential initialState actions
</pre>
</div>

<p>
This first creates a generator of programs of at most length 10<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>, then
turning that into a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Sequential"><code>Sequential</code></a> which can be passed to <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#v:executeSequential"><code>executeSequential</code></a> to
turn into a <a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#t:Property"><code>Property</code></a>.
</p>

<p>
The function <code>resetWS</code> clears out the web service to make sure that the tests
start with a clean slate each time. Its definition is
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">resetWS</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">resetWS</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
  resetReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/reset"</span>
  void <span class="org-haskell-operator">$</span> httpNoBody resetReq mgr
</pre>
</div>

<p>
The final bit is the <code>main</code> function, which I wrote like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  res <span class="org-haskell-operator">&lt;-</span> checkSequential <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Group</span> <span class="org-string">"Main"</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"sequential"</span>, prop_seq<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
  unless res exitFailure
</pre>
</div>

<p>
That is, first run the property sequentially (<a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#v:checkSequential"><code>checkSequential</code></a>) and if that
fails exit with failure.
</p>
</div>
</div>

<div id="outline-container-orgde41804" class="outline-2">
<h2 id="orgde41804">Running the test</h2>
<div class="outline-text-2" id="text-orgde41804">
<p>
When running the test fails and gives me a program that breaks the property, and
exactly what fails:
</p>

<pre class="example" id="orgcb6c8d9">
━━━ Main ━━━
  ✗ sequential failed after 13 tests and 1 shrink.

        ┏━━ tst/test-01.hs ━━━
     89 ┃ getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     90 ┃ getUser = Command gen exec [ Require r
     91 ┃                            , Ensure e
     92 ┃                            ]
     93 ┃   where
     94 ┃     gen (State m) = case M.keys m of
     95 ┃       [] -&gt; Nothing
     96 ┃       ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     97 ┃
     98 ┃     exec (GetUser i) = liftIO $ do
     99 ┃       mgr &lt;- newManager defaultManagerSettings
    100 ┃       getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
    101 ┃       getResp &lt;- httpLbs getReq mgr
    102 ┃       let us = decode $ responseBody getResp :: Maybe [User]
    103 ┃       return (status200 == responseStatus getResp, us)
    104 ┃
    105 ┃     r (State m) (GetUser i) = i `elem` M.keys m
    106 ┃
    107 ┃     e _ _ (GetUser _) (r, us) = do
    108 ┃       r === True
    109 ┃       assert $ isJust us
    110 ┃       (length &lt;$&gt; us) === Just 1
        ┃       ^^^^^^^^^^^^^^^^^^^^^^^^^^
        ┃       │ Failed (- lhs =/= + rhs)
        ┃       │ - Just 0
        ┃       │ + Just 1

        ┏━━ tst/test-01.hs ━━━
    118 ┃ prop_seq :: Property
    119 ┃ prop_seq = property $ do
    120 ┃   actions &lt;- forAll $ Gen.sequential (Range.linear 1 10) initialState [addUser, deleteUser, getUser]
        ┃   │ Var 0 = AddUser ""
        ┃   │ Var 1 = GetUser 1
    121 ┃   resetWS
    122 ┃   executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 12) (Seed 6041776208714975061 (-2279196309322888437)) sequential

  ✗ 1 failed.
</pre>

<p>
My goodness, that is pretty output!
</p>

<p>
Anyway, I'd say that the failing program has been shrunk to be minimal so I'd
say that all in all this is a big step up from what I had earlier. Sure, using
the <i>hedgehog</i> state machine API is slightly involved, but once worked out I
find it fairly straight-forward and it most likely is written by people much
more knowledgable than me and better than anything I could produce. Having to
use generators explicitly (the <i>hedgehog</i> way) is neither easier nor more
complicated than defining a few type class instances (the <i>QuickCheck</i> way).
Finally, the integrated shrinking is rather brilliant and <i>not</i> having to
implement that myself is definitely a big benefit.
</p>

<p>
Now I only have to fix the errors in the web service that the test reveal. This
post is already rather long, so I'll keep that for a future post.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
There is still one thing that's unclear to me though, and that's how to
get to the output in an update function.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Put another way, programs will never test how the web service behaves
when asking for non-existing users. I think that, if I want to test that, I'll
opt for using a separate API call type for it.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
At least that's my understanding of the impact of <code>Range.linear 1 10</code>.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hedgehog.html">hedgehog</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>
<div class="post-date">22 Apr 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-04-22-000-comonadic-builders--minor-addition.html">Comonadic builders, minor addition</a></h1>
<p>
When reading about <a href="https://chshersh.github.io/posts/2019-03-25-comonadic-builders">Comonadic builders</a> the other day I reacted to this comment:
</p>

<blockquote>
<p>
The <code>comonad</code> package has the <a href="https://hackage.haskell.org/package/comonad-5.0.4/docs/Control-Comonad-Trans-Traced.html#t:TracedT">Traced</a> <code>newtype</code> wrapper around the function
<code>(-&gt;)</code>. The <code>Comonad</code> instance for this <code>newtype</code> gives us the desired
behaviour. However, dealing with the <code>newtype</code> wrapping and unwrapping makes our
code noisy and truly harder to understand, so let's use the <code>Comonad</code> instance
for the arrow <code>(-&gt;)</code> itself
</p>
</blockquote>

<p>
So, just for fun I thought I work out the "noisy and truly harder" bits.
</p>

<p>
To begin with I needed two language extensions and two imports
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE OverloadedStrings#-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE RecordWildCards #-}</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Control.Comonad.Traced</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Text</span>
</pre>
</div>

<p>
After that I could copy quite a bit of stuff directly from the other post
</p>

<ul class="org-ul">
<li><code>Settings</code> definition</li>
<li>The <code>Semigroup</code> instance for <code>Settings</code></li>
<li>The <code>Monoid</code> instance for <code>Settings</code></li>
<li><code>Project</code> definition</li>
</ul>

<p>
After this everything had only minor changes. First off the <code>ProjectBuilder</code>
type had to be changed to
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">ProjectBuilder</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">Traced</span> <span class="org-haskell-type">Settings</span> <span class="org-haskell-type">Project</span>
</pre>
</div>

<p>
With that done the types of all the functions can actually be left as they are,
but of course the definitions have to modified. However, it turned out that the
necessary modifications were rather smaller than I had expected. First out
<code>buildProject</code> which I decided to call <code>buildProjectW</code> to make it possible to
keep the original code and the new code in the same file without causing name
clashes:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">buildProjectW</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ProjectBuilder</span>
<span class="org-haskell-definition">buildProjectW</span> <span class="org-haskell-operator">=</span> traced <span class="org-haskell-operator">.</span> buildProject
  <span class="org-haskell-keyword">where</span>
    buildProject projectName <span class="org-haskell-constructor">Settings</span><span class="org-rainbow-delimiters-depth-1">{</span><span class="org-haskell-operator">..</span><span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Project</span>
      <span class="org-rainbow-delimiters-depth-1">{</span> projectHasLibrary <span class="org-haskell-operator">=</span> getAny settingsHasLibrary
      , projectGitHub     <span class="org-haskell-operator">=</span> getAny settingsGitHub
      , projectTravis     <span class="org-haskell-operator">=</span> getAny settingsTravis
      , <span class="org-haskell-operator">..</span>
      <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The only difference is the addition of <code>traced .</code> to wrap it up in the
<code>newtype</code>, the rest is copied straight from the original article.
</p>

<p>
The two simple project combinator functions, which I call <code>hasLibraryBW</code> and
<code>gitHubBW</code>, needed a bit of tweaking. In the original version combinators take a
<code>builder</code> which is an ordinary function, so it can just be called. Now however,
the function is wrapped in a <code>newtype</code> so a bit of unwrapping is necessary:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">hasLibraryBW</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ProjectBuilder</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Project</span>
<span class="org-haskell-definition">hasLibraryBW</span> builder <span class="org-haskell-operator">=</span> runTraced builder <span class="org-haskell-operator">$</span> mempty <span class="org-rainbow-delimiters-depth-1">{</span> settingsHasLibrary <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Any</span> <span class="org-haskell-constructor">True</span> <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-haskell-definition">gitHubBW</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ProjectBuilder</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Project</span>
<span class="org-haskell-definition">gitHubBW</span> builder <span class="org-haskell-operator">=</span> runTraced builder <span class="org-haskell-operator">$</span> mempty <span class="org-rainbow-delimiters-depth-1">{</span> settingsGitHub <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Any</span> <span class="org-haskell-constructor">True</span> <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Once again it's rather small differences from the code in the article.
</p>

<p>
As for the final combinator, which I call <code>travisBW</code>, actually needed no changes
at all. I only rewrote it using a <code>when</code> clause, because I prefer that style
over <code>let</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">travisBW</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ProjectBuilder</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Project</span>
<span class="org-haskell-definition">travisBW</span> builder <span class="org-haskell-operator">=</span> project <span class="org-rainbow-delimiters-depth-1">{</span> projectTravis <span class="org-haskell-operator">=</span> projectGitHub project <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">where</span>
    project <span class="org-haskell-operator">=</span> extract builder
</pre>
</div>

<p>
Finally, to show that this implementation hasn't really changed the behaviour
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">&#955;</span> extract <span class="org-haskell-operator">$</span> buildProjectW <span class="org-string">"travis"</span> <span class="org-haskell-operator">=&gt;&gt;</span> travisBW
<span class="org-haskell-constructor">Project</span> <span class="org-rainbow-delimiters-depth-1">{</span> projectName <span class="org-haskell-operator">=</span> <span class="org-string">"travis"</span>
        , projectHasLibrary <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
        , projectGitHub <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
        , projectTravis <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
        <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-haskell-definition">&#955;</span> extract <span class="org-haskell-operator">$</span> buildProjectW <span class="org-string">"github-travis"</span> <span class="org-haskell-operator">=&gt;&gt;</span> gitHubBW <span class="org-haskell-operator">=&gt;&gt;</span> travisBW
<span class="org-haskell-constructor">Project</span> <span class="org-rainbow-delimiters-depth-1">{</span> projectName <span class="org-haskell-operator">=</span> <span class="org-string">"github-travis"</span>
        , projectHasLibrary <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
        , projectGitHub <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
        , projectTravis <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
        <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-haskell-definition">&#955;</span> extract <span class="org-haskell-operator">$</span> buildProjectW <span class="org-string">"travis-github"</span> <span class="org-haskell-operator">=&gt;&gt;</span> travisBW <span class="org-haskell-operator">=&gt;&gt;</span> gitHubBW
<span class="org-haskell-constructor">Project</span> <span class="org-rainbow-delimiters-depth-1">{</span> projectName <span class="org-haskell-operator">=</span> <span class="org-string">"travis-github"</span>
        , projectHasLibrary <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
        , projectGitHub <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
        , projectTravis <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
        <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-comonad.html">comonad</a> <a href="https://magnus.therning.org/tag-builder_pattern.html">builder_pattern</a> </div>
<div class="post-date">03 Mar 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-03-03-000-conduit-and-postgresql.html">Conduit and PostgreSQL</a></h1>
<p>
For a while now I've been playing around with an event-drive software design
(<a href="https://en.wikipedia.org/wiki/Event-driven_architecture">EDA</a>) using <a href="https://hackage.haskell.org/package/conduit"><code>conduit</code></a> for processing of events. For this post the processing can
basically be viewed as the following diagram
</p>

<pre class="example" id="org234dea9">
+-----------+   +------------+   +---------+
|           |   |            |   |         |
| PG source |--&gt;| Processing |--&gt;| PG sink |
|           |   |            |   |         |
+-----------+   +------------+   +---------+
     ^                                |
     |            +------+            |
     |            |      |            |
     |            |  PG  |            |
     +------------|  DB  |&lt;-----------+
                  |      |
                  +------+
</pre>

<p>
I started out looking for Conduit components for PostgreSQL on <a href="https://hackage.haskell.org/">Hackage</a> but
failed to find something fitting so I started looking into writing them myself
using <a href="https://hackage.haskell.org/package/postgresql-simple"><code>postgresql-simple</code></a>.
</p>

<p>
The sink wasn't much of a problem, use <code>await</code> to get an event (a tuple) and
write it to the database. My almost complete ignorance of using databases
resulted in a first version of the source was rather naive and used
busy-waiting. Then I stumbled on PostgreSQL's support for notifications through
the <code>LISTEN</code> and <code>NOTIFY</code> commands. I rather like the result and it seems to
work well.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<p>
It looks like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Control.Monad.IO.Class</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">MonadIO</span>, liftIO<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Data.Aeson</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Value</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Conduit</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">C</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Conduit.Combinators</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">CC</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Data.Text</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Data.Time.Clock</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">UTCTime</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Data.UUID</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">UUID</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Database.PostgreSQL.Simple</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Connection</span>, <span class="org-haskell-constructor">Only</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">..</span><span class="org-rainbow-delimiters-depth-2">)</span>, execute, execute_, query<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Database.PostgreSQL.Simple.Notification</span> <span class="org-rainbow-delimiters-depth-1">(</span>getNotification<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">fst8</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span>a, b, c, d, e, f, g, h<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> a
<span class="org-haskell-definition">fst8</span> <span class="org-rainbow-delimiters-depth-1">(</span>a, <span class="org-haskell-keyword">_</span>, <span class="org-haskell-keyword">_</span>, <span class="org-haskell-keyword">_</span>, <span class="org-haskell-keyword">_</span>, <span class="org-haskell-keyword">_</span>, <span class="org-haskell-keyword">_</span>, <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> a

<span class="org-haskell-definition">dbSource</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Connection</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">C.ConduitT</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Int</span>, <span class="org-haskell-type">UTCTime</span>, <span class="org-haskell-type">Int</span>, <span class="org-haskell-type">Int</span>, <span class="org-haskell-type">Bool</span>, <span class="org-haskell-type">UUID</span>, <span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Value</span><span class="org-rainbow-delimiters-depth-1">)</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">dbSource</span> conn ver <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  res <span class="org-haskell-operator">&lt;-</span> liftIO <span class="org-haskell-operator">$</span> query conn <span class="org-string">"SELECT * from events where id &gt; (?) ORDER BY id"</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Only</span> ver<span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">case</span> res <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      liftIO <span class="org-haskell-operator">$</span> execute_ conn <span class="org-string">"LISTEN MyEvent"</span>
      liftIO <span class="org-haskell-operator">$</span> getNotification conn
      dbSource conn ver
    <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      <span class="org-haskell-keyword">let</span> ver' <span class="org-haskell-operator">=</span> maximum <span class="org-haskell-operator">$</span> map fst8 res
      CC.yieldMany res
      dbSource conn ver'

<span class="org-haskell-definition">dbSink</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Connection</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">C.ConduitT</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Int</span>, <span class="org-haskell-type">Int</span>, <span class="org-haskell-type">Bool</span>, <span class="org-haskell-type">UUID</span>, <span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-type">C.Void</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">dbSink</span> conn <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  evt <span class="org-haskell-operator">&lt;-</span> C.await
  <span class="org-haskell-keyword">case</span> evt <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-haskell-constructor">Just</span> event <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      liftIO <span class="org-haskell-operator">$</span> execute conn <span class="org-string">"INSERT INTO events \</span>
<span class="org-string">                            \(srv_id, stream_id, cmd, cmd_id, correlation_id, event_data) \</span>
<span class="org-string">                            \VALUES (?, ?, ?, ?, ?, ?)"</span> event
      liftIO <span class="org-haskell-operator">$</span> execute_ conn <span class="org-string">"NOTIFY MyEvent"</span>
      dbSink conn
</pre>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
If I've missed something crucial I would of course love to hear about it.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> <a href="https://magnus.therning.org/tag-event_sourcing.html">event_sourcing</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-postgresql.html">postgresql</a> </div>
<div class="post-date">17 Feb 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-02-17-000-choosing-a-conduit-randomly.html">Choosing a conduit randomly</a></h1>
<p>
Lately I've been playing around <a href="https://hackage.haskell.org/package/conduit">conduit</a>. One thing I wanted to try out was to
set up processing where one processing step was chosen on random from a number
of components, based on weights. In short I guess I wanted a function with a
type something like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Int</span>, <span class="org-haskell-type">ConduitT</span> i o m r<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ConduitT</span> i o m r
</pre>
</div>

<p>
I have to admit I don't even know where to start writing such a function<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
but after a little bit of thinking I realised I could get the same effect by
controlling how chunks of data is routed. That is, instead of choosing a
component randomly, I can choose a route randomly. It would look something like
when choosing from three components
</p>

<pre class="example" id="org60d40ef">
                        +---------+   +----------+   +-------------+
                        | Filter  |   | Drop tag |   | Component A |
                    +--&gt;| Value-0 |--&gt;|          |--&gt;|             |--+
                    |   +---------+   +----------+   +-------------+  |
+----------------+  |   +---------+   +----------+   +-------------+  |
| Choose random  |  |   | Filter  |   | Drop tag |   | Component B |  |
| value based on +-----&gt;| Value-1 |--&gt;|          |--&gt;|             |-----&gt;
| weights        |  |   +---------+   +----------+   +-------------+  |
+----------------+  |   +---------+   +----------+   +-------------+  |
                    |   | Filter  |   | Drop tag |   | Component C |  |
                    +--&gt;| Value-2 |--&gt;|          |--&gt;|             |--+
                        +---------+   +----------+   +-------------+
</pre>

<p>
That is
</p>

<ol class="org-ol">
<li>For each chunk that comes in, choose a value randomly based on weights and
tag the chunk with the choosen value, then</li>
<li>split the processing into one route for each component,</li>
<li>in each route filter out chunks tagged with a single value, and</li>
<li>remove the tag, then</li>
<li>pass the chunk to the component, and finally</li>
<li>bring the routes back together again.</li>
</ol>

<p>
Out of these steps all but the very first one are already available in <a href="https://hackage.haskell.org/package/conduit">conduit</a>:
</p>

<ul class="org-ul">
<li>for splitting routes combining them again, use <a href="https://hackage.haskell.org/package/conduit-1.3.1/docs/Data-Conduit.html#v:sequenceConduits"><code>sequenceConduits</code></a></li>
<li>for filtering, use <a href="https://hackage.haskell.org/package/conduit-1.3.1/docs/Data-Conduit-Combinators.html#v:filter"><code>filter</code></a></li>
<li>for dropping the tag, use <a href="https://hackage.haskell.org/package/conduit-1.3.1/docs/Data-Conduit-Combinators.html#v:map"><code>map</code></a></li>
</ul>

<p>
What's left is the beginning. I started with a function to pick a value on
random based on weights<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">pickByWeight</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Int</span>, b<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> b
<span class="org-haskell-definition">pickByWeight</span> xs <span class="org-haskell-operator">=</span> randomRIO <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">1</span>, tot<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span> n <span class="org-haskell-operator">-&gt;</span> return <span class="org-rainbow-delimiters-depth-1">(</span>pick n xs<span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">where</span>
    tot <span class="org-haskell-operator">=</span> sum <span class="org-haskell-operator">$</span> map fst xs

    pick n <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>k, x<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-haskell-constructor">:</span>xs<span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-operator">|</span> n <span class="org-haskell-operator">&lt;=</span> k <span class="org-haskell-operator">=</span> x
      <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> pick <span class="org-rainbow-delimiters-depth-1">(</span>n <span class="org-haskell-operator">-</span> k<span class="org-rainbow-delimiters-depth-1">)</span> xs
    pick <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> error <span class="org-string">"pick error"</span>
</pre>
</div>

<p>
Using that I then made a component that tags chunks
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">picker</span> ws <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  evt <span class="org-haskell-operator">&lt;-</span> await
  <span class="org-haskell-keyword">case</span> evt <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-haskell-constructor">Just</span> e <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      p <span class="org-haskell-operator">&lt;-</span> liftIO <span class="org-haskell-operator">$</span> pickByWeight ws
      yield <span class="org-rainbow-delimiters-depth-1">(</span>p, e<span class="org-rainbow-delimiters-depth-1">)</span>
      picker ws
</pre>
</div>

<p>
I was rather happy with this&#x2026;
</p>

<blockquote>
<p>
<a href="https://twitter.com/snoyberg">@snoyberg</a> just have to let you know, conduit is a joy to use. Thanks for sharing it.
</p>

<p>
&#x2013; Magnus Therning (<a href="https://twitter.com/magthe">@magthe</a>) <a href="https://twitter.com/magthe/status/1093175648993140736">February 6, 2019</a>
</p>
</blockquote>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Except maybe by using Template Haskell to generate the code I did come up
with.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
I used <code>Quickcheck</code>'s <a href="https://hackage.haskell.org/package/QuickCheck-2.12.6.1/docs/Test-QuickCheck-Gen.html#v:frequency"><code>frequency</code></a> as inspiration for writing it.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> </div>
<div class="post-date">10 Feb 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-02-10-000-using-stack-to-get-around-upstream-bugs.html">Using stack to get around upstream bugs</a></h1>
<p>
Recently I bumped into <a href="https://github.com/brendanhay/amazonka/issues/517">a bug in <i>amazonka</i></a>.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> I can't really sit around
waiting for Amazon to fix it, and then for <i>amazonka</i> to use the fixed
documentation to generate the code and make another release.
</p>

<p>
Luckily <a href="https://docs.haskellstack.org/en/stable/README/"><code>stack</code></a> contains features that make it fairly simple to work around this
bug until it's properly fixed. Here's how.
</p>

<ol class="org-ol">
<li>Put the upstream code in a git repository of your own. In my case I simply
forked the <a href="https://github.com/brendanhay/amazonka"><i>amazonka</i> repository on github</a> (my fork is <a href="https://github.com/magthe/amazonka">here</a>).</li>

<li>Fix the bug and commit the change. <a href="https://github.com/magthe/amazonka/commit/1543b65e3a8b692aa9038ada68aaed9967752983">My change to <i>amazonka-codepipeline</i></a> was
simply to remove the missing fields &#x2013; it was easier than trying to make them
optional (i.e. wrapping them in =Maybe=s).</li>

<li>Tell <code>slack</code> to use the code from your modified git repository. In my case I
added the following to my <code>slack.yaml</code>:</li>
</ol>

<pre class="example" id="org3a0d6eb">
extra-deps:
  - github: magthe/amazonka
    commit: 1543b65e3a8b692aa9038ada68aaed9967752983
    subdirs:
      - amazonka-codepipeline
</pre>

<p>
That's it!
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
The guilty party is Amazon, not <i>amazonka</i>, though I was a little
surprised that there doesn't seem to be any established way to modify the Amazon
API documentation before it's used to autogenerate the Haskell code.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-amazonka.html">amazonka</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-stack.html">stack</a> </div>
<div class="post-date">02 Feb 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-02-02-000-the-readert-design-pattern-or-tagless-final-.html">The ReaderT design pattern or tagless final?</a></h1>
<p>
The other week I read V. Kevroletin's <a href="https://serokell.io/blog/2018/12/07/tagless-final">Introduction to Tagless Final</a> and realised
that a couple of my projects, both at work and at home, would benefit from a
refactoring to that approach. All in all I was happy with the changes I made,
even though I haven't made use of all the way. In particular there I could
further improve the tests in a few places by adding more typeclasses. For now
it's good enough and I've clearly gotten some value out of it.
</p>

<p>
I found mr. Kevroletin's article to be a good introduction so I've been passing
it on when people on the <a href="https://functionalprogramming.slack.com/">Functional programming slack</a> bring up questions about
how to organize their code as applications grow. In particular if they mention
that they're using monad transformers. I did exactly that just the other day
<i>@solomon</i> wrote
</p>

<blockquote>
<p>
so i've created a rats nest of IO where almost all the functions in my program
are in <code>ReaderT Env IO ()</code> and I'm not sure how to purify everything and move
the IO to the edge of the program
</p>
</blockquote>

<p>
I proposed tagless final and passed the URL on, and then I got a pointer to the
article <a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">The ReaderT Design Patter</a> which I hadn't seen before.
</p>

<p>
The two approches are similar, at least to me, and I can't really judge if one's
better than the other. Just to get a feel for it I thought I'd try to rewrite
the example in the <code>ReaderT</code> article in a tagless final style.
</p>

<div id="outline-container-org6b0a206" class="outline-2">
<h2 id="org6b0a206">A slightly changed example of <code>ReaderT</code> design pattern</h2>
<div class="outline-text-2" id="text-org6b0a206">
<p>
I decided to make a few changes to the example in the article:
</p>

<ul class="org-ul">
<li>I removed the <code>modify</code> function, instead the code uses the typeclass function
<code>modifyBalance</code> directly.</li>
<li>I separated the instances needed for the tests spatially in the code just to
make it easier to see what's "production" code and what's test code.</li>
<li>I combined the <code>main</code> functions from the various examples to that both an
example (<code>main0</code>) and the test (<code>main1</code>) are run.</li>
<li>I switched from <code>Control.Concurrent.Async.Lifted.Safe</code> (from <code>monad-control</code>)
to <code>UnliftIO.Async</code> (from <code>unliftio</code>)</li>
</ul>

<p>
After that the code looks like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE FlexibleInstances #-}</span>

<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Control.Concurrent.STM</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Control.Monad.Reader</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Control.Monad.State.Strict</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">State</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Say</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Test.Hspec</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">UnliftIO.Async</span>

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Env</span>
  <span class="org-rainbow-delimiters-depth-1">{</span> envLog <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">!</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-3">()</span></span><span class="org-rainbow-delimiters-depth-2">)</span>
  , envBalance <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">!</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">TVar</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-haskell-keyword">class</span> <span class="org-haskell-type">HasLog</span> a <span class="org-haskell-keyword">where</span>
  getLog <span class="org-haskell-operator">::</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HasLog</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-keyword">where</span>
  getLog <span class="org-haskell-operator">=</span> envLog

<span class="org-haskell-keyword">class</span> <span class="org-haskell-type">HasBalance</span> a <span class="org-haskell-keyword">where</span>
  getBalance <span class="org-haskell-operator">::</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">TVar</span> <span class="org-haskell-type">Int</span>

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HasBalance</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-keyword">where</span>
  getBalance <span class="org-haskell-operator">=</span> envBalance

<span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadBalance</span> m <span class="org-haskell-keyword">where</span>
  modifyBalance <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>

<span class="org-haskell-keyword">instance</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">HasBalance</span> env, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadBalance</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">ReaderT</span> env m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  modifyBalance f <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    env <span class="org-haskell-operator">&lt;-</span> ask
    liftIO <span class="org-haskell-operator">$</span> atomically <span class="org-haskell-operator">$</span> modifyTVar' <span class="org-rainbow-delimiters-depth-1">(</span>getBalance env<span class="org-rainbow-delimiters-depth-1">)</span> f

<span class="org-haskell-definition">logSomething</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadReader</span> env m, <span class="org-haskell-type">HasLog</span> env, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">logSomething</span> msg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  env <span class="org-haskell-operator">&lt;-</span> ask
  liftIO <span class="org-haskell-operator">$</span> getLog env msg

<span class="org-haskell-definition">main0</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main0</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  ref <span class="org-haskell-operator">&lt;-</span> newTVarIO <span class="org-highlight-numbers-number">4</span>
  <span class="org-haskell-keyword">let</span> env <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Env</span> <span class="org-rainbow-delimiters-depth-1">{</span> envLog <span class="org-haskell-operator">=</span> sayString , envBalance <span class="org-haskell-operator">=</span> ref <span class="org-rainbow-delimiters-depth-1">}</span>
  runReaderT
    <span class="org-rainbow-delimiters-depth-1">(</span>concurrently_
      <span class="org-rainbow-delimiters-depth-2">(</span>modifyBalance <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">+</span> <span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
      <span class="org-rainbow-delimiters-depth-2">(</span>logSomething <span class="org-string">"Increasing account balance"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
    env
  balance <span class="org-haskell-operator">&lt;-</span> readTVarIO ref
  sayString <span class="org-haskell-operator">$</span> <span class="org-string">"Final balance: "</span> <span class="org-haskell-operator">++</span> show balance

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HasLog</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  getLog <span class="org-haskell-operator">=</span> id

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HasBalance</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">TVar</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  getBalance <span class="org-haskell-operator">=</span> id

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadBalance</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">State.StateT</span> <span class="org-haskell-type">Int</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  modifyBalance <span class="org-haskell-operator">=</span> State.modify

<span class="org-haskell-definition">main1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main1</span> <span class="org-haskell-operator">=</span> hspec <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  describe <span class="org-string">"modify"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    it <span class="org-string">"works, IO"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      var <span class="org-haskell-operator">&lt;-</span> newTVarIO <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>
      runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>modifyBalance <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">+</span> <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> var
      res <span class="org-haskell-operator">&lt;-</span> readTVarIO var
      res <span class="org-haskell-operator">`shouldBe`</span> <span class="org-highlight-numbers-number">3</span>
    it <span class="org-string">"works, pure"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      <span class="org-haskell-keyword">let</span> res <span class="org-haskell-operator">=</span> State.execState <span class="org-rainbow-delimiters-depth-1">(</span>modifyBalance <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">+</span> <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>
      res <span class="org-haskell-operator">`shouldBe`</span> <span class="org-highlight-numbers-number">3</span>
  describe <span class="org-string">"logSomething"</span> <span class="org-haskell-operator">$</span>
    it <span class="org-string">"works"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      var <span class="org-haskell-operator">&lt;-</span> newTVarIO <span class="org-string">""</span>
      <span class="org-haskell-keyword">let</span> logFunc msg <span class="org-haskell-operator">=</span> atomically <span class="org-haskell-operator">$</span> modifyTVar var <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">++</span> msg<span class="org-rainbow-delimiters-depth-1">)</span>
          msg1 <span class="org-haskell-operator">=</span> <span class="org-string">"Hello "</span>
          msg2 <span class="org-haskell-operator">=</span> <span class="org-string">"World\n"</span>
      runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>logSomething msg1 <span class="org-haskell-operator">&gt;&gt;</span> logSomething msg2<span class="org-rainbow-delimiters-depth-1">)</span> logFunc
      res <span class="org-haskell-operator">&lt;-</span> readTVarIO var
      res <span class="org-haskell-operator">`shouldBe`</span> <span class="org-rainbow-delimiters-depth-1">(</span>msg1 <span class="org-haskell-operator">++</span> msg2<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> main0 <span class="org-haskell-operator">&gt;&gt;</span> main1
</pre>
</div>

<p>
I think the distinguising features are
</p>

<ul class="org-ul">
<li>The application environmant, <code>Env</code> will contain configuraiton values (not in
this example), state, <code>envBalance</code>, and functions we might want to vary,
<code>envLog</code></li>
<li>There is no explicit type representing the execution context</li>
<li>Typeclasses are used to abstract over application environment, <code>HasLog</code> and
<code>HasBalance</code></li>
<li>Typeclasses are used to abstract over operations, <code>MonadBalance</code></li>
<li>Typeclasses are implemented for both the application environment, <code>HasLog</code> and
<code>HasBalance</code>, and the execution context, <code>MonadBalance</code></li>
</ul>

<p>
In the end this makes for code with very loose couplings; there's not really any
single concrete type that implements all the constraints to work in the "real"
main function (<code>main0</code>). I could of course introduce a type synonym for it
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">App</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ReaderT</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-type">IO</span>
</pre>
</div>

<p>
but it brings no value &#x2013; it wouldn't be used explicitly anywhere.
</p>
</div>
</div>

<div id="outline-container-org65b3426" class="outline-2">
<h2 id="org65b3426">A tagless final version</h2>
<div class="outline-text-2" id="text-org65b3426">
<p>
In order to compare the <code>ReaderT</code> design pattern to tagless final (as I
understand it) I made an attempt to translate the code above. The code below is
the result.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeFamilies #-}</span>

<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Control.Concurrent.STM</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Control.Monad.Identity</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">Id</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Control.Monad.Reader</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Control.Monad.State.Strict</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">State</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Say</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Test.Hspec</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">UnliftIO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">MonadUnliftIO</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">UnliftIO.Async</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Env</span> <span class="org-rainbow-delimiters-depth-1">{</span>envBalance <span class="org-haskell-operator">::</span> <span class="org-haskell-type">TVar</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ReaderT</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-type">IO</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span>, <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Env</span>, <span class="org-haskell-constructor">MonadUnliftIO</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> a
<span class="org-haskell-definition">runAppM</span> env app <span class="org-haskell-operator">=</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span> env

<span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">ModifyM</span> m <span class="org-haskell-keyword">where</span>
  mModify <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>

<span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">LogSomethingM</span> m <span class="org-haskell-keyword">where</span>
  mLogSomething <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> m<span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">ModifyM</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mModify f <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    ref <span class="org-haskell-operator">&lt;-</span> asks envBalance
    liftIO <span class="org-haskell-operator">$</span> atomically <span class="org-haskell-operator">$</span> modifyTVar' ref f

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">LogSomethingM</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mLogSomething <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">.</span> sayString

<span class="org-haskell-definition">main0</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main0</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  ref <span class="org-haskell-operator">&lt;-</span> newTVarIO <span class="org-highlight-numbers-number">4</span>
  <span class="org-haskell-keyword">let</span> env <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Env</span> ref
  runAppM env
    <span class="org-rainbow-delimiters-depth-1">(</span>concurrently_
      <span class="org-rainbow-delimiters-depth-2">(</span>mModify <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">+</span> <span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
      <span class="org-rainbow-delimiters-depth-2">(</span>mLogSomething <span class="org-string">"Increasing account balance"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
  balance <span class="org-haskell-operator">&lt;-</span> readTVarIO ref
  sayString <span class="org-haskell-operator">$</span> <span class="org-string">"Final balance: "</span> <span class="org-haskell-operator">++</span> show balance

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">ModifyAppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ModifyAppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unModifyAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State.StateT</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-type">Id.Identity</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">State.MonadState</span> <span class="org-haskell-constructor">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runModifyAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ModifyAppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>a, <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">runModifyAppM</span> s app <span class="org-haskell-operator">=</span> Id.runIdentity <span class="org-haskell-operator">$</span> State.runStateT <span class="org-rainbow-delimiters-depth-1">(</span>unModifyAppM app<span class="org-rainbow-delimiters-depth-1">)</span> s

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">ModifyM</span> <span class="org-haskell-type">ModifyAppM</span> <span class="org-haskell-keyword">where</span>
  mModify <span class="org-haskell-operator">=</span> State.modify'

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">LogAppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">LogAppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unLogAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ReaderT</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">TVar</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-type">IO</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span>, <span class="org-haskell-constructor">MonadReader</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">TVar</span> <span class="org-haskell-constructor">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runLogAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">TVar</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">LogAppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> a
<span class="org-haskell-definition">runLogAppM</span> env app <span class="org-haskell-operator">=</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unLogAppM app<span class="org-rainbow-delimiters-depth-1">)</span> env

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">LogSomethingM</span> <span class="org-haskell-type">LogAppM</span> <span class="org-haskell-keyword">where</span>
  mLogSomething msg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    var <span class="org-haskell-operator">&lt;-</span> ask
    liftIO <span class="org-haskell-operator">$</span> atomically <span class="org-haskell-operator">$</span> modifyTVar var <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">++</span> msg<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">main1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main1</span> <span class="org-haskell-operator">=</span> hspec <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  describe <span class="org-string">"mModify"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    it <span class="org-string">"works, IO"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      var <span class="org-haskell-operator">&lt;-</span> newTVarIO <span class="org-highlight-numbers-number">1</span>
      runAppM <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Env</span> var<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>mModify <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">+</span> <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
      res <span class="org-haskell-operator">&lt;-</span> readTVarIO var
      res <span class="org-haskell-operator">`shouldBe`</span> <span class="org-highlight-numbers-number">3</span>
    it <span class="org-string">"works, pure"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      <span class="org-haskell-keyword">let</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-keyword">_</span>, res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> runModifyAppM <span class="org-highlight-numbers-number">1</span> <span class="org-rainbow-delimiters-depth-1">(</span>mModify <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">+</span> <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
      res <span class="org-haskell-operator">`shouldBe`</span> <span class="org-highlight-numbers-number">3</span>
  describe <span class="org-string">"mLogSomething"</span> <span class="org-haskell-operator">$</span>
    it <span class="org-string">"works"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      var <span class="org-haskell-operator">&lt;-</span> newTVarIO <span class="org-string">""</span>
      runLogAppM var <span class="org-rainbow-delimiters-depth-1">(</span>mLogSomething <span class="org-string">"Hello"</span> <span class="org-haskell-operator">&gt;&gt;</span> mLogSomething <span class="org-string">"World!"</span><span class="org-rainbow-delimiters-depth-1">)</span>
      res <span class="org-haskell-operator">&lt;-</span> readTVarIO var
      res <span class="org-haskell-operator">`shouldBe`</span> <span class="org-string">"HelloWorld!"</span>

<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> main0 <span class="org-haskell-operator">&gt;&gt;</span> main1
</pre>
</div>

<p>
The steps for the "real" part of the program were
</p>

<ol class="org-ol">
<li>Introduce an execution type, <code>AppM</code>, with a convenience function for running
it, <code>runAppM</code></li>
<li>Remove the log function from the environment type, <code>envLog</code> in <code>Env</code></li>
<li>Remove all the <code>HasX</code> classes</li>
<li>Create a new operations typeclass for logging, <code>LogSomethingM</code></li>
<li>Rename the operations typeclass for modifying the balance to match the naming
found in the <a href="https://serokell.io/blog/2018/12/07/tagless-final">tagless article</a> a bit better, <code>ModifyM</code></li>
<li>Implement instances of both operations typeclasses for <code>AppM</code></li>
</ol>

<p>
For testing the steps were
</p>

<ol class="org-ol">
<li>Define an execution type for each test, <code>ModifyAppM</code> and <code>LogAppM</code>, with some
convenience functions for running them, <code>runModifyAppM</code> and <code>runLogAppM</code></li>
<li>Write instances for the operations typeclasses, one for each</li>
</ol>

<p>
So I think the distinguising features are
</p>

<ul class="org-ul">
<li>There's both an environment type, <code>Env</code>, and an execution type <code>AppM</code> that
wraps it</li>
<li>The environment holds only configuration values (none in this example), and
state (<code>envBalance</code>)</li>
<li>Typeclasses are used to abstract over operations, <code>LogSomethingM</code> and
<code>ModifyM</code></li>
<li>Typeclasses are only implemented for the execution type</li>
</ul>

<p>
This version has slightly more coupling, the execution type specifies the
environment to use, and the operations are tied directly to the execution type.
However, this coupling doesn't really make a big difference &#x2013; looking at the
pure modify test the amount of code don't differ by much.
</p>
</div>

<div id="outline-container-org9a9bb0f" class="outline-3">
<h3 id="org9a9bb0f">A short note (mostly to myself)</h3>
<div class="outline-text-3" id="text-org9a9bb0f">
<p>
I did write it using <code>monad-control</code> first, and then I needed an instance for
<code>MonadBaseControl IO</code>. Deriving it automatically requires <code>UndecidableInstances</code>
and I didn't really dare turn that on, so I ended up writing the instance. After
some help on <a href="https://mail.haskell.org/pipermail/haskell-cafe/2019-February/130667.html">haskell-cafe</a> it ended up looking like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadBaseControl</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  <span class="org-haskell-keyword">type</span> <span class="org-haskell-type">StM</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> a
  liftBaseWith f <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">(</span>liftBaseWith <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span> run <span class="org-haskell-operator">-&gt;</span> f <span class="org-rainbow-delimiters-depth-2">(</span>run <span class="org-haskell-operator">.</span> unAppM<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
  restoreM <span class="org-haskell-operator">=</span> return
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge8c9125" class="outline-2">
<h2 id="orge8c9125">Conclusion</h2>
<div class="outline-text-2" id="text-orge8c9125">
<p>
My theoretical knowledge isn't anywhere near good enough to say anything
objectively about the difference in expressiveness of the two design patterns.
That means that my conclusion comes down to taste, do you like the <code>readerT</code>
patter or tagless final better?
</p>

<p>
I like the slightly looser coupling I get with the <code>ReaderT</code> pattern. Loose
coupling is (almost) always a desirable goal. However, I can see that tying the
typeclass instances directly to a concrete execution type results in the intent
being communicated a little more clearly. Clearly communicating intent in code
is also a desirable goal. In particular I suspect it'll result in more
actionable error messages when making changes to the code &#x2013; the error will tell
me that my execution type lacks an instance of a specific typeclass, instead of
it telling me that a particular transformer stack does. On the other hand, in
the <code>ReaderT</code> pattern that stack is very shallow.
</p>

<p>
One possibility would be that one pattern is better suited for libraries and the
other for applications. I don't think that's the case though as in both cases
the library code would be written in a style that results in typeclass
constraints on the caller and providing instances for those typeclasses is
roughly an equal amount of work for both styles.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Please do point out any mistakes I've made in this, in particular if they
stem from me misunderstanding tagless final completely.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-tagless_final.html">tagless_final</a> <a href="https://magnus.therning.org/tag-readert.html">readert</a> <a href="https://magnus.therning.org/tag-monad.html">monad</a> <a href="https://magnus.therning.org/tag-monad_transformers.html">monad_transformers</a> </div>
<div class="post-date">28 Jan 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-01-28-000-a-missing-piece-in-my-emacs-spacemacs-setup-for-haskell-development.html">A missing piece in my Emacs/Spacemacs setup for Haskell development</a></h1>
<p>
With the help of a work mate I've finally found this gem that's been missing
from my Spacemacs setup
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">with-eval-after-load</span> 'intero
  <span class="org-rainbow-delimiters-depth-2">(</span>flycheck-add-next-checker 'intero '<span class="org-rainbow-delimiters-depth-3">(</span>warning . haskell-hlint<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>flycheck-add-next-checker 'intero '<span class="org-rainbow-delimiters-depth-3">(</span>warning . haskell-stack-ghc<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-spacemacs.html">spacemacs</a> </div>
<div class="post-date">20 Jan 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-01-20-000-tagless-final-and-scotty.html">Tagless final and Scotty</a></h1>
<p>
For a little while I've been playing around with event sourcing in Haskell using
<a href="https://hackage.haskell.org/package/conduit"><code>Conduit</code></a> and <a href="https://hackage.haskell.org/package/scotty"><code>Scotty</code></a>. I've come far enough that the basic functionality I'm
after is there together with all those little bits that make it a piece of
software that's fit for deployment in production (configuration, logging, etc.).
There's just one thing that's been nagging me, testability.
</p>

<p>
The app is built of two main parts, a web server (<code>Scotty</code>) and a pipeline of
stream processing components (<code>Conduit</code>). The part using <code>Scotty</code> is utilising a
simple monad stack, <code>ReaderT Config IO</code>, and the <code>Conduit</code> part is using
<code>Conduit In Out IO</code>. This means that in both parts the outer edge, the part
dealing with the outside world, is running in <code>IO</code> directly. Something that
isn't really aiding in testing.
</p>

<p>
I started out thinking that I'd rewrite what I have using a free monad with a
bunch of interpreters. Then I remembered that I have "check out tagless final".
This post is a record of the small experiments I did to see how to use it with
<code>Scotty</code> to achieve (and actually improve) on the code I have in my
production-ready code.
</p>

<div id="outline-container-org70bf102" class="outline-2">
<h2 id="org70bf102">1 - Use tagless final with <code>Scotty</code></h2>
<div class="outline-text-2" id="text-org70bf102">
<p>
As a first simple little experiment I wrote a tiny little web server that would
print a string to <code>stdout</code> when receiving the request to <code>GET /route0</code>.
</p>

<p>
The printing to <code>stdout</code> is the operation I want to make abstract.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadPrinter</span> m <span class="org-haskell-keyword">where</span>
  mPutStrLn <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
</pre>
</div>

<p>
I then created an application type that is an instance of that class.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span> unAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> a <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadPrinter</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mPutStrLn t <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> putStrLn <span class="org-rainbow-delimiters-depth-1">(</span>unpack t<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Then I added a bit of <code>Scotty</code> boilerplate. It's not strictly necessary, but
does make the code a bit nicer to read.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">FooM</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ScottyT</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-type">AppM</span>
<span class="org-haskell-keyword">type</span> <span class="org-haskell-type">FooActionM</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ActionT</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-type">AppM</span>

<span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Port</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ScottyT</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">foo</span> port <span class="org-haskell-operator">=</span> scottyT port unAppM
</pre>
</div>

<p>
With that in place the web server itself is just a matter of tying it all
together.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  foo <span class="org-highlight-numbers-number">3000</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    get <span class="org-string">"/route0"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      lift <span class="org-haskell-operator">$</span> mPutStrLn <span class="org-string">"getting /route0"</span>
      json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"route0"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"ok"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    notFound <span class="org-haskell-operator">$</span> json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"error"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"not found"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
That was simple enough.
</p>
</div>
</div>

<div id="outline-container-org032b911" class="outline-2">
<h2 id="org032b911">2 - Add configuration</h2>
<div class="outline-text-2" id="text-org032b911">
<p>
In order to try out how to deal with configuration I added a class for doing
some simple logging
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadLogger</span> m <span class="org-haskell-keyword">where</span>
  mLog <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
</pre>
</div>

<p>
The straight forward way to deal with configuration is to create a monad stack
with <code>ReaderT</code> and since it's logging I want to do the configuration consists of
a single <code>LoggerSet</code> (from <a href="https://hackage.haskell.org/package/fast-logger"><code>fast-logger</code></a>).
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span> unAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ReaderT</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-type">IO</span> a <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span>, <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">LoggerSet</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That means the class instance can be implemented like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadLogger</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mLog msg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    ls <span class="org-haskell-operator">&lt;-</span> ask
    liftIO <span class="org-haskell-operator">$</span> pushLogStrLn ls <span class="org-haskell-operator">$</span> toLogStr msg
</pre>
</div>

<p>
Of course <code>foo</code> has to be changed too, and it becomes a little easier with a
wrapper for <code>runReaderT</code> and <code>unAppM</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Port</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ScottyT</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">foo</span> ls port <span class="org-haskell-operator">=</span> scottyT port <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">`runAppM`</span> ls<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> a
<span class="org-haskell-definition">runAppM</span> app ls <span class="org-haskell-operator">=</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span> ls
</pre>
</div>

<p>
With that in place the printing to <code>stdout</code> can be replaced by a writing to the
log.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  ls <span class="org-haskell-operator">&lt;-</span> newStdoutLoggerSet defaultBufSize
  foo ls <span class="org-highlight-numbers-number">3000</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    get <span class="org-string">"/route0"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      lift <span class="org-haskell-operator">$</span> mLog <span class="org-string">"log: getting /route0"</span>
      json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"route0"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"ok"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    notFound <span class="org-haskell-operator">$</span> json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"error"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"not found"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
Not really a big change, I'd say. Extending the configuration is clearly
straight forward too.
</p>
</div>
</div>

<div id="outline-container-org9bf256e" class="outline-2">
<h2 id="org9bf256e">3 - Per-request configuration</h2>
<div class="outline-text-2" id="text-org9bf256e">
<p>
At work we use correlation IDs<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> and I think that the most convenient way to
deal with it is to put the correlation ID into the configuration after
extracting it. That is, I want to modify the configuration on each request.
Luckily it turns out to be possible to do that, despite using <code>ReaderT</code> for
holding the configuration.
</p>

<p>
I can't be bothered with a full implementation of correlation ID for this little
experiment, but as long as I can get a new <code>AppM</code> by running a function on the
configuration it's just a matter of extracting the correct header from the
request. For this experiment it'll do to just modify an integer in the
configuration.
</p>

<p>
I start with defining a type for the configuration and changing <code>AppM</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">LoggerSet</span>, <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span> unAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ReaderT</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-type">IO</span> a <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span>, <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Config</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The logger instance has to be changed accordingly of course.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadLogger</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mLog msg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>ls, i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> ask
    liftIO <span class="org-haskell-operator">$</span> pushLogStrLn ls <span class="org-haskell-operator">$</span> toLogStr msg <span class="org-haskell-operator">&lt;&gt;</span> toLogStr <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">":"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;&gt;</span> toLogStr <span class="org-rainbow-delimiters-depth-1">(</span>show i<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The <code>get</code> function that comes with <code>scotty</code> isn't going to cut it, since it has
no way of modifying the configuration, so I'll need a new one.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mGet</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ScottyError</span> e <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">RoutePattern</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ActionT</span> e <span class="org-haskell-type">AppM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ScottyT</span> e <span class="org-haskell-type">AppM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">mGet</span> p a <span class="org-haskell-operator">=</span> get p <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  withCfg <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> <span class="org-rainbow-delimiters-depth-2">(</span>ls, i<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span>ls, succ i<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> a
</pre>
</div>

<p>
The tricky bit is in the <code>withCfg</code> function. It's indeed not very easy to read,
I think
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">withCfg</span> <span class="org-haskell-operator">=</span> mapActionT <span class="org-haskell-operator">.</span> withAppM
  <span class="org-haskell-keyword">where</span>
    mapActionT f <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">ActionT</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ActionT</span> <span class="org-haskell-operator">$</span> <span class="org-rainbow-delimiters-depth-1">(</span>mapExceptT <span class="org-haskell-operator">.</span> mapReaderT <span class="org-haskell-operator">.</span> mapStateT<span class="org-rainbow-delimiters-depth-1">)</span> f a
    withAppM f a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-haskell-operator">$</span> withReaderT f <span class="org-rainbow-delimiters-depth-1">(</span>unAppM a<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Basically it reaches into the guts of <code>scotty</code>'s <code>ActionT</code> type (the details are
exposed in <code>Web.Scotty.Internal.Types</code>, thanks for not hiding it completely),
and modifies the <code>ReaderT Config</code> I've supplied.
</p>

<p>
The new server has two routes, the original one and a new one at <code>GET /route1</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  putStrLn <span class="org-string">"Starting"</span>
  ls <span class="org-haskell-operator">&lt;-</span> newStdoutLoggerSet defaultBufSize
  foo <span class="org-rainbow-delimiters-depth-1">(</span>ls, <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-highlight-numbers-number">3000</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    get <span class="org-string">"/route0"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      lift <span class="org-haskell-operator">$</span> mLog <span class="org-string">"log: getting /route0"</span>
      json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"route0"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"ok"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    mGet <span class="org-string">"/route1"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      lift <span class="org-haskell-operator">$</span> mLog <span class="org-string">"log: getting /route1"</span>
      json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"route1"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"bar"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    notFound <span class="org-haskell-operator">$</span> json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"error"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"not found"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
It's now easy to verify that the original route, <code>GET /route0</code>, logs a string
containing the integer '0', while the new route, <code>GET /route1</code>, logs a string
containing the integer '1'.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
If you don't know what it is you'll find multiple sources by searching
for "http correlation-id". <a href="https://theburningmonk.com/2015/05/a-consistent-approach-to-track-correlation-ids-through-microservices/">A consistent approach to track correlation IDs
through microservices</a> is as good a place to start as any.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-scotty.html">scotty</a> <a href="https://magnus.therning.org/tag-tagless_final.html">tagless_final</a> </div>
<div class="post-date">16 Oct 2018</div><h1 class="post-title"><a href="https://magnus.therning.org/2018-10-16-000-zipping-streams.html">Zipping streams</a></h1>
<p>
Writing the following is easy after glancing through the documentation for
<a href="https://hackage.haskell.org/package/conduit">conduit</a>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">let</span> src <span class="org-haskell-operator">=</span> mapM_ C.yield <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">0</span><span class="org-haskell-operator">..</span><span class="org-highlight-numbers-number">9</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">]</span>
          p0 <span class="org-haskell-operator">=</span> CC.map <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> i <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"p0"</span>, succ i<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
          p1 <span class="org-haskell-operator">=</span> CC.filter odd <span class="org-haskell-operator">.|</span> CC.map <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> i <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"p1"</span>, i<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
          p <span class="org-haskell-operator">=</span> C.getZipConduit <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">C.ZipConduit</span> p0 <span class="org-haskell-operator">&lt;*</span> <span class="org-haskell-constructor">C.ZipConduit</span> p1
          sink <span class="org-haskell-operator">=</span> CC.mapM_ print
      <span class="org-haskell-keyword">in</span> C.runConduit <span class="org-haskell-operator">$</span> src <span class="org-haskell-operator">.|</span> p <span class="org-haskell-operator">.|</span> sink
</pre>
</div>

<p>
Neither <a href="https://hackage.haskell.org/package/pipes">pipes</a> nor <a href="https://hackage.haskell.org/package/streaming">streaming</a> make it as easy to figure out. I must be missing
something! What functions should I be looking at?
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> <a href="https://magnus.therning.org/tag-pipes.html">pipes</a> <a href="https://magnus.therning.org/tag-streaming.html">streaming</a> </div>
<div class="post-date">01 Oct 2018</div><h1 class="post-title"><a href="https://magnus.therning.org/2018-10-01-000-using-a-configuration-in-scotty.html">Using a configuration in Scotty</a></h1>
<p>
At work we're only now getting around to put <a href="https://hilton.org.uk/blog/microservices-correlation-id">correlation IDs</a> into use. We write
most our code in Clojure but since I'd really like to use more Haskell at work I
thought I'd dive into <a href="https://hackage.haskell.org/package/scotty">Scotty</a> and see how to deal with logging and then
especially how to get correlation IDs into the logs.
</p>

<div id="outline-container-org908bdc9" class="outline-2">
<h2 id="org908bdc9">The types</h2>
<div class="outline-text-2" id="text-org908bdc9">
<p>
For configuration it decided to use the reader monad inside <code>ActionT</code> from
Scotty. Enter Chell:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">ChellM</span> c <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ScottyT</span> <span class="org-haskell-type">Text</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">ReaderT</span> c <span class="org-haskell-type">IO</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">type</span> <span class="org-haskell-type">ChellActionM</span> c <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ActionT</span> <span class="org-haskell-type">Text</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">ReaderT</span> c <span class="org-haskell-type">IO</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
In order to run it I wrote a function corresponding to <code>scotty</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">chell</span> <span class="org-haskell-operator">::</span> c <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Port</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">chell</span> cfg port a <span class="org-haskell-operator">=</span> scottyOptsT opts <span class="org-rainbow-delimiters-depth-1">(</span>flip runReaderT cfg<span class="org-rainbow-delimiters-depth-1">)</span> a
  <span class="org-haskell-keyword">where</span>
    opts <span class="org-haskell-operator">=</span> def <span class="org-rainbow-delimiters-depth-1">{</span> verbose <span class="org-haskell-operator">=</span> <span class="org-highlight-numbers-number">0</span>
               , settings <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-2">(</span>settings def<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> settingsPort <span class="org-haskell-operator">=</span> port <span class="org-rainbow-delimiters-depth-2">}</span>
               <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6fb6127" class="outline-2">
<h2 id="org6fb6127">Correlation ID</h2>
<div class="outline-text-2" id="text-org6fb6127">
<p>
To deal with the correlation ID each incoming request should be checked for the
HTTP header <code>X-Correlation-Id</code> and if present it should be used during logging.
If no such header is present then a new correlation ID should be created. Since
it's per request it feels natural to create a WAI middleware for this.
</p>

<p>
The easiest way I could come up with was to push the correlation ID into the
request's headers before it's passed on:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">requestHeaderCorrelationId</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Request</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">ByteString</span>
<span class="org-haskell-definition">requestHeaderCorrelationId</span> <span class="org-haskell-operator">=</span> lookup <span class="org-string">"X-Correlation-Id"</span> <span class="org-haskell-operator">.</span> requestHeaders

<span class="org-haskell-definition">correlationId</span> <span class="org-haskell-operator">::</span>  <span class="org-haskell-type">Middleware</span>
<span class="org-haskell-definition">correlationId</span> app req sendResponse <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  u <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-1">(</span>randomIO <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">UUID</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">let</span> corrId <span class="org-haskell-operator">=</span> maybe <span class="org-rainbow-delimiters-depth-1">(</span>toASCIIBytes u<span class="org-rainbow-delimiters-depth-1">)</span> id <span class="org-rainbow-delimiters-depth-1">(</span>requestHeaderCorrelationId req<span class="org-rainbow-delimiters-depth-1">)</span>
      newHeaders <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"X-Correlation-Id"</span>, corrId<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">:</span> <span class="org-rainbow-delimiters-depth-1">(</span>requestHeaders req<span class="org-rainbow-delimiters-depth-1">)</span>
  app <span class="org-rainbow-delimiters-depth-1">(</span>req <span class="org-rainbow-delimiters-depth-2">{</span> requestHeaders <span class="org-haskell-operator">=</span> newHeaders <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span> res <span class="org-haskell-operator">-&gt;</span> sendResponse res
</pre>
</div>

<p>
It also turns out to be useful to have both a default correlation ID and a
function for pulling it out of the headers:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">defaultCorrelationString</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ByteString</span>
<span class="org-haskell-definition">defaultCorrelationString</span> <span class="org-haskell-operator">=</span> <span class="org-string">"no-correlation-id"</span>

<span class="org-haskell-definition">getCorrelationId</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Request</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ByteString</span>
<span class="org-haskell-definition">getCorrelationId</span> r <span class="org-haskell-operator">=</span> maybe defaultCorrelationString id <span class="org-rainbow-delimiters-depth-1">(</span>requestHeaderCorrelationId r<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org210c543" class="outline-2">
<h2 id="org210c543">Getting the correlation ID into the configuration</h2>
<div class="outline-text-2" id="text-org210c543">
<p>
Since the correlation ID should be picked out of the request on handling of
every request it's useful to have it the configuration when running the
<code>ChellActionM</code> actions. However, since the correlation ID isn't available when
running the reader (the call to <code>runReaderT</code> in <code>chell</code>) something else is
called for. When looking around I found <code>local</code> (and later I was pointed to the
more general <code>withReaderT</code>) but it doesn't have a suitable type. After some <a href="https://twitter.com/EyalL/status/1046696148218580993">help
on Twitter</a> I arrived at <code>withConfig</code> which allows me to run an action in a
modified configuration:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">withConfig</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span>c <span class="org-haskell-operator">-&gt;</span> c'<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellActionM</span> c' <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellActionM</span> c <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">withConfig</span> <span class="org-haskell-operator">=</span> mapActionT <span class="org-haskell-operator">.</span> withReaderT
  <span class="org-haskell-keyword">where</span>
    mapActionT f <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">ActionT</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ActionT</span> <span class="org-haskell-operator">$</span> <span class="org-rainbow-delimiters-depth-1">(</span>mapExceptT <span class="org-haskell-operator">.</span> mapReaderT <span class="org-haskell-operator">.</span> mapStateT<span class="org-rainbow-delimiters-depth-1">)</span> f a
</pre>
</div>
</div>
</div>

<div id="outline-container-org5962f2c" class="outline-2">
<h2 id="org5962f2c">Making it handy to use</h2>
<div class="outline-text-2" id="text-org5962f2c">
<p>
Armed with this I can put together some functions to replace Scotty's <code>get</code>,
<code>post</code>, etc. With a configuration type like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Cfg</span> <span class="org-haskell-constructor">LoggerSet</span> <span class="org-haskell-constructor">ByteString</span>
</pre>
</div>

<p>
The modified <code>get</code> looks like this (Scotty's original is <code>S.get</code>)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">get</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">RoutePattern</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellActionM</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellM</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">get</span> p a <span class="org-haskell-operator">=</span> S.get p <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  r <span class="org-haskell-operator">&lt;-</span> request
  <span class="org-haskell-keyword">let</span> corrId <span class="org-haskell-operator">=</span> getCorrelationId r
  withConfig <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Cfg</span> l <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Cfg</span> l corrId<span class="org-rainbow-delimiters-depth-1">)</span> a
</pre>
</div>

<p>
With this in place I can use the simpler <code>ReaderT Config IO</code> for inner functions
that need to log.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-scotty.html">scotty</a> <a href="https://magnus.therning.org/tag-monad.html">monad</a> </div>
<div class="post-date">14 Jul 2018</div><h1 class="post-title"><a href="https://magnus.therning.org/2018-07-14-000-quickcheck-on-a-rest-api.html">QuickCheck on a REST API</a></h1>
<p>
Since I'm working with web stuff nowadays I thought I'd play a little with
translating my old post on <a href="2015-06-15-000-using-quickcheck-to-test-c-apis.html">using QuickCheck to test C APIs</a> to the web.
</p>

<div id="outline-container-orgd2e8eeb" class="outline-2">
<h2 id="orgd2e8eeb">The goal and how to reach it</h2>
<div class="outline-text-2" id="text-orgd2e8eeb">
<p>
I want to use <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> to test a REST API, just like in the case of the C API
the idea is to
</p>

<ol class="org-ol">
<li>generate a sequence of API calls (a <i>program</i>), then</li>
<li>run the sequence against a model, as well as</li>
<li>run the sequence against the web service, and finally</li>
<li>compare the resulting model against reality.</li>
</ol>
</div>
</div>

<div id="outline-container-org776189d" class="outline-2">
<h2 id="org776189d">The REST API</h2>
<div class="outline-text-2" id="text-org776189d">
<p>
I'll use a small web service I'm working on, and then concentrate on only a
small part of the API to begin with.
</p>

<p>
The parts of the API I'll use for the programs at this stage are
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Method</th>
<th scope="col" class="org-left">Route</th>
<th scope="col" class="org-left">Example in</th>
<th scope="col" class="org-left">Example out</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>POST</code></td>
<td class="org-left"><code>/users</code></td>
<td class="org-left"><code>{"userId": 0, "userName": "Yogi Berra"}</code></td>
<td class="org-left"><code>{"userId": 42, "userName": "Yogi Berra"}</code></td>
</tr>

<tr>
<td class="org-left"><code>DELETE</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
The following API calls will also be used, but not in the programs
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Method</th>
<th scope="col" class="org-left">Route</th>
<th scope="col" class="org-left">Example in</th>
<th scope="col" class="org-left">Example out</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>[0,3,7]</code></td>
</tr>

<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>{"userId": 42, "userName": "Yogi Berra"}</code></td>
</tr>

<tr>
<td class="org-left"><code>POST</code></td>
<td class="org-left"><code>/reset</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org45a80a7" class="outline-2">
<h2 id="org45a80a7">Representing API calls</h2>
<div class="outline-text-2" id="text-org45a80a7">
<p>
Given the information about the API above it seems the following is enough to
represent the two calls of interest together with a constructor representing the
end of a program
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">ApiCall</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-constructor">Text</span>
             <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-constructor">Int</span>
             <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">EndProgram</span>
             <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
and a program is just a sequence of calls, so list of <code>ApiCall</code> will do.
However, since I want to generate sequences of calls, i.e. implement
<code>Arbitrary</code>, I'll wrap it in a <code>newtype</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Prog</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-constructor">ApiCall</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8734229" class="outline-2">
<h2 id="org8734229">Running against a model (simulation)</h2>
<div class="outline-text-2" id="text-org8734229">
<p>
First of all I need to decide what model to use. Based on the part of the API
I'm using I'll use an ordinary dictionary of <code>Int</code> and <code>Text</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">Model</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">M.Map</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-type">Text</span>
</pre>
</div>

<p>
Simulating execution of a program is simulating each call against a
model that's updated with each step. I expect the final model to
correspond to the state of the real service after the program is run for
real. The simulation begins with an empty dictionary.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">simulateProgram</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Model</span>
<span class="org-haskell-definition">simulateProgram</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Prog</span> cs<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> foldl simulateCall M.empty cs
</pre>
</div>

<p>
The simulation of the API calls must then be a function taking a model and a
call, returning an updated model
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">simulateCall</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Model</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ApiCall</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Model</span>
<span class="org-haskell-definition">simulateCall</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> t<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> M.insert k t m
  <span class="org-haskell-keyword">where</span>
    k <span class="org-haskell-operator">=</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.keys m<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">simulateCall</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> k<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> M.delete k m
<span class="org-haskell-definition">simulateCall</span> m <span class="org-haskell-constructor">EndProgram</span> <span class="org-haskell-operator">=</span> m
</pre>
</div>

<p>
Here I have to make a few assumptions. First, I assume the indeces for the users
start on <code>1</code>. Second, that the next index used always is the successor of
highest currently used index. We'll see how well this holds up to reality later
on.
</p>
</div>
</div>

<div id="outline-container-org9c8cb3a" class="outline-2">
<h2 id="org9c8cb3a">Running against the web service</h2>
<div class="outline-text-2" id="text-org9c8cb3a">
<p>
Running the program against the actual web service follows the same pattern, but
here I'm dealing with the real world, so it's a little more messy, i.e. <code>IO</code> is
involved. First the running of a single call
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">runCall</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Manager</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ApiCall</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">runCall</span> mgr <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> t<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  ireq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/users"</span>
  <span class="org-haskell-keyword">let</span> req <span class="org-haskell-operator">=</span> ireq <span class="org-rainbow-delimiters-depth-1">{</span> requestBody <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RequestBodyLBS</span> <span class="org-rainbow-delimiters-depth-2">(</span>encode <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">User</span> <span class="org-highlight-numbers-number">0</span> t<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>
  resp <span class="org-haskell-operator">&lt;-</span> httpLbs req mgr
  guard <span class="org-rainbow-delimiters-depth-1">(</span>status201 <span class="org-haskell-operator">==</span> responseStatus resp<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runCall</span> mgr <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> k<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  req <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"DELETE http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show k
  resp <span class="org-haskell-operator">&lt;-</span> httpNoBody req mgr
  guard <span class="org-rainbow-delimiters-depth-1">(</span>status200 <span class="org-haskell-operator">==</span> responseStatus resp<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runCall</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-constructor">EndProgram</span> <span class="org-haskell-operator">=</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
</pre>
</div>

<p>
The running of a program is slightly more involved. Of course I have to set up
the <code>Manager</code> needed for the HTTP calls, but I also need to
</p>

<ol class="org-ol">
<li>ensure that the web service is in a well-known state before starting, and</li>
<li>extract the state of the web service after running the program, so I can
compare it to the model</li>
</ol>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">runProgram</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Model</span>
<span class="org-haskell-definition">runProgram</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Prog</span> cs<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
  resetReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/reset"</span>
  httpNoBody resetReq mgr
  mapM_ <span class="org-rainbow-delimiters-depth-1">(</span>runCall mgr<span class="org-rainbow-delimiters-depth-1">)</span> cs
  model <span class="org-haskell-operator">&lt;-</span> extractModel mgr
  return model
</pre>
</div>

<p>
The call to <code>POST /reset</code> resets the web service. I would have liked to simply
restart the service completely, but I failed in automating it. I think I'll have
to take a closer look at the implementation of <a href="http://hackage.haskell.org/package/scotty">scotty</a> to find a way.
</p>

<p>
Extracting the web service state and packaging it in a <code>Model</code> is a matter of
calling <code>GET /users</code> and then repeatedly calling <code>GET /users/:id</code> with each <code>id</code>
gotten from the first call
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">extractModel</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Manager</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Model</span>
<span class="org-haskell-definition">extractModel</span> mgr <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  req <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"http://localhost:3000/users"</span>
  resp <span class="org-haskell-operator">&lt;-</span> httpLbs req mgr
  <span class="org-haskell-keyword">let</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Just</span> ids<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> decode <span class="org-rainbow-delimiters-depth-1">(</span>responseBody resp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">]</span>
  users <span class="org-haskell-operator">&lt;-</span> forM ids <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span> id <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
    req <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show id
    resp <span class="org-haskell-operator">&lt;-</span> httpLbs req mgr
    <span class="org-haskell-keyword">let</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Just</span> <span class="org-rainbow-delimiters-depth-2">(</span>user<span class="org-haskell-constructor">:</span><span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> decode <span class="org-rainbow-delimiters-depth-1">(</span>responseBody resp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">User</span><span class="org-rainbow-delimiters-depth-1">]</span>
    return user
  return <span class="org-haskell-operator">$</span> foldl <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> map <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">User</span> id name<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">-&gt;</span> M.insert id name map<span class="org-rainbow-delimiters-depth-1">)</span> M.empty users
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf418a26" class="outline-2">
<h2 id="orgf418a26">Generating programs</h2>
<div class="outline-text-2" id="text-orgf418a26">
<p>
My approach to generating a program is based on the idea that given a certain
state there is only a limited number of possible calls that make sense. Given a
model <code>m</code> it makes sense to make one of the following calls:
</p>

<ul class="org-ul">
<li>add a new user</li>
<li>delete an existing user</li>
<li>end the program</li>
</ul>

<p>
Based on this writing <code>genProgram</code> is rather straight forward
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">genProgram</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Gen</span> <span class="org-haskell-type">Program</span>
<span class="org-haskell-definition">genProgram</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Prog</span> <span class="org-haskell-operator">&lt;$&gt;</span> go M.empty
  <span class="org-haskell-keyword">where</span>
    possibleAddUser <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> arbitrary<span class="org-rainbow-delimiters-depth-1">]</span>
    possibleDeleteUser m <span class="org-haskell-operator">=</span> map <span class="org-rainbow-delimiters-depth-1">(</span>return <span class="org-haskell-operator">.</span> <span class="org-haskell-constructor">DeleteUser</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.keys m<span class="org-rainbow-delimiters-depth-1">)</span>
    possibleEndProgram <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>return <span class="org-haskell-constructor">EndProgram</span><span class="org-rainbow-delimiters-depth-1">]</span>

    go m <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      <span class="org-haskell-keyword">let</span> possibles <span class="org-haskell-operator">=</span> possibleDeleteUser m <span class="org-haskell-operator">++</span> possibleAddUser m <span class="org-haskell-operator">++</span> possibleEndProgram m
      s <span class="org-haskell-operator">&lt;-</span> oneof possibles
      <span class="org-haskell-keyword">let</span> m' <span class="org-haskell-operator">=</span> simulateCall m s
      <span class="org-haskell-keyword">case</span> s <span class="org-haskell-keyword">of</span>
        <span class="org-haskell-constructor">EndProgram</span> <span class="org-haskell-operator">-&gt;</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span>
        <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>s<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;$&gt;</span> go m'
</pre>
</div>

<p>
Armed with that the <code>Arbitrary</code> instance for <code>Program</code> can be implemented as<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Arbitrary</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-keyword">where</span>
  arbitrary <span class="org-haskell-operator">=</span> genProgram
  shrink p <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge02a7fa" class="outline-2">
<h2 id="orge02a7fa">The property of an API</h2>
<div class="outline-text-2" id="text-orge02a7fa">
<p>
The steps in the <a href="#orgd2e8eeb">first section</a> can be used as a recipe for writing the property
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">prop_progCorrectness</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Property</span>
<span class="org-haskell-definition">prop_progCorrectness</span> program <span class="org-haskell-operator">=</span> monadicIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  <span class="org-haskell-keyword">let</span> simulatedModel <span class="org-haskell-operator">=</span> simulateProgram program
  runModel <span class="org-haskell-operator">&lt;-</span> run <span class="org-haskell-operator">$</span> runProgram program
  assert <span class="org-haskell-operator">$</span> simulatedModel <span class="org-haskell-operator">==</span> runModel
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd44c20f" class="outline-2">
<h2 id="orgd44c20f">What next?</h2>
<div class="outline-text-2" id="text-orgd44c20f">
<p>
There are some improvements that I'd like to make:
</p>

<ul class="org-ul">
<li>Make the generation of <code>Program</code> better in the sense that the programs become
longer. I think this is important as I start tackling larger APIs.</li>
<li>Write an implementation of <code>shrink</code> for <code>Program</code>. With longer programs it's
of course more important to actually implement <code>shrink</code>.</li>
</ul>

<p>
I'd love to hear if others are using <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> to test REST APIs in some way,
if anyone has suggestions for improvements, and of course ideas for how to
implement <code>shrink</code> in a nice way.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Yes, I completely skip the issue of shrinking programs at this point.
This is OK at this point though, because the generated =Programs=s do end up to
be very short indeed.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-flycheck.html">flycheck</a> </div>
<div class="post-date">15 Jun 2015</div><h1 class="post-title"><a href="https://magnus.therning.org/2015-06-15-000-using-quickcheck-to-test-c-apis.html">Using QuickCheck to test C APIs</a></h1>
<p>
Last year at ICFP I attended the <a href="http://cufp.org/2014/t12-john-hughes-introduction-to-testing-with-quickcheck.html">tutorial on QuickCheck</a> with John Hughes. We got
to use the Erlang implementation of QuickCheck to test a C API. Ever since I've
been planning to do the same thing using Haskell. I've put it off for the better
part of a year now, but then Francesco Mazzoli wrote about <a href="http://hackage.haskell.org/package/inline-c">inline-c</a> (<a href="https://www.fpcomplete.com/blog/2015/05/inline-c">Call C
functions from Haskell without bindings</a> and I found the motivation to actually
start writing some code.
</p>

<div id="outline-container-org755182d" class="outline-2">
<h2 id="org755182d">The general idea</h2>
<div class="outline-text-2" id="text-org755182d">
<p>
Many C APIs are rather stateful beasts so to test it I
</p>

<ol class="org-ol">
<li>generate a sequence of API calls (a program of sorts),</li>
<li>run the sequence against a model,</li>
<li>run the sequence against the real implementation, and</li>
<li>compare the model against the real state each step of the way.</li>
</ol>
</div>
</div>

<div id="outline-container-org5c47d51" class="outline-2">
<h2 id="org5c47d51">The C API</h2>
<div class="outline-text-2" id="text-org5c47d51">
<p>
To begin with I hacked up a simple implementation of a stack in C. The
"specification" is
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-doc">/**</span>
<span class="org-doc"> * Create a stack.</span>
<span class="org-doc"> */</span>
<span class="org-type">void</span> *<span class="org-function-name">create</span><span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-doc">/**</span>
<span class="org-doc"> * Push a value onto an existing stack.</span>
<span class="org-doc"> */</span>
<span class="org-type">void</span> <span class="org-function-name">push</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-doc">/**</span>
<span class="org-doc"> * Pop a value off an existing stack.</span>
<span class="org-doc"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pop</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Using <code>inline-c</code> to create bindings for it is amazingly simple:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">CApi</span>
    <span class="org-haskell-keyword">where</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Language.C.Inline</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">C</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Foreign.Ptr</span>

C<span class="org-haskell-definition">.</span>include <span class="org-string">"stack.h"</span>

<span class="org-haskell-definition">create</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Ptr</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">create</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>C.exp<span class="org-haskell-quasi-quote">| void * { create() } |</span><span class="org-rainbow-delimiters-depth-1">]</span>

<span class="org-haskell-definition">push</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Ptr</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">C.CInt</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">push</span> s i <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>C.exp<span class="org-haskell-quasi-quote">| void { push($(void *s), $(int i)) } |</span><span class="org-rainbow-delimiters-depth-1">]</span>

<span class="org-haskell-definition">pop</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Ptr</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">C.CInt</span>
<span class="org-haskell-definition">pop</span> s <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>C.exp<span class="org-haskell-quasi-quote">| int { pop($(void *s)) } |</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
In the code below I import this module qualified.
</p>
</div>
</div>

<div id="outline-container-org7f43b7c" class="outline-2">
<h2 id="org7f43b7c">Representing a program</h2>
<div class="outline-text-2" id="text-org7f43b7c">
<p>
To represent a sequence of calls I first used a custom type, but later realised
that there really was no reason at all to not use a wrapped list:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">Program</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">P</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Foldable</span>, <span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Traversable</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Then each of the C API functions can be represented with
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Create</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Push</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Pop</span>
    <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org63a6359" class="outline-2">
<h2 id="org63a6359"><code>Arbitrary</code> for <code>Statement</code></h2>
<div class="outline-text-2" id="text-org63a6359">
<p>
My implementation of <code>Arbitrary</code> for <code>Statement</code> is very simple:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Arbitrary</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-keyword">where</span>
    arbitrary <span class="org-haskell-operator">=</span> oneof <span class="org-rainbow-delimiters-depth-1">[</span>return <span class="org-haskell-constructor">Create</span>, return <span class="org-haskell-constructor">Pop</span>, liftM <span class="org-haskell-constructor">Push</span> arbitrary<span class="org-rainbow-delimiters-depth-1">]</span>
    shrink <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Push</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Push</span> <span class="org-haskell-operator">&lt;$&gt;</span> shrink i
    shrink <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span>
</pre>
</div>

<p>
That is, <code>arbitrary</code> just returns one of the constructors of <code>Statement</code>, and
shrinking only returns anything for the one constructor that takes an argument,
<code>Push</code>.
</p>
</div>
</div>

<div id="outline-container-org2a84010" class="outline-2">
<h2 id="org2a84010">Prerequisites of <code>Arbitrary</code> for <code>Program Statement</code></h2>
<div class="outline-text-2" id="text-org2a84010">
<p>
I want to ensure that all <code>Program Statement</code> are valid, which means I need to
define the model for running the program and functions for checking the
precondition of a statement as well as for updating the model (i.e. for running
the <code>Statement</code>).
</p>

<p>
Based on the <a href="#org5c47d51">C API</a> above it seems necessary to track creation, the contents of
the stack, and even if it isn't explicitly mentioned it's probably a good idea
to track the popped value. Using <a href="http://hackage.haskell.org/package/record"><code>record</code></a> (<code>Record</code> is imported as <code>R</code>, and
<code>Record.Lens</code> as <code>RL</code>) I defined it like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">ModelContext</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>R.r<span class="org-haskell-quasi-quote">| { created :: Bool, pop :: Maybe Int, stack :: [Int] } |</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
Based on the rather informal specification I coded the pre-conditions for the
three statements as
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">preCond</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ModelContext</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Bool</span>
<span class="org-haskell-definition">preCond</span> ctx <span class="org-haskell-constructor">Create</span> <span class="org-haskell-operator">=</span> not <span class="org-haskell-operator">$</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| created |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
<span class="org-haskell-definition">preCond</span> ctx <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Push</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| created |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
<span class="org-haskell-definition">preCond</span> ctx <span class="org-haskell-constructor">Pop</span> <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| created |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
</pre>
</div>

<p>
That is
</p>

<ul class="org-ul">
<li><code>Create</code> requires that the stack hasn't been created already.</li>
<li><code>Push i</code> requires that the stack has been created.</li>
<li><code>Pop</code> also requires that the stack has been created.</li>
</ul>

<p>
Furthermore the "specification" suggests the following definition of a function
for running a statement:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">modelRunStatement</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ModelContext</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ModelContext</span>
<span class="org-haskell-definition">modelRunStatement</span> ctx <span class="org-haskell-constructor">Create</span> <span class="org-haskell-operator">=</span> RL.set <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| created |</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-constructor">True</span> ctx
<span class="org-haskell-definition">modelRunStatement</span> ctx <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Push</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> RL.over <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| stack |</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">(</span>i <span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">)</span> ctx
<span class="org-haskell-definition">modelRunStatement</span> ctx <span class="org-haskell-constructor">Pop</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>R.r<span class="org-haskell-quasi-quote">| { created = c, pop = headMay s, stack = tail s } |</span><span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-haskell-keyword">where</span>
        c <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| created |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
        s <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| stack |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
</pre>
</div>

<p>
(This definition assumes that the model satisfies the pre-conditions, as can be
seen in the use of <code>tail</code>.)
</p>
</div>
</div>

<div id="outline-container-org9eab783" class="outline-2">
<h2 id="org9eab783"><code>Arbitrary</code> for <code>Program Statement</code></h2>
<div class="outline-text-2" id="text-org9eab783">
<p>
With this in place I can define <code>Arbitrary</code> for <code>Program Statement</code> as
follows.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Arbitrary</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Program</span> <span class="org-haskell-type">Statement</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
    arbitrary <span class="org-haskell-operator">=</span> liftM <span class="org-haskell-constructor">P</span> <span class="org-haskell-operator">$</span> ar baseModelCtx
        <span class="org-haskell-keyword">where</span>
            ar m <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
                push <span class="org-haskell-operator">&lt;-</span> liftM <span class="org-haskell-constructor">Push</span> arbitrary
                <span class="org-haskell-keyword">let</span> possible <span class="org-haskell-operator">=</span> filter <span class="org-rainbow-delimiters-depth-1">(</span>preCond m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-constructor">Create</span>, <span class="org-haskell-constructor">Pop</span>, push<span class="org-rainbow-delimiters-depth-1">]</span>
                <span class="org-haskell-keyword">if</span> null possible
                    <span class="org-haskell-keyword">then</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span>
                    <span class="org-haskell-keyword">else</span> <span class="org-haskell-keyword">do</span>
                        s <span class="org-haskell-operator">&lt;-</span> oneof <span class="org-rainbow-delimiters-depth-1">(</span>map return possible<span class="org-rainbow-delimiters-depth-1">)</span>
                        <span class="org-haskell-keyword">let</span> m' <span class="org-haskell-operator">=</span> modelRunStatement m s
                        frequency <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">499</span>, liftM2 <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">(</span>return s<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">(</span>ar m'<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">1</span>, return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-3">[]</span></span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
The idea is to, in each step, choose a valid statement given the provided model
and cons it with the result of a recursive call with an updated model. The
constant 499 is just an arbitrary one I chose after running <code>arbitrary</code> a few
times to see how long the generated programs were.
</p>

<p>
For shrinking I take advantage of the already existing implementation for lists:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">shrink</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">P</span> p<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> filter allowed <span class="org-haskell-operator">$</span> map <span class="org-haskell-constructor">P</span> <span class="org-rainbow-delimiters-depth-1">(</span>shrink p<span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-haskell-keyword">where</span>
        allowed <span class="org-haskell-operator">=</span> and <span class="org-haskell-operator">.</span> snd <span class="org-haskell-operator">.</span> mapAccumL go baseModelCtx
            <span class="org-haskell-keyword">where</span>
                go ctx s <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>modelRunStatement ctx s, preCond ctx s<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org637962f" class="outline-2">
<h2 id="org637962f">Some thoughts so far</h2>
<div class="outline-text-2" id="text-org637962f">
<p>
I would love making an implementation of <code>Arbitrary s</code>, where <code>s</code> is something
that implements a type class that contains <code>preCond</code>, <code>modelRunStatement</code> and
anything else needed. I made an attempt using something like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">S</span> a <span class="org-haskell-keyword">where</span>
    <span class="org-haskell-keyword">type</span> <span class="org-haskell-type">Ctx</span> a <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span>

    baseCtx <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Ctx</span> a
    preCond <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Ctx</span> a <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Bool</span>
    <span class="org-haskell-operator">...</span>
</pre>
</div>

<p>
However, when trying to use <code>baseCtx</code> in an implementation of <code>arbitrary</code> I ran
into the issue of injectivity. I'm still not entirely sure what that means, or
if there is something I can do to work around it. Hopefully someone reading this
can offer a solution.
</p>
</div>
</div>

<div id="outline-container-orga64057c" class="outline-2">
<h2 id="orga64057c">Running the C code</h2>
<div class="outline-text-2" id="text-orga64057c">
<p>
When running the sequence of <code>Statement</code> against the C code I catch the results
in
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">RealContext</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>r<span class="org-haskell-quasi-quote">| { o :: Ptr (), pop :: Maybe Int } |</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
Actually running a statement and capturing the output in a <code>RealContext</code> is
easily done using <code>inline-c</code> and <code>record</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">realRunStatement</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">RealContext</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">RealContext</span>
<span class="org-haskell-definition">realRunStatement</span> ctx <span class="org-haskell-constructor">Create</span> <span class="org-haskell-operator">=</span> CApi.create <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span> ptr <span class="org-haskell-operator">-&gt;</span> return <span class="org-haskell-operator">$</span> RL.set <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| o |</span><span class="org-rainbow-delimiters-depth-1">]</span> ptr ctx
<span class="org-haskell-definition">realRunStatement</span> ctx <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Push</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> CApi.push o <span class="org-rainbow-delimiters-depth-1">(</span>toEnum i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;</span> return ctx
    <span class="org-haskell-keyword">where</span>
        o <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| o |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
<span class="org-haskell-definition">realRunStatement</span> ctx <span class="org-haskell-constructor">Pop</span> <span class="org-haskell-operator">=</span> CApi.pop o <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span> v <span class="org-haskell-operator">-&gt;</span> return <span class="org-haskell-operator">$</span> RL.set <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| pop |</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Just</span> <span class="org-rainbow-delimiters-depth-2">(</span>fromEnum v<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> ctx
    <span class="org-haskell-keyword">where</span>
        o <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| o |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
</pre>
</div>
</div>
</div>

<div id="outline-container-org8c5786b" class="outline-2">
<h2 id="org8c5786b">Comparing states</h2>
<div class="outline-text-2" id="text-org8c5786b">
<p>
Comparing a <code>ModelContext</code> and a <code>RealContext</code> is easily done:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">compCtx</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ModelContext</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">RealContext</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Bool</span>
<span class="org-haskell-definition">compCtx</span> mc rc <span class="org-haskell-operator">=</span> mcC <span class="org-haskell-operator">==</span> rcC <span class="org-haskell-operator">&amp;&amp;</span> mcP <span class="org-haskell-operator">==</span> rcP
    <span class="org-haskell-keyword">where</span>
        mcC <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| created |</span><span class="org-rainbow-delimiters-depth-1">]</span> mc
        rcC <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| o |</span><span class="org-rainbow-delimiters-depth-1">]</span> rc <span class="org-haskell-operator">/=</span> nullPtr
        mcP <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| pop|</span><span class="org-rainbow-delimiters-depth-1">]</span> mc
        rcP <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| pop|</span><span class="org-rainbow-delimiters-depth-1">]</span> rc
</pre>
</div>
</div>
</div>

<div id="outline-container-org12af561" class="outline-2">
<h2 id="org12af561">Verifying a <code>Program Statement</code></h2>
<div class="outline-text-2" id="text-org12af561">
<p>
With all that in place I can finally write a function for checking the validity
of a program:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">validProgram</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Bool</span>
<span class="org-haskell-definition">validProgram</span> p <span class="org-haskell-operator">=</span> and <span class="org-haskell-operator">&lt;$&gt;</span> snd <span class="org-haskell-operator">&lt;$&gt;</span> mapAccumM go <span class="org-rainbow-delimiters-depth-1">(</span>baseModelCtx, baseRealContext<span class="org-rainbow-delimiters-depth-1">)</span> p
    <span class="org-haskell-keyword">where</span>
        runSingleStatement mc rc s <span class="org-haskell-operator">=</span> realRunStatement rc s <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span> rc' <span class="org-haskell-operator">-&gt;</span> return <span class="org-rainbow-delimiters-depth-1">(</span>modelRunStatement mc s, rc'<span class="org-rainbow-delimiters-depth-1">)</span>

        go <span class="org-rainbow-delimiters-depth-1">(</span>mc, rc<span class="org-rainbow-delimiters-depth-1">)</span> s <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
            ctxs<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span>mc', rc'<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> runSingleStatement mc rc s
            return <span class="org-rainbow-delimiters-depth-1">(</span>ctxs, compCtx mc' rc'<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
(This uses <code>mapAccumM</code> from an <a href="2015-06-09-000-mapaccum-in-monad.html">earlier post of mine</a>.)
</p>
</div>
</div>

<div id="outline-container-org813eb63" class="outline-2">
<h2 id="org813eb63">The property, finally!</h2>
<div class="outline-text-2" id="text-org813eb63">
<p>
To wrap this all up I then define the property
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">prop_program</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Property</span>
<span class="org-haskell-definition">prop_program</span> p <span class="org-haskell-operator">=</span> monadicIO <span class="org-haskell-operator">$</span> run <span class="org-rainbow-delimiters-depth-1">(</span>validProgram p<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;=</span> assert
</pre>
</div>

<p>
and a main function
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> quickCheck prop_program
</pre>
</div>

<hr>

<p>
<i>Edit 2015-07-17</i>: Adjusted the description of the pre-conditions to match the
code.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-quickcheck.html">quickcheck</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>
<div class="post-date">09 Jun 2015</div><h1 class="post-title"><a href="https://magnus.therning.org/2015-06-09-000-mapaccum-in-monad.html">mapAccum in monad</a></h1>
<p>
I recently had two functions of very similar shape, only difference was that one
was pure and the other need some I/O. The former was easily written using
<code>mapAccumL</code>. I failed to find a function like <code>mapAccumL</code> that runs in a monad,
so I wrote up the following:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mapAccumM</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Monad</span> m, <span class="org-haskell-type">Traversable</span> t<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>a <span class="org-haskell-operator">-&gt;</span> b <span class="org-haskell-operator">-&gt;</span> m <span class="org-rainbow-delimiters-depth-2">(</span>a, c<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> t b <span class="org-haskell-operator">-&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span>a, t c<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">mapAccumM</span> f a l <span class="org-haskell-operator">=</span> swap <span class="org-haskell-operator">&lt;$&gt;</span> runStateT <span class="org-rainbow-delimiters-depth-1">(</span>mapM go l<span class="org-rainbow-delimiters-depth-1">)</span> a
    <span class="org-haskell-keyword">where</span>
        go i <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
            s <span class="org-haskell-operator">&lt;-</span> get
            <span class="org-rainbow-delimiters-depth-1">(</span>s', r<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> lift <span class="org-haskell-operator">$</span> f s i
            put s'
            return r
</pre>
</div>

<p>
Bring on the comments/suggestions/improvements/etc!
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div><div id="archive">
<a href="https://magnus.therning.org/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><!-- org-static-blog-page-postamble --></div>
</body>
</html>
