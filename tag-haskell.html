<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://magnus.therning.org/feed.xml"
      title="RSS feed for https://magnus.therning.org/">
<title>Magnus web site</title>
<meta name="author" content="Magnus Therning"><meta name="referrer" content="no-referrer"><link href= "static/style.css" rel="stylesheet" type="text/css" /><link href= "static/htmlize.css" rel="stylesheet" type="text/css" /><link href= "static/extra_style.css" rel="stylesheet" type="text/css" /></head>
<body>
<div id="preamble" class="status"><div class="nav-bar"><a class="nav-link" href="./index.html">Top</a><a class="nav-link" href="./archive.html">Archive</a><a class="nav-link align-right" href="./feed.xml"><img src="static/rss-feed-icon.png" style="height: 24px;" /></a></div></div>
<div id="content">
<h1 class="title">Posts tagged "haskell":</h1>
<div class="post-date">04 Jan 2026</div><h1 class="post-title"><a href="https://magnus.therning.org/2026-01-04-validation-of-data-in-a-servant-server.html">Validation of data in a servant server</a></h1>
<p>
I've been playing around with adding more validation of data received by an HTTP
endpoint in a <a href="https://hackage.haskell.org/package/servant">servant</a> server. Defining a type with a <code>FromJSON</code> instance is very
easy, just derive a <code>Generic</code> instance and it just works. Here's a simple
example
</p>

<div class="org-src-container">
<pre class="src src-haskell"><code><span class="org-keyword">data</span> Person = Person
    { name :: <span class="org-type">Text</span>
    , age :: <span class="org-type">Int</span>
    , occupation :: <span class="org-type">Occupation</span>
    }
    <span class="org-keyword">deriving</span> (Generic, Show)
    <span class="org-keyword">deriving</span> (FromJSON, ToJSON) via <span class="org-type">(Generically Person)</span>

<span class="org-keyword">data</span> Occupation = UnderAge | Student | Unemployed | SelfEmployed | Retired | Occupation <span class="org-type">Text</span>
    <span class="org-keyword">deriving</span> (Eq, Generic, Ord, Show)
    <span class="org-keyword">deriving</span> (FromJSON, ToJSON) via <span class="org-type">(Generically Occupation)</span>
</code></pre>
</div>

<p>
However, the validation is rather limited, basically it's just checking that
each field is present and of the correct type. For the type above I'd like to
enforce some constraints for the combination of <code>age</code> and <code>occupation</code>.
</p>

<p>
The steps I thought of are
</p>

<ol class="org-ol">
<li>Hide the default constructor and define a <a href="https://wiki.haskell.org/Smart_constructors">smart</a> one. (This is the standard
suggestion for placing extra constraints values.)</li>
<li>Manually define the <code>FromJSON</code> instance using the <code>Generic</code> instance to limit
the amount of code and the smart constructor.</li>
</ol>
<div id="outline-container-org0245825" class="outline-2">
<h2 id="org0245825">The smart constructor</h2>
<div class="outline-text-2" id="text-org0245825">
<p>
I give the constructor the result type <code>Either String Person</code> to make sure it
can both be usable in code and when defining <code>parseJSON</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><code><span class="org-function-name">mkPerson</span> :: <span class="org-type">Text</span> <span class="org-operator">-&gt;</span> <span class="org-type">Int</span> <span class="org-operator">-&gt;</span> <span class="org-type">Occupation</span> <span class="org-operator">-&gt;</span> <span class="org-type">Either String Person</span>
<span class="org-function-name">mkPerson</span> name age occupation = <span class="org-keyword">do</span>
    guardE mustBeUnderAge
    guardE notUnderAge
    guardE tooOldToBeStudent
    guardE mustBeRetired
    pure <span class="org-operator">$</span> Person name age occupation
  <span class="org-keyword">where</span>
    <span class="org-function-name">guardE</span> (pred, err) = when pred <span class="org-operator">$</span> Left err
    <span class="org-function-name">mustBeUnderAge</span> = (age <span class="org-operator">&lt;</span> <span class="org-number">8</span> <span class="org-operator">&amp;&amp;</span> occupation <span class="org-operator">&gt;</span> UnderAge, <span class="org-string">"too young for occupation"</span>)
    <span class="org-function-name">notUnderAge</span> = (age <span class="org-operator">&gt;</span> <span class="org-number">15</span> <span class="org-operator">&amp;&amp;</span> occupation <span class="org-operator">==</span> UnderAge, <span class="org-string">"too old to be under age"</span>)
    <span class="org-function-name">tooOldToBeStudent</span> = (age <span class="org-operator">&gt;</span> <span class="org-number">45</span> <span class="org-operator">&amp;&amp;</span> occupation <span class="org-operator">==</span> Student, <span class="org-string">"too old to be a student"</span>)
    <span class="org-function-name">mustBeRetired</span> = (age <span class="org-operator">&gt;</span> <span class="org-number">65</span> <span class="org-operator">&amp;&amp;</span> occupation <span class="org-operator">/=</span> Retired, <span class="org-string">"too old to not be retired"</span>)
</code></pre>
</div>

<p>
Here I'm making use of <code>Either e</code> being a <code>Monad</code> and use <code>when</code> to apply the
constraints and ensure the reason for failure is given to the caller.
</p>
</div>
</div>
<div id="outline-container-org9e3cd39" class="outline-2">
<h2 id="org9e3cd39">The <code>FromJSON</code> instance</h2>
<div class="outline-text-2" id="text-org9e3cd39">
<p>
When defining the instance I take advantage of the <code>Generic</code> instance to make
the implementation short and simple.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><code><span class="org-keyword">instance</span> FromJSON <span class="org-type">Person</span> <span class="org-keyword">where</span>
    <span class="org-function-name">parseJSON</span> v = <span class="org-keyword">do</span>
        Person{name, age, occupation} &lt;- genericParseJSON defaultOptions v
        either fail pure <span class="org-operator">$</span> mkPerson name age occupation
</code></pre>
</div>

<p>
If there are many more fields in the type I'd consider using <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/record_wildcards.html"><code>RecordWildCards</code></a>.
</p>
</div>
</div>
<div id="outline-container-orgd2a5ae0" class="outline-2">
<h2 id="orgd2a5ae0">Conclusion</h2>
<div class="outline-text-2" id="text-orgd2a5ae0">
<p>
No, it's nothing ground-breaking but I think it's a fairly nice example of how
things can fit together in Haskell.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-servant.html">servant</a> </div>

<div class="post-date">28 Jun 2025</div><h1 class="post-title"><a href="https://magnus.therning.org/2025-06-28-reading-redis-responses.html">Reading Redis responses</a></h1>
<p>
When I began experimenting with writing a new Redis client package I decided to
use lazy bytestrings, because:
</p>

<ol class="org-ol">
<li><a href="https://hackage.haskell.org/package/aeson">aeson</a> seems to prefer it &#x2013; the <a href="https://hackage.haskell.org/package/aeson-2.2.3.0/docs/Data-Aeson.html#g:10">main encoding and decoding functions</a> use lazy
byte strings, though there are <a href="https://hackage.haskell.org/package/aeson-2.2.3.0/docs/Data-Aeson.html#g:11">strict variants</a> too.</li>
<li>the <code>Builder</code> type in <a href="https://hackage-content.haskell.org/package/bytestring">bytestring</a> produce lazy bytestrings.</li>
</ol>

<p>
At the time I was happy to see that <a href="https://hackage.haskell.org/package/attoparsec">attoparsec</a> seemed to support strict and lazy
bytestrings equally well.
</p>

<p>
To get on with things I also wrote the simplest function I could come up with
for sending and receiving data over the network &#x2013; I used <code>send</code> and <code>recv</code> from
<a href="https://hackage.haskell.org/package/network-3.2.7.0/docs/Network-Socket-ByteString-Lazy.html">Network.Socket.ByteString.Lazy</a> in <a href="https://hackage.haskell.org/package/network-3.2.7.0">network</a>. The function was really simple
</p>

<div class="org-src-container">
<pre class="src src-haskell"><code><span class="org-keyword">import</span> Network.Socket.ByteString.Lazy <span class="org-keyword">qualified</span> <span class="org-keyword">as</span> SB

<span class="org-function-name">sendCmd</span> :: <span class="org-type">Conn</span> <span class="org-operator">-&gt;</span> <span class="org-type">Command r</span> <span class="org-operator">-&gt;</span> <span class="org-type">IO </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">Result r</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span>
<span class="org-function-name">sendCmd</span> <span class="org-rainbow-delimiters-depth-1">(</span>Conn p<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>Command k cmd<span class="org-rainbow-delimiters-depth-1">)</span> = withResource p <span class="org-operator">$</span> \sock <span class="org-operator">-&gt;</span> <span class="org-keyword">do</span>
    _ &lt;- <span class="org-warning">SB.</span>send sock <span class="org-operator">$</span> toWireCmd cmd
    resp &lt;- <span class="org-warning">SB.</span>recv sock <span class="org-number">4096</span>
    <span class="org-keyword">case</span> decode resp <span class="org-keyword">of</span>
        Left err <span class="org-operator">-&gt;</span> pure <span class="org-operator">$</span> Left <span class="org-operator">$</span> RespError <span class="org-string">"decode"</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">TL.</span>pack err<span class="org-rainbow-delimiters-depth-1">)</span>
        Right r <span class="org-operator">-&gt;</span> pure <span class="org-operator">$</span> k <span class="org-operator">&lt;$&gt;</span> fromWireResp cmd r
</code></pre>
</div>

<p>
with <code>decode</code> defined like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><code><span class="org-function-name">decode</span> :: <span class="org-type">ByteString</span> <span class="org-operator">-&gt;</span> <span class="org-type">Either String Resp</span>
<span class="org-function-name">decode</span> = parseOnly resp
</code></pre>
</div>

<p>
I knew I'd have to revisit this function, it was naïve to believe that a call to
<code>recv</code> would always result in as single complete response. It was however good
enough to get going. When I got to improving <code>sendCmd</code> I was a little surprised
to find that I'd also have to switch to using strict bytestrings in the parser.
</p>
<div id="outline-container-org94fd594" class="outline-2">
<h2 id="org94fd594">Interlude on the Redis serialisation protocol (RESP3)</h2>
<div class="outline-text-2" id="text-org94fd594">
<p>
The Redis protocol has some defining attributes
</p>

<ul class="org-ul">
<li>It's somewhat of a binary protocol. If you stick to keys and values that fall
within the set of ASCII strings, then the protocol is humanly readable and you
can rather easily use <code>netcat</code> or <code>telnet</code> as a client. However, you aren't
limited to storing only readable strings.</li>
<li>It's somewhat of a <a href="https://redis.io/docs/latest/develop/reference/protocol-spec/#request-response-model">request-response protocol</a>. A notable exception is the
<a href="https://redis.io/docs/latest/commands/?group=pubsub">publish-subscribe subset</a>, but it's rather small and I reckon most Redis users
don't use it.</li>
<li>It's somewhat of a type-length-value style protocol. Some of the data types
include their length in bytes, e.g. <span class="underline">bulk strings</span> and <span class="underline">verbatim strings</span>.
Other types include the number of elements, e.g. <span class="underline">arrays</span> and <span class="underline">maps</span>. A large
number of them have no length at all, e.g. <span class="underline">simple strings</span>, <span class="underline">integers</span>, and
<span class="underline">doubles</span>.</li>
</ul>

<p>
I suspect there are good reasons, I gather a lot of it has to do with speed. It
does however cause one issue when writing a client: <i>it's not possible to read a
whole response without parsing it</i>.
</p>
</div>
</div>
<div id="outline-container-orge572c4f" class="outline-2">
<h2 id="orge572c4f">Rewriting <code>sendCmd</code></h2>
<div class="outline-text-2" id="text-orge572c4f">
<p>
With that extra information about the RESP3 protocol the naïve implementation
above falls short in a few ways
</p>

<ul class="org-ul">
<li>The read buffer may contain more than one full message and give the definition
of <code>decode</code> above any remaining bytes are simply dropped.<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup></li>
<li>The read buffer my contain less than one full message and then <code>decode</code> will
return an error.<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup></li>
</ul>

<p>
Surely this must be solvable, because in my mind running the parser results in
one of three things:
</p>

<ol class="org-ol">
<li>Parsing is done and the result is returned, together with any input that
wasn't consumed.</li>
<li>The parsing is not done due to lack of input, this is typically encoded as a
continuation.</li>
<li>The parsing failed so the error is returned, together with input that wasn't
consumed.</li>
</ol>

<p>
So, I started looking in the documentation for the module
<a href="https://hackage.haskell.org/package/attoparsec-0.14.4/docs/Data-Attoparsec-ByteString-Lazy.html">Data.Attoparsec.ByteString.Lazy</a> in <a href="https://hackage.haskell.org/package/attoparsec">attoparsec</a>. I was a little surprised to find
that the <code>Result</code> type lacked a way to feed more input to a parser &#x2013; it only
has two constructors, <code>Done</code> and <code>Fail</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><code><span class="org-keyword">data</span> Result r
    = Fail <span class="org-type">ByteString</span> <span class="org-type"><span class="org-rainbow-delimiters-depth-1">[</span></span><span class="org-type">String</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">]</span></span> <span class="org-type">String</span>
    | Done <span class="org-type">ByteString</span> <span class="org-type">r</span>
</code></pre>
</div>

<p>
I'm guessing the idea is that the function producing the lazy bytestring in the
first place should be able to produce more chunks of data on demand. That's
likely what the lazy variant of <code>recv</code> does, but at the same time it also
requires choosing a maximum length and that doesn't rhyme with RESP3. The lazy
<code>recv</code> isn't quite lazy in the way I needed it to be.
</p>

<p>
When looking at the parser for strict bytestrings I calmed down. This parser
follows what I've learned about parsers (it's not defined <i>exactly</i> like this;
it's parameterised in its input but for the sake of simplicity I show it with
<code>ByteString</code> as input):
</p>

<div class="org-src-container">
<pre class="src src-haskell"><code><span class="org-keyword">data</span> Result r
    = Fail <span class="org-type">ByteString</span> <span class="org-type"><span class="org-rainbow-delimiters-depth-1">[</span></span><span class="org-type">String</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">]</span></span> <span class="org-type">String</span>
    | Partial <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">ByteString</span> <span class="org-operator">-&gt;</span> <span class="org-type">Result r</span><span class="org-rainbow-delimiters-depth-1">)</span>
    | Done <span class="org-type">ByteString</span> <span class="org-type">r</span>
</code></pre>
</div>

<p>
Then to my delight I found that there's already a function for handling exactly
my problem
</p>

<div class="org-src-container">
<pre class="src src-haskell"><code><span class="org-function-name">parseWith</span> :: Monad <span class="org-type">m</span> =&gt; <span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">m ByteString</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-operator">-&gt;</span> <span class="org-type">Parser a</span> <span class="org-operator">-&gt;</span> <span class="org-type">ByteString</span> <span class="org-operator">-&gt;</span> <span class="org-type">m </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">Result a</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</code></pre>
</div>

<p>
I only needed to rewrite the existing parser to work with strict bytestrings and
work out how to write a function using <code>recv</code> (for strict bytestrings) that
fulfils the requirements to be used as the first argument to <code>parseWith</code>. The
first part wasn't very difficult due to the similarity between <i>attoparsec</i>'s
APIs for lazy and strict bytestrings. The second only had one complication. It
turns out <code>recv</code> is blocking, but of course that doesn't work well with
<code>parseWith</code>. I wrapped it in <code>timeout</code> based on the idea that timing out means
there's no more data and the parser should be given an empty string so it
finishes. I also decided to pass the parser as an argument, so I could use the
same function for receiving responses for individual commands as well as for
pipelines. The full receiving function is
</p>

<div class="org-src-container">
<pre class="src src-haskell"><code><span class="org-keyword">import</span> Data.ByteString <span class="org-keyword">qualified</span> <span class="org-keyword">as</span> BS
<span class="org-keyword">import</span> Data.Text <span class="org-keyword">qualified</span> <span class="org-keyword">as</span> T
<span class="org-keyword">import</span> Network.Socket.ByteString <span class="org-keyword">qualified</span> <span class="org-keyword">as</span> SB

<span class="org-function-name">recvParse</span> :: <span class="org-type">S.Socket</span> <span class="org-operator">-&gt;</span> <span class="org-type">Parser r</span> <span class="org-operator">-&gt;</span> <span class="org-type">IO </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">Either Text </span><span class="org-type"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-type">BS.ByteString, r</span><span class="org-type"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span>
<span class="org-function-name">recvParse</span> sock parser = <span class="org-keyword">do</span>
    parseWith receive parser <span class="org-warning">BS.</span>empty <span class="org-operator">&gt;&gt;=</span> \<span class="org-keyword">case</span>
        Fail _ <span class="org-rainbow-delimiters-depth-1">[]</span> err <span class="org-operator">-&gt;</span> pure <span class="org-operator">$</span> Left <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">T.</span>pack err<span class="org-rainbow-delimiters-depth-1">)</span>
        Fail _ ctxs err <span class="org-operator">-&gt;</span> pure <span class="org-operator">$</span> Left <span class="org-operator">$</span> <span class="org-warning">T.</span>intercalate <span class="org-string">" &gt; "</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">T.</span>pack <span class="org-operator">&lt;$&gt;</span> ctxs<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;&gt;</span> <span class="org-string">": "</span> <span class="org-operator">&lt;&gt;</span> <span class="org-warning">T.</span>pack err
        Partial _ <span class="org-operator">-&gt;</span> pure <span class="org-operator">$</span> Left <span class="org-string">"impossible error"</span>
        Done rem result <span class="org-operator">-&gt;</span> pure <span class="org-operator">$</span> Right <span class="org-rainbow-delimiters-depth-1">(</span>rem, result<span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-keyword">where</span>
    <span class="org-function-name">receive</span> =
        timeout <span class="org-number">100_000</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">SB.</span>recv sock <span class="org-number">4096</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&gt;&gt;=</span> \<span class="org-keyword">case</span>
            Nothing <span class="org-operator">-&gt;</span> pure <span class="org-warning">BS.</span>empty
            Just bs <span class="org-operator">-&gt;</span> pure bs
</code></pre>
</div>

<p>
Then I only needed to rewrite <code>sendCmd</code> and I wanted to do it in such a way that
any remaining input data could be use in by the next call to <code>sendCmd</code>.<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> I
settled for modifying the <code>Conn</code> type to hold an <code>IORef ByteString</code> together
with the socket and then the function ended up looking like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><code><span class="org-function-name">sendCmd</span> :: <span class="org-type">Conn</span> <span class="org-operator">-&gt;</span> <span class="org-type">Command r</span> <span class="org-operator">-&gt;</span> <span class="org-type">IO </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">Result r</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span>
<span class="org-function-name">sendCmd</span> <span class="org-rainbow-delimiters-depth-1">(</span>Conn p<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>Command k cmd<span class="org-rainbow-delimiters-depth-1">)</span> = withResource p <span class="org-operator">$</span> \(sock, remRef<span class="org-rainbow-delimiters-unmatched">)</span> <span class="org-operator">-&gt;</span> <span class="org-keyword">do</span>
    _ &lt;- <span class="org-warning">SBL.</span>send sock <span class="org-operator">$</span> toWireCmd cmd
    rem &lt;- readIORef remRef
    recvParse sock rem resp <span class="org-operator">&gt;&gt;=</span> \<span class="org-keyword">case</span>
        Left err <span class="org-operator">-&gt;</span> pure <span class="org-operator">$</span> Left <span class="org-operator">$</span> RespError <span class="org-string">"recv/parse"</span> err
        Right <span class="org-rainbow-delimiters-unmatched">(</span>newRem, r<span class="org-rainbow-delimiters-unmatched">)</span> <span class="org-operator">-&gt;</span> <span class="org-keyword">do</span>
            writeIORef remRef newRem
            pure <span class="org-operator">$</span> k <span class="org-operator">&lt;$&gt;</span> fromWireResp cmd r
</code></pre>
</div>
</div>
</div>
<div id="outline-container-org83c453b" class="outline-2">
<h2 id="org83c453b">What's next?</h2>
<div class="outline-text-2" id="text-org83c453b">
<p>
I've started looking into pub/sub, and basically all of the work described in
this post is a prerequisite for that. It's not very difficult on the protocol
level, but I think it's difficult to come up with a design that allows maximal
flexibility. I'm not even sure it's worthwhile the complexity.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
This isn't that much of a problem when sticking to the request-response
commands, I think. It most certainly becomes a problem with pub/sub though.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I'm sure that whatever size of buffer I choose to use there'll be someone
out there who's storing values that are larger. Then there's pipelining that
makes it even more of an issue.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
To be honest I'm not totally convinced there'll ever be any remaining input.
Unless a single <code>Conn</code> is used by several threads &#x2013; which would lead to much
pain with the current implementation &#x2013; or pub/sub is used &#x2013; which isn't
supported yet.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-redis.html">redis</a> </div>

<div class="post-date">20 Jun 2025</div><h1 class="post-title"><a href="https://magnus.therning.org/2025-06-20-finding-a-type-for-redis-commands.html">Finding a type for Redis commands</a></h1>
<p>
Arriving at a type for Redis commands required a bit of exploration. I had some
ideas early on that I for various reasons ended up dropping on the way. This is
a post about my travels, hopefully someone finds it worthwhile reading.
</p>
<div id="outline-container-org9e7139e" class="outline-2">
<h2 id="org9e7139e">The protocol</h2>
<div class="outline-text-2" id="text-org9e7139e">
<p>
The <a href="https://redis.io/docs/latest/develop/reference/protocol-spec/">Redis Serialization Protocol</a> (RESP) initially reminded me of JSON and I
thought that following the pattern of <a href="https://hackage.haskell.org/package/aeson">aeson</a> might be a good idea. I decided
up-front that I'd only support the latest version of RESP, i.e. version 3. So, I
thought of a data type, <code>Resp</code> with a constructor for each RESP3 data type, and
a pair of type classes, <code>FromResp</code> and <code>ToResp</code> for converting between Haskell
types and RESP3. Then after some more reflection I realised that converting to
RESP is largely pointless. The main reason to convert anything <i>to</i> RESP3 is to
assemble a command, with its arguments, to send to Redis, but all commands are
<a href="https://redis.io/docs/latest/develop/reference/protocol-spec/#arrays">arrays</a> of <a href="https://redis.io/docs/latest/develop/reference/protocol-spec/#bulk-strings">bulk strings</a> so it's unlikely that anyone will actually use
<code>ToResp</code>.<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> So I scrapped the idea of <code>ToResp</code>. <code>FromResp</code> looked like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">class</span> FromResp a <span class="org-keyword">where</span>
    <span class="org-function-name">fromResp</span> :: <span class="org-type">Value</span> <span class="org-operator">-&gt;</span> <span class="org-type">Either FromRespError a</span>
</pre>
</div>

<p>
When I started defining commands I didn't like the number of <code>ByteString</code>
arguments that resulted in, so I defined a data type, <code>Arg</code>, and an accompanying
type class for arguments, <code>ToArg</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">newtype</span> Arg = Arg <span class="org-rainbow-delimiters-depth-1">{</span>unArg :: <span class="org-type"><span class="org-rainbow-delimiters-depth-2">[</span></span><span class="org-type">ByteString</span><span class="org-type"><span class="org-rainbow-delimiters-depth-2">]</span></span><span class="org-rainbow-delimiters-depth-1">}</span>
    <span class="org-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span>Show, Semigroup, Monoid<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-keyword">class</span> ToArg a <span class="org-keyword">where</span>
    <span class="org-function-name">toArg</span> :: <span class="org-type">a</span> <span class="org-operator">-&gt;</span> <span class="org-type">Arg</span>
</pre>
</div>

<p>
Later on I saw that it might also be nice to have a type class specifically for
keys, <code>ToKey</code>, though that's a wrapper for a single <code>ByteString</code>.
</p>

<p>
Implementing the functions to encode/decode the protocol were straight-forward
applications of <a href="https://hackage.haskell.org/package/attoparsec">attoparsec</a> and <a href="https://hackage.haskell.org/package/bytestring">bytestring</a> (using its <code>Builder</code>).
</p>
</div>
</div>
<div id="outline-container-org597492d" class="outline-2">
<h2 id="org597492d">A command is a function in need of a sender</h2>
<div class="outline-text-2" id="text-org597492d">
<p>
Even though supporting <a href="https://redis.io/docs/latest/develop/use/pipelining/">pipelining</a> was one of the goals I felt a need to make
sure I'd understood the protocol so I started off with single commands. The
protocol is a simple request/response protocol at the core so I settled on this
type for commands
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">type</span> Cmd a = forall m. <span class="org-rainbow-delimiters-depth-1">(</span>Monad <span class="org-type">m</span><span class="org-rainbow-delimiters-depth-1">)</span> =&gt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">ByteString</span> <span class="org-operator">-&gt;</span> <span class="org-type">m ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">-&gt;</span> <span class="org-type">m </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">Either FromRespError a</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>

<p>
that is, a command is a function accepting a <i>sender</i> and returning an <i>a</i>.
</p>

<p>
I wrote a helper function for defining commands, <code>sendCmd</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-function-name">sendCmd</span> :: <span class="org-rainbow-delimiters-depth-1">(</span>Monad <span class="org-type">m</span>, FromResp <span class="org-type">a</span><span class="org-rainbow-delimiters-depth-1">)</span> =&gt; <span class="org-type"><span class="org-rainbow-delimiters-depth-1">[</span></span><span class="org-type">ByteString</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">]</span></span> <span class="org-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">ByteString</span> <span class="org-operator">-&gt;</span> <span class="org-type">m ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">-&gt;</span> <span class="org-type">m </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">Either FromRespError a</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span>
<span class="org-function-name">sendCmd</span> cmdArgs send = <span class="org-keyword">do</span>
    <span class="org-keyword">let</span> <span class="org-function-name">cmd</span> = encode <span class="org-operator">$</span> Array <span class="org-operator">$</span> map BulkString cmdArgs
    send cmd <span class="org-operator">&lt;&amp;&gt;</span> decode <span class="org-operator">&gt;&gt;=</span> \<span class="org-keyword">case</span>
        Left desc <span class="org-operator">-&gt;</span> pure <span class="org-operator">$</span> Left <span class="org-operator">$</span> FromRespError <span class="org-string">"Decode"</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">Text.</span>pack desc<span class="org-rainbow-delimiters-depth-1">)</span>
        Right v <span class="org-operator">-&gt;</span> pure <span class="org-operator">$</span> fromValue v
</pre>
</div>

<p>
which made it easy to define commands. Here are two examples, <a href="https://redis.io/docs/latest/commands/append/">append</a> and <a href="https://redis.io/docs/latest/commands/mget/">mget</a>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-function-name">append</span> :: <span class="org-rainbow-delimiters-depth-1">(</span>ToArg <span class="org-type">a</span>, ToArg <span class="org-type">b</span><span class="org-rainbow-delimiters-depth-1">)</span> =&gt; <span class="org-type">a</span> <span class="org-operator">-&gt;</span> <span class="org-type">b</span> <span class="org-operator">-&gt;</span> <span class="org-type">Cmd Int</span>
<span class="org-function-name">append</span> key val = sendCmd <span class="org-operator">$</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"APPEND"</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-operator">&lt;&gt;</span> unArg <span class="org-rainbow-delimiters-depth-1">(</span>toArg key <span class="org-operator">&lt;&gt;</span> toArg val<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-doc">-- | https://redis.io/docs/latest/commands/mget/</span>
<span class="org-function-name">mget</span> :: <span class="org-rainbow-delimiters-depth-1">(</span>ToArg <span class="org-type">a</span>, FromResp <span class="org-type">b</span><span class="org-rainbow-delimiters-depth-1">)</span> =&gt; <span class="org-type">NE.NonEmpty a</span> <span class="org-operator">-&gt;</span> <span class="org-type">Cmd </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">NE.NonEmpty b</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span>
<span class="org-function-name">mget</span> ks = sendCmd <span class="org-operator">$</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"MGET"</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-operator">&lt;&gt;</span> unArg <span class="org-rainbow-delimiters-depth-1">(</span>foldMap1 toArg ks<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The function to send off a command and receive its response, <code>sendAndRecieve</code>,
was just a call to <code>send</code> followed by a call to <code>recv</code> in <a href="https://hackage.haskell.org/package/network">network</a> (the variants
for lazy bytestrings).
</p>

<p>
I sort of liked this representation &#x2013; there's always something pleasant with
finding a way to represent something as a function. There's a very big problem
with it though: it's difficult to implement pipelining!
</p>

<p>
Yes, <code>Cmd</code> is a functor since <code>(-&gt;) r</code> is a functor, and thus it's possible to
make it an <code>Applicative</code>, e.g. using <a href="https://hackage.haskell.org/package/free">free</a>. However, to implement pipelining it's
necessary to
</p>

<ol class="org-ol">
<li>encode all commands, then</li>
<li>concatenate them all into a single bytestring and send it</li>
<li>read the response, which is a concatenation of the individual commands'
responses, and</li>
<li>convert each separate response from RESP3.</li>
</ol>

<p>
That isn't easy when each command contains its own encoding and decoding. The
sender function would have to relinquish control after encoding the command, and
resume with the resume again later to decode it. I suspect it's doable using
continuations, or <a href="https://hackage.haskell.org/package/monad-coroutine">monad-coroutine</a>, but it felt complicated and rather than
travelling down that road I asked for ideas on the <a href="https://discourse.haskell.org/t/applicative-that-would-require-two-passes-to-run/12179">Haskell Discourse</a>. The
replies lead me to a paper, <a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/delivery.pdf">Free delivery</a>, and a bit later a package,
<a href="https://hackage.haskell.org/package/monad-batcher">monad-batcher</a>. When I got the pointer to the package I'd already read the paper
and started implementing the ideas in it, so I decided to save exploring
<i>monad-batcher</i> for later.
</p>
</div>
</div>
<div id="outline-container-org02d7470" class="outline-2">
<h2 id="org02d7470">A command for free delivery</h2>
<div class="outline-text-2" id="text-org02d7470">
<p>
The paper Free delivery is a perfect match for pipelining in Redis, and my
understanding is that it proposes a solution where
</p>

<ol class="org-ol">
<li>Commands are defined as a GADT, <code>Command a</code>.</li>
<li>Two functions are defined to serialise and deserialise a <code>Command a</code>. In the
paper they use <code>String</code> as the serialisation, so <code>show</code> and <code>read</code> is used.</li>
<li>A type, <code>ActionA a</code>, is defined that combines a command with a modification
of its <code>a</code> result. It implements <code>Functor</code>.</li>
<li>A free type, <code>FreeA f a</code> is defined, and made into an <code>Applicative</code> with the
constraint that <code>f</code> is a <code>Functor</code>.</li>
<li>A function, <code>serializeA</code>, is defined that traverses a <code>FreeA ActionA a</code>
serialising each command.</li>
<li>A function, <code>deserializeA</code>, is defined that traverses a <code>FreeA ActionA a</code>
deserialising the response for each command.</li>
</ol>

<p>
I defined a command type, <code>Command a</code>, with only three commands in it, <code>echo</code>,
<code>hello</code>, and <code>ping</code>. I then followed the recipe above to verify that I could get
it working at all. The Haskell used in the paper is showing its age, and there
seems to be a <code>Functor</code> instance missing, but it was still straight forward and
I could verify that it worked against a locally running Redis.
</p>

<p>
Then I made a few changes&#x2026;
</p>

<p>
I renamed the command type to <code>Cmd</code> so I could use <code>Command</code> for what the
paper calls <code>ActionA</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">data</span> Cmd r <span class="org-keyword">where</span>
    Echo :: <span class="org-type">Text</span> <span class="org-operator">-&gt;</span> <span class="org-type">Cmd Text</span>
    Hello :: <span class="org-type">Maybe Int</span> <span class="org-operator">-&gt;</span> <span class="org-type">Cmd </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    Ping :: <span class="org-type">Maybe Text</span> <span class="org-operator">-&gt;</span> <span class="org-type">Cmd Text</span>

<span class="org-keyword">data</span> Command a = forall r. Command !<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">r</span> <span class="org-operator">-&gt;</span> <span class="org-type">a</span><span class="org-rainbow-delimiters-depth-1">)</span> !<span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">Cmd r</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span>

<span class="org-keyword">instance</span> Functor <span class="org-type">Command</span> <span class="org-keyword">where</span>
    <span class="org-function-name">fmap</span> f <span class="org-rainbow-delimiters-depth-1">(</span>Command k c<span class="org-rainbow-delimiters-depth-1">)</span> = Command <span class="org-rainbow-delimiters-depth-1">(</span>f <span class="org-operator">.</span> k<span class="org-rainbow-delimiters-depth-1">)</span> c

<span class="org-function-name">toWireCmd</span> :: <span class="org-type">Cmd r</span> <span class="org-operator">-&gt;</span> <span class="org-type">ByteString</span>
<span class="org-function-name">toWireCmd</span> <span class="org-rainbow-delimiters-depth-1">(</span>Echo msg<span class="org-rainbow-delimiters-depth-1">)</span> = _
<span class="org-function-name">toWireCmd</span> <span class="org-rainbow-delimiters-depth-1">(</span>Hello ver<span class="org-rainbow-delimiters-depth-1">)</span> = _
<span class="org-function-name">toWireCmd</span> <span class="org-rainbow-delimiters-depth-1">(</span>Ping msg<span class="org-rainbow-delimiters-depth-1">)</span> = _

<span class="org-function-name">fromWireResp</span> :: <span class="org-type">Cmd r</span> <span class="org-operator">-&gt;</span> <span class="org-type">Resp</span> <span class="org-operator">-&gt;</span> <span class="org-type">Either RespError r</span>
<span class="org-function-name">fromWireResp</span> <span class="org-rainbow-delimiters-depth-1">(</span>Echo _<span class="org-rainbow-delimiters-depth-1">)</span> = fromResp
<span class="org-function-name">fromWireResp</span> <span class="org-rainbow-delimiters-depth-1">(</span>Hello _<span class="org-rainbow-delimiters-depth-1">)</span> = fromResp
<span class="org-function-name">fromWireResp</span> <span class="org-rainbow-delimiters-depth-1">(</span>Ping _<span class="org-rainbow-delimiters-depth-1">)</span> = fromResp
</pre>
</div>

<p>
(At this point I was still using <code>FromResp</code>.)
</p>

<p>
I also replaced the free applicative defined in the paper and started using
<a href="https://hackage.haskell.org/package/free">free</a>. A couple of type aliases make it a little easier to write nice signatures
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">type</span> Pipeline a = <span class="org-type">Ap Command a</span>

<span class="org-keyword">type</span> PipelineResult a = <span class="org-type">Validation </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">[</span></span><span class="org-type">RespError</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">]</span></span><span class="org-type"> a</span>
</pre>
</div>

<p>
and defining individual pipeline commands turned into something rather
mechanical. (I also swapped the order of the arguments to build a <code>Command</code> so I
can use point-free style here.)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-function-name">liftPipe</span> :: <span class="org-rainbow-delimiters-depth-1">(</span>FromResp <span class="org-type">r</span><span class="org-rainbow-delimiters-depth-1">)</span> =&gt; <span class="org-type">Cmd r</span> <span class="org-operator">-&gt;</span> <span class="org-type">Pipeline r</span>
<span class="org-function-name">liftPipe</span> = liftAp <span class="org-operator">.</span> Command id

<span class="org-function-name">echo</span> :: <span class="org-type">Text</span> <span class="org-operator">-&gt;</span> <span class="org-type">Pipeline Text</span>
<span class="org-function-name">echo</span> = liftPipe <span class="org-operator">.</span> Echo

<span class="org-function-name">hello</span> :: <span class="org-type">Maybe Int</span> <span class="org-operator">-&gt;</span> <span class="org-type">Pipeline </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-function-name">hello</span> = liftPipe <span class="org-operator">.</span> Hello

<span class="org-function-name">ping</span> :: <span class="org-type">Maybe Text</span> <span class="org-operator">-&gt;</span> <span class="org-type">Pipeline Text</span>
<span class="org-function-name">ping</span> = liftPipe <span class="org-operator">.</span> Ping
</pre>
</div>

<p>
One nice thing with switching to <i>free</i> was that serialisation became very simple
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-function-name">toWirePipeline</span> :: <span class="org-type">Pipeline a</span> <span class="org-operator">-&gt;</span> <span class="org-type">ByteString</span>
<span class="org-function-name">toWirePipeline</span> = runAp_ <span class="org-operator">$</span> \(Command _ c<span class="org-rainbow-delimiters-unmatched">)</span> <span class="org-operator">-&gt;</span> toWireCmd c
</pre>
</div>

<p>
On the other hand deserialisation became a little more involved, but it's not
too bad
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-function-name">fromWirePipelineResp</span> :: <span class="org-type">Pipeline a</span> <span class="org-operator">-&gt;</span> <span class="org-type"><span class="org-rainbow-delimiters-depth-1">[</span></span><span class="org-type">Resp</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">]</span></span> <span class="org-operator">-&gt;</span> <span class="org-type">PipelineResult a</span>
<span class="org-function-name">fromWirePipelineResp</span> <span class="org-rainbow-delimiters-depth-1">(</span>Pure a<span class="org-rainbow-delimiters-depth-1">)</span> _ = pure a
<span class="org-function-name">fromWirePipelineResp</span> <span class="org-rainbow-delimiters-depth-1">(</span>Ap <span class="org-rainbow-delimiters-depth-2">(</span>Command k c<span class="org-rainbow-delimiters-depth-2">)</span> p<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>r : rs<span class="org-rainbow-delimiters-depth-1">)</span> = fromWirePipelineResp p rs <span class="org-operator">&lt;*&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>k <span class="org-operator">&lt;$&gt;</span> liftError singleton <span class="org-rainbow-delimiters-depth-2">(</span>fromWireResp c r<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">fromWirePipelineResp</span> _ _ = Failure <span class="org-rainbow-delimiters-depth-1">[</span>RespError <span class="org-string">"fromWirePipelineResp"</span> <span class="org-string">"Unexpected wire result"</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
Everything was working nicely and I started adding support for more commands. I
used the small service from work to guide my choice of what commands to add.
First out was <a href="https://redis.io/docs/latest/commands/del/">del</a>, then <a href="https://redis.io/docs/latest/commands/get/">get</a> and <a href="https://redis.io/docs/latest/commands/set/">set</a>. After adding <a href="https://redis.io/docs/latest/commands/lpush/">lpush</a> I was pretty much ready
to try to replace <i>hedis</i> in the service from work.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">data</span> Cmd r <span class="org-keyword">where</span>
    <span class="org-comment">-- echo, hello, ping</span>
    Del :: <span class="org-rainbow-delimiters-depth-1">(</span>ToKey <span class="org-type">k</span><span class="org-rainbow-delimiters-depth-1">)</span> =&gt; <span class="org-type">NonEmpty k</span> <span class="org-operator">-&gt;</span> <span class="org-type">Cmd Int</span>
    Get :: <span class="org-rainbow-delimiters-depth-1">(</span>ToKey <span class="org-type">k</span>, FromResp <span class="org-type">r</span><span class="org-rainbow-delimiters-depth-1">)</span> =&gt; <span class="org-type">k</span> <span class="org-operator">-&gt;</span> <span class="org-type">Cmd r</span>
    Set :: <span class="org-rainbow-delimiters-depth-1">(</span>ToKey <span class="org-type">k</span>, ToArg <span class="org-type">v</span><span class="org-rainbow-delimiters-depth-1">)</span> =&gt; <span class="org-type">k</span> <span class="org-operator">-&gt;</span> <span class="org-type">v</span> <span class="org-operator">-&gt;</span> <span class="org-type">Cmd Bool</span>
    Lpush :: <span class="org-rainbow-delimiters-depth-1">(</span>ToKey <span class="org-type">k</span>, ToArg <span class="org-type">v</span><span class="org-rainbow-delimiters-depth-1">)</span> =&gt; <span class="org-type">k</span> <span class="org-operator">-&gt;</span> <span class="org-type">NonEmpty v</span> <span class="org-operator">-&gt;</span> <span class="org-type">Cmd Int</span>
</pre>
</div>

<p>
However, when looking at the above definition started I thinking.
</p>

<ul class="org-ul">
<li>Was it really a good idea to litter <code>Cmd</code> with constraints like that?</li>
<li>Would it make sense to keep the <code>Cmd</code> type a bit closer to the actual Redis
commands?</li>
<li>Also, maybe <code>FromResp</code> wasn't such a good idea after all, what if I remove it?</li>
</ul>

<p>
That brought me to the third version of the type for Redis commands.
</p>
</div>
</div>
<div id="outline-container-orgb20caeb" class="outline-2">
<h2 id="orgb20caeb">Converging and simplifying</h2>
<div class="outline-text-2" id="text-orgb20caeb">
<p>
While adding new commands and writing instances of <code>FromResp</code> I slowly realised
that my initial thinking of RESP3 as somewhat similar to JSON didn't really pan
out. I had quickly dropped <code>ToResp</code> and now the instances of <code>FromResp</code> didn't
sit right with me. They obviously had to "follow the commands", so to speak, but
at the same time allow users to bring their own types. For instance, <code>LSPUSH</code>
returns the number of pushed messages, but at the same time <code>GET</code> should be able
to return an <code>Int</code> too. This led to <code>Int</code>'s <code>FromResp</code> looking like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">instance</span> FromResp <span class="org-type">Int</span> <span class="org-keyword">where</span>
    <span class="org-function-name">fromResp</span> <span class="org-rainbow-delimiters-depth-1">(</span>BulkString bs<span class="org-rainbow-delimiters-depth-1">)</span> =
        <span class="org-keyword">case</span> parseOnly <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">AC8.</span>signed <span class="org-warning">AC8.</span>decimal<span class="org-rainbow-delimiters-depth-1">)</span> bs <span class="org-keyword">of</span>
            Left s <span class="org-operator">-&gt;</span> Left <span class="org-operator">$</span> RespError <span class="org-string">"FromResp"</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">TL.</span>pack s<span class="org-rainbow-delimiters-depth-1">)</span>
            Right n <span class="org-operator">-&gt;</span> Right n
    <span class="org-function-name">fromResp</span> <span class="org-rainbow-delimiters-depth-1">(</span>Number n<span class="org-rainbow-delimiters-depth-1">)</span> = Right <span class="org-operator">$</span> fromEnum n
    <span class="org-function-name">fromResp</span> _ = Left <span class="org-operator">$</span> RespError <span class="org-string">"FromResp"</span> <span class="org-string">"Unexpected value"</span>
</pre>
</div>

<p>
I could see this becoming worse, take the instance for <code>Bool</code>, I'd have to
consider that
</p>

<ul class="org-ul">
<li>for <code>MOVE</code> <code>Integer 1</code> means <code>True</code> and <code>Integer 0</code> means <code>False</code></li>
<li>for <code>SET</code> <code>SimpleString "OK"</code> means <code>True</code></li>
<li>users would justifiably expect a bunch of bytestrings to be <code>True</code>, e.g.
<code>BulkString "true"</code>, <code>BulkString "TRUE"</code>, <code>BulkString "1"</code>, etc</li>
</ul>

<p>
However, it's impossible to cover <i>all</i> ways users can encode a <code>Bool</code> in a
<code>ByteString</code> so no matter what I do users will end up having to wrap <i>their</i>
<code>Bool</code> with <code>newtype</code> and implement a fitting <code>FromResp</code>. On top of that, even
thought I haven't found any example of it yet, I fully expect there to be,
somewhere in the large set of Redis commands, at least two commands each wanting
an instance of a basic type that simply can't be combined into a single
instance, meaning that the client library would need to do some <code>newtype</code>
wrapping too.
</p>

<p>
No, I really didn't like it! So, could I get rid of <code>FromResp</code> and still offer
users an API where they can user their own types as the result of commands?
</p>

<p>
To be concrete I wanted this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">data</span> Cmd r <span class="org-keyword">where</span>
    <span class="org-comment">-- other commands</span>
    Get :: <span class="org-rainbow-delimiters-depth-1">(</span>ToKey <span class="org-type">k</span><span class="org-rainbow-delimiters-depth-1">)</span> =&gt; <span class="org-type">k</span> <span class="org-operator">-&gt;</span> <span class="org-type">Cmd </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">Maybe ByteString</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>

<p>
and I wanted the user to be able to conveniently turn a <code>Cmd r</code> into a <code>Cmd s</code>.
In other words, I wanted a <code>Functor</code> instance. Making <code>Cmd</code> itself a functor
isn't necessary and I just happened to already have a functor type that wraps
<code>Cmd</code>, the <code>Command</code> type I used for pipelining. If I were to use that I'd need
to write wrapper functions for each command though, but if I did that then I
could also remove the <code>ToKey~/~ToArg</code> constraints from the constructors of <code>Cmd
r</code> and put them on the wrapper instead. I'd get
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">data</span> Cmd r <span class="org-keyword">where</span>
    <span class="org-comment">-- other commands</span>
    Get :: <span class="org-type">Key</span> <span class="org-operator">-&gt;</span> <span class="org-type">Cmd </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">Maybe ByteString</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span>

<span class="org-function-name">get</span> :: <span class="org-rainbow-delimiters-depth-1">(</span>ToKey <span class="org-type">k</span><span class="org-rainbow-delimiters-depth-1">)</span> =&gt; <span class="org-type">k</span> <span class="org-operator">-&gt;</span> <span class="org-type">Command </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">Maybe ByteString</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span>
<span class="org-function-name">get</span> = Command id <span class="org-operator">.</span> Get <span class="org-operator">.</span> toKey
</pre>
</div>

<p>
I'd also have to rewrite <code>fromWireResp</code> so it's more specific for each command.
Instead of
</p>

<div class="org-src-container">
<pre class="src src-hskell">fromWireResp :: Cmd r -&gt; Resp -&gt; Either RespError r
fromWireResp (Get _) = fromResp
...
</pre>
</div>

<p>
I had to match up exactly on the possible replies to <code>GET</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-function-name">fromWireResp</span> :: <span class="org-type">Cmd r</span> <span class="org-operator">-&gt;</span> <span class="org-type">Resp</span> <span class="org-operator">-&gt;</span> <span class="org-type">Either RespError r</span>
<span class="org-function-name">fromWireResp</span> _ <span class="org-rainbow-delimiters-depth-1">(</span>SimpleError err desc<span class="org-rainbow-delimiters-depth-1">)</span> = Left <span class="org-operator">$</span> RespError <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">T.</span>decodeUtf8 err<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">T.</span>decodeUtf8 desc<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">fromWireResp</span> <span class="org-rainbow-delimiters-depth-1">(</span>Get _<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>BulkString bs<span class="org-rainbow-delimiters-depth-1">)</span> = Right <span class="org-operator">$</span> Just bs
<span class="org-function-name">fromWireResp</span> <span class="org-rainbow-delimiters-depth-1">(</span>Get _<span class="org-rainbow-delimiters-depth-1">)</span> Null = Right Nothing
...
<span class="org-function-name">fromWireResp</span> _ _ = Left <span class="org-operator">$</span> RespError <span class="org-string">"fromWireResp"</span> <span class="org-string">"Unexpected value"</span>
</pre>
</div>

<p>
Even though it was more code I liked it better than before, and I think it's
slightly simpler code. I also hope it makes the use of the API is a bit simpler
and clear.
</p>

<p>
Here's an example from the code for the service I wrote for work. It reads a UTC
timestamp stored in <code>timeKey</code>, the timestamp is a JSON string so it needs to be
decoded.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-function-name">readUTCTime</span> :: <span class="org-type">Connection</span> <span class="org-operator">-&gt;</span> <span class="org-type">IO </span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-type">Maybe UTCTime</span><span class="org-type"><span class="org-rainbow-delimiters-depth-1">)</span></span>
<span class="org-function-name">readUTCTime</span> conn =
    sendCmd conn <span class="org-rainbow-delimiters-depth-1">(</span>maybe Nothing decode <span class="org-operator">&lt;$&gt;</span> get timeKey<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&gt;&gt;=</span> \<span class="org-keyword">case</span>
        Left _ <span class="org-operator">-&gt;</span> pure Nothing
        Right datum <span class="org-operator">-&gt;</span> pure datum
</pre>
</div>
</div>
</div>
<div id="outline-container-org0a0824d" class="outline-2">
<h2 id="org0a0824d">What's next?</h2>
<div class="outline-text-2" id="text-org0a0824d">
<p>
I'm pretty happy with the command type for now, though I have a feeling I'll
have to revisit <code>Arg</code> and <code>ToArg</code> at some point.
</p>

<p>
I've just turned the <code>Connection</code> type into a pool using <a href="https://hackage.haskell.org/package/resource-pool">resource-pool</a>, and I
started looking at pub/sub. The latter thing, pub/sub, will require some thought
and experimentation I think. Quite possibly it'll end up in a post here too.
</p>

<p>
I also have <i>a lot</i> of commands to add.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Of course one could use RESP3 as the serialisation format for storing values
in Redis. Personally I think I'd prefer using something more widely used, and
easier to read, such as JSON or BSON.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-redis.html">redis</a> </div>

<div class="post-date">17 Jun 2025</div><h1 class="post-title"><a href="https://magnus.therning.org/2025-06-17-why-i'm-writing-a-redis-client-package.html">Why I'm writing a Redis client package</a></h1>
<p>
A couple of weeks ago I needed a small, hopefully temporary, service at work. It
bridges a gap in functionality provided by a legacy system and the functionality
desired by a new system. The legacy system is cumbersome to work with, so we
tend to prefer building anti-corruption layers rather than changing it directly,
and sometimes we implement it as separate services.
</p>

<p>
This time it was good enough to run the service as a cronjob, but it did need to
keep track of when it ran the last time. It felt silly to spin up a separate DB
just to keep a timestamp, and using another service's DB is something I <i>really</i>
dislike and avoid.<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> So, I ended up using the Redis instance that's used as a
cache by a OSS service we host.
</p>

<p>
The last time I had a look at the options for writing a Redis client in Haskell
I found two candidates, <a href="https://hackage.haskell.org/package/hedis">hedis</a> and <a href="https://hackage.haskell.org/package/redis-io">redis-io</a>. At the time I wrote a <a href="https://magnus.therning.org/2021-05-07-working-with-hedis.html">short note</a>
about them. This time around I found nothing much has changed, they are still
the only two contenders and they still suffer from the same issues
</p>

<ul class="org-ul">
<li><i>hedis</i> has still has the same API and I still find it as awkward.</li>
<li><i>redis-io</i> still requires a logger.</li>
</ul>

<p>
I once again decided to use <i>hedis</i> and wrote the service for work in a couple
of days, but this time I thought I'd see what it would take to remove the
requirement on <a href="https://hackage.haskell.org/package/tinylog">tinylog</a> from <i>redis-io</i>. I spent a few evenings on it, though I
spent most time on "modernising" the dev setup, using Nix to build, re-format
using <i>fourmolu</i>, etc. I did the same for <a href="https://hackage.haskell.org/package/redis-resp">redis-resp</a>, the main dependency of
<i>redis-io</i>. The result of that can be found on my gitlab account:
</p>

<ul class="org-ul">
<li><a href="https://gitlab.com/magus/redis-resp">https://gitlab.com/magus/redis-resp</a></li>
<li><a href="https://gitlab.com/magus/redis-io">https://gitlab.com/magus/redis-io</a></li>
</ul>

<p>
At the moment I won't take that particular experiment any further and given that
the most recent change to <i>redis-io</i> was in 2020 (according to its <a href="https://gitlab.com/twittner/redis-io/">git repo</a>)
I don't think there's much interest upstream either.
</p>

<p>
Making the changes to <i>redis-io</i> and <i>redis-resp</i> made me a little curious about
the <a href="https://redis.io/docs/latest/develop/reference/protocol-spec/">Redis protocol</a> so I started reading about it. It made me start thinking
about implementing a client lib myself. How hard could it be?
</p>

<p>
I'd also asked a question about Redis client libs on <a href="https://www.reddit.com/r/haskell/comments/1kk4a5v/redis_lib_for_haskell/">r/haskell</a> and a response
led me to <a href="https://hackage.haskell.org/package/redis-schema">redis-schema</a>. It has a very good README, and its section on
transactions with its observation that Redis transactions are a perfect match
for <code>Applicative</code>. This pushed me even closer to start writing a client lib.
What pushed me over the edge was the realisation that <a href="https://redis.io/docs/latest/develop/use/pipelining/">pipelining</a> also is a
perfect match for <code>Applicative</code>.
</p>

<p>
For the last few weeks I've spent some of my free time reading and experimenting
and I'm enjoying it very much. We'll see where it leads, but hopefully I'll at
least have bit more to write about it.
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
One definition of a microservice I find very useful is "a service that owns
its own DB schema."
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-redis.html">redis</a> </div>

<div class="post-date">16 Mar 2025</div><h1 class="post-title"><a href="https://magnus.therning.org/2025-03-16-using-lens-aeson-to-implement-fromjson.html">Using lens-aeson to implement FromJSON</a></h1>
<p>
At work I sometimes need to deal with large and deep JSON objects where I'm only
interested in a few of the values. If all the interesting values are on the top
level, then <a href="https://hackage.haskell.org/package/aeson">aeson</a> have functions that make it easy to implement <code>FromJSON</code>'s
<code>parseJSON</code> (<a href="https://hackage.haskell.org/package/aeson-2.2.3.0/docs/Data-Aeson.html#g:26">Constructors and accessors</a>), but if the values are spread out then
the functions in aeson come up a bit short. That's when I reach for <a href="https://hackage.haskell.org/package/lens-aeson">lens-aeson</a>,
as lenses make it very easy to work with large structures. However, I've found
that using its lenses to implement <code>parseJSON</code> become a lot easier with a few
helper functions.
</p>

<p>
Many of the lenses produces results wrapped in <code>Maybe</code>, so the first function is
one that transforms a <code>Maybe a</code> to a <code>Parser a</code>. Here I make use of <code>Parser</code>
implementing <code>MonadFail</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">infixl</span> <span class="org-number">8</span> <span class="org-operator">&lt;!&gt;</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-operator">&lt;!&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> :: <span class="org-rainbow-delimiters-depth-1">(</span>MonadFail <span class="org-type">m</span><span class="org-rainbow-delimiters-depth-1">)</span> =&gt; <span class="org-type">Maybe a</span> <span class="org-operator">-&gt;</span> <span class="org-type">String</span> <span class="org-operator">-&gt;</span> <span class="org-type">m a</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-operator">&lt;!&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> mv err = maybe <span class="org-rainbow-delimiters-depth-1">(</span>fail err<span class="org-rainbow-delimiters-depth-1">)</span> pure mv
</pre>
</div>

<p>
In some code I wrote this week I used it to extract the user name out of a JWT
produced by Keycloak:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">instance</span> FromJSON <span class="org-type">OurClaimsSet</span> <span class="org-keyword">where</span>
    parseJSON = ... $ \o <span class="org-operator">-&gt;</span> <span class="org-keyword">do</span>
        cs &lt;- parseJSON o
        n &lt;- o <span class="org-operator">^?</span> key <span class="org-string">"preferred_username"</span> <span class="org-operator">.</span> _String <span class="org-operator">&lt;!&gt;</span> <span class="org-string">"preferred username missing"</span>
        ...
        pure <span class="org-operator">$</span> OurClaimsSet cs n <span class="org-operator">...</span>
</pre>
</div>

<p>
Also, all the lenses start with a <code>Value</code> and that makes the <code>withX</code> functions
in aeson to not be a perfect fit. So I define variations of the <code>withX</code>
functions, e.g.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-function-name">withObjectV</span> :: <span class="org-type">String</span> <span class="org-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Value</span> <span class="org-operator">-&gt;</span> <span class="org-type">Parser a</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">-&gt;</span> <span class="org-type">Value</span> <span class="org-operator">-&gt;</span> <span class="org-type">Parser a</span>
<span class="org-function-name">withObjectV</span> s f = withObject s <span class="org-rainbow-delimiters-depth-1">(</span>f <span class="org-operator">.</span> Object<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That makes the full <code>FromJSON</code> instance for <code>OurClaimsSet</code> look like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">instance</span> FromJSON <span class="org-type">OurClaimsSet</span> <span class="org-keyword">where</span>
    <span class="org-function-name">parseJSON</span> = withObjectV <span class="org-string">"OurClaimsSet"</span> <span class="org-operator">$</span> \o <span class="org-operator">-&gt;</span> <span class="org-keyword">do</span>
        cs &lt;- parseJSON o
        n &lt;- o <span class="org-operator">^?</span> key <span class="org-string">"preferred_username"</span> <span class="org-operator">.</span> _String <span class="org-operator">&lt;!&gt;</span> <span class="org-string">"name"</span>
        <span class="org-keyword">let</span> <span class="org-function-name">rs</span> = o <span class="org-operator">^..</span> key <span class="org-string">"resource_access"</span> <span class="org-operator">.</span> members <span class="org-operator">.</span> key <span class="org-string">"roles"</span> <span class="org-operator">.</span> _Array <span class="org-operator">.</span> traverse <span class="org-operator">.</span> _String
        pure <span class="org-operator">$</span> OurClaimsSet cs n rs
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>

<div class="post-date">01 Dec 2024</div><h1 class="post-title"><a href="https://magnus.therning.org/2024-12-01-servant-and-a-weirdness-in-keycloak.html">Servant and a weirdness in Keycloak</a></h1>
<p>
When writing a small tool to interface with Keycloak I found an endpoint that
require the content type to be <code>application/json</code> while the body should be plain
text. (The details are in the <a href="https://github.com/keycloak/keycloak/issues/34401">issue</a>.) Since <a href="https://hackage.haskell.org/package/servant">servant</a> assumes that the content
type and the content match (I know, I'd always thought that was a safe
assumption to make too) it doesn't work with <code>ReqBody '[JSON] Text</code>. Instead I
had to create a custom type that's a combination of <a href="https://hackage.haskell.org/package/servant-0.20.2/docs/Servant-API-ContentTypes.html#t:JSON"><code>JSON</code></a> and <a href="https://hackage.haskell.org/package/servant-0.20.2/docs/Servant-API-ContentTypes.html#t:PlainText"><code>PlainText</code></a>,
something that turned out to required surprisingly little code:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">data</span> KeycloakJSON <span class="org-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span>Typeable<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-keyword">instance</span> Accept <span class="org-type">KeycloakJSON</span> <span class="org-keyword">where</span>
    <span class="org-function-name">contentType</span> _ = <span class="org-string">"application"</span> <span class="org-operator">//</span> <span class="org-string">"json"</span>

<span class="org-keyword">instance</span> MimeRender <span class="org-type">KeycloakJSON</span> <span class="org-type">Text</span> <span class="org-keyword">where</span>
    <span class="org-function-name">mimeRender</span> _ = fromStrict <span class="org-operator">.</span> encodeUtf8
</pre>
</div>

<p>
The bug has already been fixed in Keycloak, but I'm sure there are other APIs
with similar weirdness so maybe this will be useful to someone else.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-servant.html">servant</a> </div>

<div class="post-date">13 Jul 2024</div><h1 class="post-title"><a href="https://magnus.therning.org/2024-07-13-hoogle-setup-for-local-development.html">Hoogle setup for local development</a></h1>
<p>
About a week ago I asked a <a href="https://discourse.nixos.org/t/haskell-shell-setup-with-working-hoogle-developpackage/48507/2">question on the Nix Discourse</a> about how to create a
setup for Hoogle that
</p>

<ul class="org-ul">
<li>includes the locally installed packages, and</li>
<li>the package I'm working on, and ideally also</li>
<li>have all local links, i.e. no links to <a href="https://hackage.haskell.org/">Hackage</a>.</li>
</ul>

<p>
I didn't get an answer there, but some people on the Nix Haskell channel on
Matrix helped a bit, but it seems this particular use case requires a bit of
manual work. The following commands get me an almost fully working setup:
</p>

<div class="org-src-container">
<pre class="src src-shell">cabal haddock --haddock-internal --haddock-quickjump --haddock-hoogle --haddock-html

<span class="org-variable-name">hoogle_dir</span>=$<span class="org-rainbow-delimiters-depth-1">(</span>dirname $<span class="org-rainbow-delimiters-depth-2">(</span>dirname $<span class="org-rainbow-delimiters-depth-3">(</span>readlink -f $<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-builtin">which</span> hoogle<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
hoogle generate --database=local.hoo <span class="org-sh-escaped-newline">\</span>
       $<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">for</span> d<span class="org-keyword"> in</span> $<span class="org-rainbow-delimiters-depth-2">(</span>fd -L .txt $<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-variable-name">hoogle_dir</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-keyword">do</span> printf <span class="org-string">"--local=%s "</span> $<span class="org-rainbow-delimiters-depth-2">(</span>dirname $<span class="org-variable-name">d</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-keyword">done</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-sh-escaped-newline">\</span>
       --local=./dist-newstyle/build/x86_64-linux/ghc-9.8.2/pkg-0.0.1/doc/html/pkg

hoogle server --local --database=local.foo
</pre>
</div>

<p>
What's missing is working links between the documentation of locally installed
packages. It looks like the links in the generated documention in Nix have a lot
of relative references containing <code>${pkgroot}/../../../../</code> which is what I
supect causes the broken links.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>

<div class="post-date">19 May 2024</div><h1 class="post-title"><a href="https://magnus.therning.org/2024-05-19-nix,-cabal,-and-tests.html">Nix, cabal, and tests</a></h1>
<p>
At work I decided to attempt to change the setup of one of our projects from using
</p>

<ul class="org-ul">
<li><a href="https://github.com/input-output-hk/haskell.nix">haskell.nix</a></li>
<li><a href="https://docs.haskellstack.org/en/stable/">stack</a></li>
<li><a href="https://hackage.haskell.org/package/hpack">hpack</a></li>
</ul>

<p>
to the triplet I tend to prefer
</p>

<ul class="org-ul">
<li><code>developPackage</code> from <a href="https://github.com/NixOS/nixpkgs/">nixpkgs</a></li>
<li><a href="https://www.haskell.org/cabal/index.html">cabal</a> (the tool)</li>
<li><a href="https://cabal.readthedocs.io/en/stable/">cabal</a> (the spec)</li>
</ul>

<p>
During this I ran into two small issues relating to tests.
</p>
<div id="outline-container-org442482b" class="outline-2">
<h2 id="org442482b"><code>hspec-discover</code> both is, and isn't, available in the shell</h2>
<div class="outline-text-2" id="text-org442482b">
<p>
I found mentions of this mentioned in an open <a href="https://github.com/haskell/cabal/issues/8434">cabal ticket</a> and someone even made
a <a href="https://github.com/kenranunderscore/hspec-discover-repro">git repo</a> to explore it. I posted <a href="https://discourse.nixos.org/t/hspec-discover-not-available-in-shell/45563">a question</a> on the Nix discorse.
</p>

<p>
Basically, when running <code>cabal test</code> in a dev shell, started with <code>nix develop</code>,
the tool <code>hspec-discover</code> wasn't found. At the same time the packages was
installed
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-rainbow-delimiters-depth-1">(</span>ins<span class="org-rainbow-delimiters-depth-1">)</span>$ ghc-pkg list | rg hspec
    hspec-2.9.7
    hspec-core-2.9.7
    <span class="org-rainbow-delimiters-depth-1">(</span>hspec-discover-2.9.7<span class="org-rainbow-delimiters-depth-1">)</span>
    hspec-expectations-0.8.2
</pre>
</div>

<p>
and it was on the <code>$PATH</code>
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-rainbow-delimiters-depth-1">(</span>ins<span class="org-rainbow-delimiters-depth-1">)</span>$ whereis hspec-discover
hspec-discover: /nix/store/vaq3gvak92whk5l169r06xrbkx6c0lqp-ghc-9.2.8-with-packages/bin/hspec-discover /nix/store/986bnyyhmi042kg4v6d918hli32lh9dw-hspec-discover-2.9.7/bin/hspec-discover
</pre>
</div>

<p>
The solution, as the user <a href="https://discourse.nixos.org/u/julm">julm</a> pointed out, is to simply do what <code>cabal</code> tells
you and run <code>cabal update</code> first.
</p>
</div>
</div>
<div id="outline-container-org20e6fe8" class="outline-2">
<h2 id="org20e6fe8">Dealing with tests that won't run during build</h2>
<div class="outline-text-2" id="text-org20e6fe8">
<p>
The project's tests were set up in such a way that standalone tests and
integration tests are mixed into the same test executable. As the integration
tests need the just built service to be running they can't be run during <code>nix
build</code>. However, the only way of preventing that, without making code changes,
is to pass an argument to the test executable, <code>--skip=&lt;prefix&gt;</code>, and I believe
that's not possible when using <code>developPackage</code>. It's not a big deal though,
it's perfectly fine to run the tests separately using <code>nix develop . command
...</code>. However, it turns out <code>developPackage</code> and the underlying machinery is
smart enough to skip installing package required for testing when it's turned
off (using <code>dontCheck</code>). This is the case also when <code>returnShellEnv</code> is <code>true</code>.
</p>

<p>
Luckily it's not too difficult to deal with it. I already had a variable
<code>isDevShell</code> so I could simply reuse it and add the following expression to
<code>modifier</code>
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-nix-keyword">if</span> isDevShell <span class="org-nix-keyword">then</span> hl.doCheck <span class="org-nix-keyword">else</span> hl.dontCheck<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-cabal.html">cabal</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>

<div class="post-date">20 Apr 2024</div><h1 class="post-title"><a href="https://magnus.therning.org/2024-04-20-update-to-hackage-revisions-in-nix.html">Update to Hackage revisions in Nix</a></h1>
<p>
A few days after I published <a href="https://magnus.therning.org/2024-03-14-hackage-revisions-in-nix.html">Hackage revisions in Nix</a> I got a comment from
Wolfgang W that the next release of Nix will have a <code>callHackageDirect</code> with
support for specifying revisions.
</p>

<p>
The code in <a href="https://github.com/NixOS/nixpkgs/pull/284490">PR #284490</a> makes <code>callHackageDirect</code> accept a <code>rev</code> argument. Like
this:
</p>

<div class="org-src-container">
<pre class="src src-nix">haskellPackages.callHackageDirect <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">pkg</span> = <span class="org-string">"openapi3"</span>;
  <span class="org-nix-attribute">ver</span> = <span class="org-string">"3.2.3"</span>;
  <span class="org-nix-attribute">sha256</span> = <span class="org-string">"sha256-0F16o3oqOB5ri6KBdPFEFHB4dv1z+Pw6E5f1rwkqwi8="</span>;
  <span class="org-nix-attribute">rev</span> = <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-nix-attribute">revision</span> = <span class="org-string">"4"</span>;
    <span class="org-nix-attribute">sha256</span> = <span class="org-string">"sha256-a5C58iYrL7eAEHCzinICiJpbNTGwiOFFAYik28et7fI="</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
That's a lot better than using <code>overrideCabal</code>!
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>

<div class="post-date">14 Mar 2024</div><h1 class="post-title"><a href="https://magnus.therning.org/2024-03-14-hackage-revisions-in-nix.html">Hackage revisions in Nix</a></h1>
<p>
Today I got very confused when using <code>callHackageDirect</code> to add the <code>openapi3</code>
package gave me errors like this
</p>

<pre class="example" id="org957ddd8">
&gt; Using Parsec parser
&gt; Configuring openapi3-3.2.3...
&gt; CallStack (from HasCallStack):
&gt;   withMetadata, called at libraries/Cabal/Cabal/src/Distribution/Simple/Ut...
&gt; Error: Setup: Encountered missing or private dependencies:
&gt; base &gt;=4.11.1.0 &amp;&amp; &lt;4.18,
&gt; base-compat-batteries &gt;=0.11.1 &amp;&amp; &lt;0.13,
&gt; template-haskell &gt;=2.13.0.0 &amp;&amp; &lt;2.20
</pre>

<p>
When looking at its <a href="https://hackage.haskell.org/package/openapi3-3.2.3">entry on Hackage</a> those weren't the version ranges for the
dependencies. Also, running <code>ghc-pkg list</code> told me that I already had all
required packages at versions matching what Hackage said. So, what's actually
happening here?
</p>

<p>
It took me a while before remembering about <a href="https://hackage.haskell.org/package/openapi3-3.2.3/revisions/">revisions</a> but once I did it was
clear that <code>callHackageDirect</code> always fetches the initial revision of a package
(i.e. it fetches the original tar-ball uploaded by the author). After realising
this it makes perfect sense &#x2013; it's the only revision that's guaranteed to be
there and won't change. However, it would be very useful to be able to pick a
revision that actually builds.
</p>

<p>
I'm not the first one to find this, of course. It's been noted and written about
on the <a href="https://discourse.nixos.org/t/watch-out-hackage-revisions/14588">discource</a> several years ago. What I didn't find though was a way to
influence what revision that's picked. It took a bit of rummaging around in the
<code>nixpkgs</code> code but finally I found two variables that's used in the Hackage
derivation to control this
</p>

<ul class="org-ul">
<li><code>revision</code> - a string with the number of the revision, and</li>
<li><code>editedCabalFile</code> - the SHA256 of the modified Cabal file.</li>
</ul>

<p>
Setting them is done using the <code>overrideCabal</code> function. This is a piece of my
setup for a modified set of Haskell packages:
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-nix-attribute">hl</span> = nixpkgs.haskell.lib.compose;

<span class="org-nix-attribute">hsPkgs</span> = nixpkgs.haskell.packages.ghc963.override <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">overrides</span> = newpkgs: oldpkgs: <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-nix-attribute">openapi3</span> = hl.overrideCabal <span class="org-rainbow-delimiters-depth-3">(</span>drv: <span class="org-rainbow-delimiters-depth-4">{</span>
      <span class="org-nix-attribute">revision</span> = <span class="org-string">"4"</span>;
      <span class="org-nix-attribute">editedCabalFile</span> =
        <span class="org-string">"sha256-a5C58iYrL7eAEHCzinICiJpbNTGwiOFFAYik28et7fI="</span>;
    <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">(</span>oldpkgs.callHackageDirect <span class="org-rainbow-delimiters-depth-4">{</span>
      <span class="org-nix-attribute">pkg</span> = <span class="org-string">"openapi3"</span>;
      <span class="org-nix-attribute">ver</span> = <span class="org-string">"3.2.3"</span>;
      <span class="org-nix-attribute">sha256</span> = <span class="org-string">"sha256-0F16o3oqOB5ri6KBdPFEFHB4dv1z+Pw6E5f1rwkqwi8="</span>;
    <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
</pre>
</div>

<p>
It's not very ergonomic, and I think an extended version of <code>callHackageDirect</code>
would make sense.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>

<div class="post-date">03 Feb 2024</div><h1 class="post-title"><a href="https://magnus.therning.org/2024-02-03-bending-warp.html">Bending Warp</a></h1>
<p>
In the past I've noticed that <a href="https://hackage.haskell.org/package/warp">Warp</a> both writes to <code>stdout</code> at times and produces
some default HTTP responses, but I've never bothered taking the time to look up
what possibilities it offers to changes this behaviour. I've also always thought
that I ought to find out how Warp handles signals.
</p>

<p>
If you wonder <i>why</i> this would be interesting to know there are three main points:
</p>

<ol class="org-ol">
<li>The environments where the services run are set up to handle structured
logging. In our case it should be <a href="https://jsonlines.org/">JSONL</a> written to <code>stdout</code>, i.e. one JSON
object per line.</li>
<li>We've decided that the error responses we produce in our code should be JSON,
so it's irritating to have to document some special cases where this isn't
true just because Warp has a few default error responses.</li>
<li>Signal handling is, IMHO, a very important part of writing a service that
runs well in <a href="https://kubernetes.io/">k8s</a> as it uses signals to handle the lifetime of pods.</li>
</ol>
<div id="outline-container-org8d5aed4" class="outline-2">
<h2 id="org8d5aed4">Looking through the Warp API</h2>
<div class="outline-text-2" id="text-org8d5aed4">
<p>
Browsing through the <a href="https://hackage.haskell.org/package/warp-3.4.0/docs/Network-Wai-Handler-Warp.html">API documentation for Warp</a> it wasn't too difficult to find
the interesting pieces, and that Warp follows a fairly common pattern in Haskell
libraries
</p>

<ul class="org-ul">
<li>There's a function called <code>runSettings</code> that takes an argument of type <code>Settings</code>.</li>
<li>The default settings are available in a variable called <code>defaultSettings</code> (not very surprising).</li>
<li><p>
There are several functions for modifying the settings and they all have the same shape
</p>

<div class="org-src-container">
<pre class="src src-haskell">setX :: <span class="org-type">X</span> <span class="org-operator">-&gt;</span> <span class="org-type">Settings</span> <span class="org-operator">-&gt;</span> Settings.
</pre>
</div>

<p>
which makes it easy to chain them together.
</p></li>
<li>The functions I'm interested in now are

<dl class="org-dl">
<dt><code>setOnException</code></dt><dd>the default handler, <code>defaultOnException</code>, prints the
exception to <code>stdout</code> using its <code>Show</code> instance</dd>
<dt><code>setOnExceptionResponse</code></dt><dd>the default responses are produced by
<code>defaultOnExceptionResponse</code> and contain plain text response bodies</dd>
<dt><code>setInstallShutdownHandler</code></dt><dd>the default behaviour is to wait for all
ongoing requests and then shut done</dd>
<dt><code>setGracefulShutdownTimeout</code></dt><dd>sets the number of seconds to wait for
ongoing requests to finnish, the default is to wait indefinitely</dd>
</dl></li>
</ul>
</div>
</div>
<div id="outline-container-org7ef5684" class="outline-2">
<h2 id="org7ef5684">Some experimenting</h2>
<div class="outline-text-2" id="text-org7ef5684">
<p>
In order to experiment with these I put together a small API using <a href="https://hackage.haskell.org/package/servant">servant</a>,
<code>app</code>, with a <code>main</code> function using <code>runSettings</code> and stringing together a bunch
of modifications to <code>defaultSettings</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell">main :: <span class="org-type">IO</span> <span class="org-rainbow-delimiters-depth-1">()</span>
main = <span class="org-warning">Log</span>.withLogger <span class="org-operator">$</span> \logger -&gt; <span class="org-keyword">do</span>
    <span class="org-warning">Log</span>.infoIO logger <span class="org-string">"starting the server"</span>
    runSettings <span class="org-rainbow-delimiters-depth-1">(</span>mySettings logger defaultSettings<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>app logger<span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-warning">Log</span>.infoIO logger <span class="org-string">"stopped the server"</span>
  <span class="org-keyword">where</span>
    mySettings logger = myShutdownHandler logger <span class="org-operator">.</span> myOnException logger <span class="org-operator">.</span> myOnExceptionResponse
</pre>
</div>

<p>
<code>myOnException</code> logs JSON objects (using the logging I've written about before,
<a href="https://magnus.therning.org/2023-01-29-a-take-on-log-messages.html">here</a> and <a href="https://magnus.therning.org/2023-02-04-a-take-on-logging.html">here</a>). It decides wether to log or not using
<code>defaultShouldDisplayException</code>, something I copied from <code>defaultOnException</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell">myOnException :: Log.<span class="org-type">Logger</span> <span class="org-operator">-&gt;</span> <span class="org-type">Settings</span> <span class="org-operator">-&gt;</span> <span class="org-type">Settings</span>
myOnException logger = setOnException handler
  <span class="org-keyword">where</span>
    handler mr e = when <span class="org-rainbow-delimiters-depth-1">(</span>defaultShouldDisplayException e<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">$</span> <span class="org-keyword">case</span> mr <span class="org-keyword">of</span>
        Nothing -&gt; <span class="org-warning">Log</span>.warnIO logger <span class="org-operator">$</span> lm <span class="org-operator">$</span> <span class="org-string">"exception: "</span> <span class="org-operator">&lt;&gt;</span> <span class="org-warning">T</span>.pack <span class="org-rainbow-delimiters-depth-1">(</span>show e<span class="org-rainbow-delimiters-depth-1">)</span>
        Just _ -&gt; <span class="org-keyword">do</span>
            <span class="org-warning">Log</span>.warnIO logger <span class="org-operator">$</span> lm <span class="org-operator">$</span> <span class="org-string">"exception with request: "</span> <span class="org-operator">&lt;&gt;</span> <span class="org-warning">T</span>.pack <span class="org-rainbow-delimiters-depth-1">(</span>show e<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
<code>myExceptionResponse</code> responds with JSON objects. It's simpler than
<code>defaultOnExceptionResponse</code>, but it suffices for my learning.
</p>

<div class="org-src-container">
<pre class="src src-haskell">myOnExceptionResponse :: <span class="org-type">Settings</span> <span class="org-operator">-&gt;</span> <span class="org-type">Settings</span>
myOnExceptionResponse = setOnExceptionResponse handler
  <span class="org-keyword">where</span>
    handler _ =
        responseLBS
            <span class="org-warning">H</span>.internalServerError500
            <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-warning">H</span>.hContentType, <span class="org-string">"application/json; charset=utf-8"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
            <span class="org-rainbow-delimiters-depth-1">(</span>encode <span class="org-operator">$</span> object <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"error"</span> <span class="org-operator">.=</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Something went wrong"</span> :: <span class="org-type">String</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Finally, <code>myShutdownHandler</code> installs a handler for <code>SIGTERM</code> that logs and then
shuts down.
</p>

<div class="org-src-container">
<pre class="src src-haskell">myShutdownHandler :: Log.<span class="org-type">Logger</span> <span class="org-operator">-&gt;</span> <span class="org-type">Settings</span> <span class="org-operator">-&gt;</span> <span class="org-type">Settings</span>
myShutdownHandler logger = setInstallShutdownHandler shutdownHandler
  <span class="org-keyword">where</span>
    shutdownAction = <span class="org-warning">Log</span>.infoIO logger <span class="org-string">"closing down"</span>
    shutdownHandler closeSocket = void <span class="org-operator">$</span> installHandler sigTERM <span class="org-rainbow-delimiters-depth-1">(</span>Catch <span class="org-operator">$</span> shutdownAction <span class="org-operator">&gt;&gt;</span> closeSocket<span class="org-rainbow-delimiters-depth-1">)</span> Nothing
</pre>
</div>
</div>
</div>
<div id="outline-container-org9e6b344" class="outline-2">
<h2 id="org9e6b344">Conclusion</h2>
<div class="outline-text-2" id="text-org9e6b344">
<p>
I really ought to have looked into this sooner, especially as it turns out that
Warp offers all the knobs and dials I could wish for to control these aspects of
its behaviour. The next step is to take this and put it to use in one of the
services at <code>$DAYJOB</code>
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-warp.html">warp</a> </div>

<div class="post-date">09 Dec 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-12-09-getting-amazonka-s3-to-work-with-localstack.html">Getting Amazonka S3 to work with localstack</a></h1>
<p>
I'm writing this in case someone else is getting strange errors when trying to
use <a href="https://hackage.haskell.org/package/amazonka-s3">amazonka-s3</a> with <a href="https://github.com/localstack/localstack">localstack</a>. It took me rather too long finding the answer
and neither the errors I got from Amazonka nor from localstack were very
helpful.
</p>

<p>
The code I started with for setting up the connection looked like this
</p>

<div class="org-src-container">
<pre class="src src-haskell">main = <span class="org-keyword">do</span>
  awsEnv &lt;- <span class="org-warning">AWS</span>.overrideService localEndpoint <span class="org-operator">&lt;$&gt;</span> <span class="org-warning">AWS</span>.newEnv <span class="org-warning">AWS</span>.discover
  <span class="org-comment">-- do S3 stuff</span>
  <span class="org-keyword">where</span>
    localEndpoint = <span class="org-warning">AWS</span>.setEndpoint False <span class="org-string">"localhost"</span> <span class="org-number">4566</span>
</pre>
</div>

<p>
A few years ago, when I last wrote some Haskell to talk to S3 this was
enough<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>, but now I got some strange errors.
</p>

<p>
It turns out there are different ways to address buckets and the default, which
is used by AWS itself, isn't used by localstack. The documentation of
<a href="https://hackage.haskell.org/package/amazonka-2.0/docs/Amazonka.html#t:S3AddressingStyle"><code>S3AddressingStyle</code></a> has more details.
</p>

<p>
So to get it to work I had to change the S3 addressing style as well and ended
up with this code instead
</p>

<div class="org-src-container">
<pre class="src src-haskell">main = <span class="org-keyword">do</span>
  awsEnv &lt;- <span class="org-warning">AWS</span>.overrideService <span class="org-rainbow-delimiters-depth-1">(</span>s3AddrStyle <span class="org-operator">.</span> localEndpoint<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;$&gt;</span> <span class="org-warning">AWS</span>.newEnv <span class="org-warning">AWS</span>.discover
  <span class="org-comment">-- do S3 stuff</span>
  <span class="org-keyword">where</span>
    localEndpoint = <span class="org-warning">AWS</span>.setEndpoint False <span class="org-string">"localhost"</span> <span class="org-number">4566</span>
    s3AddrStyle svc = svc <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-warning">AWS</span>.s3AddressingStyle = AWS.S3AddressingStylePath<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
That was before version 2.0 of Amazonka, so it did look slightly different,
but overriding the endpoint was all that was needed.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-amazonka.html">amazonka</a> <a href="https://magnus.therning.org/tag-aws.html">aws</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-localstack.html">localstack</a> </div>

<div class="post-date">24 Sep 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-09-24-defining-a-formatter-for-cabal-files.html">Defining a formatter for Cabal files</a></h1>
<p>
For Haskell code I can use <code>lsp-format-buffer</code> and <code>lsp-format-region</code> to keep
my file looking nice, but I've never found a function for doing the same for
Cabal files. There's a nice command line tool, <code>cabal-fmt</code>, for doing it, but it
means having to jump to a terminal. It would of course be nicer to satisfy my
needs for aesthetics directly from Emacs. A few times I've thought of writing
the function myself, I mean how hard can it be? But then I've forgotten about it
until then next time I'm editing a Cabal file.
</p>

<p>
A few days ago I noticed <a href="https://github.com/purcell/emacs-reformatter">emacs-reformatter</a> popping up in my feeds. That
removed all reasons to procrastinate. It turned out to be very easy to set up.
</p>

<p>
The package doesn't have a recipe for <a href="https://github.com/radian-software/straight.el">straight.el</a> so it needs a <code>:straight</code>
section. Also, the naming of the file in the package doesn't fit the package
name, hence the slightly different name in the <code>use-package</code> declaration:<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">use-package</span> <span class="org-constant">reformatter</span>
  <span class="org-builtin">:straight</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-builtin">:host</span> github
             <span class="org-builtin">:repo</span> <span class="org-string">"purcell/emacs-reformatter"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Now the formatter can be defined
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">reformatter-define</span> cabal-format
  <span class="org-builtin">:program</span> <span class="org-string">"cabal-fmt"</span>
  <span class="org-builtin">:args</span> '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"/dev/stdin"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
in order to create functions for formatting, <code>cabal-format-buffer</code> and
<code>cabal-format-region</code>, as well as a minor mode for formatting on saving a Cabal
file.
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I'm sure it's possible to use <code>:files</code> to deal with this, but I'm not sure
how and my naive guess failed. It's OK to be like this until I figure it out
properly.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>

<div class="post-date">26 Apr 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-04-26-some-practical-haskell.html">Some practical Haskell</a></h1>
<p>
As I'm nearing the end of my time with my current employer I thought I'd put
together some bits of practical Haskell that I've put into production. We only
have a few services in Haskell, and basically I've had to sneak them into
production. I'm hoping someone will find something useful. I'd be even happier
if I get pointers on how to do this even better.
</p>

<div id="outline-container-org6d67a5e" class="outline-2">
<h2 id="org6d67a5e">Logging</h2>
<div class="outline-text-2" id="text-org6d67a5e">
<p>
I've written about that earlier in three posts:
</p>

<ol class="org-ol">
<li><a href="https://magnus.therning.org/2023-01-29-a-take-on-log-messages.html">A take on log messages</a></li>
<li><a href="https://magnus.therning.org/2023-02-04-a-take-on-logging.html">A take on logging</a></li>
<li><a href="https://magnus.therning.org/2023-02-08-logging-with-class.html">Logging with class</a></li>
</ol>
</div>
</div>

<div id="outline-container-orga164ea9" class="outline-2">
<h2 id="orga164ea9">Final exception handler</h2>
<div class="outline-text-2" id="text-orga164ea9">
<p>
After reading about the <i>uncaught exception handler</i> in <a href="https://serokell.io/blog/uncaught-exception-handling">Serokell's article</a> I've
added the following snippet to all the services.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    <span class="org-haskell-operator">...</span>
    originalHandler <span class="org-haskell-operator">&lt;-</span> getUncaughtExceptionHandler
    setUncaughtExceptionHandler <span class="org-haskell-operator">$</span> handle originalHandler <span class="org-haskell-operator">.</span> lastExceptionHandler logger
    <span class="org-haskell-operator">...</span>

<span class="org-haskell-definition">lastExceptionHandler</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Logger</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">SomeException</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">lastExceptionHandler</span> logger e <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    fatalIO logger <span class="org-haskell-operator">$</span> lm <span class="org-haskell-operator">$</span> <span class="org-string">"uncaught exception: "</span> <span class="org-haskell-operator">&lt;&gt;</span> displayException e
</pre>
</div>
</div>
</div>

<div id="outline-container-org807a09b" class="outline-2">
<h2 id="org807a09b">Handling signals</h2>
<div class="outline-text-2" id="text-org807a09b">
<p>
To make sure the platform we're running our services on is happy with a service
it needs to handle <code>SIGTERM</code>, and when running it locally during development,
e.g. for manual testing, it's nice if it also handles <code>SIGINT</code>.
</p>

<p>
The following snippet comes from a service that needs to make sure that every
iteration of its processing is completed before shutting down, hence the <code>IORef</code>
that's used to signal whether procession should continue or not.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    <span class="org-haskell-operator">...</span>
    cont <span class="org-haskell-operator">&lt;-</span> newIORef <span class="org-haskell-constructor">True</span>
    void <span class="org-haskell-operator">$</span> installHandler softwareTermination <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Catch</span> <span class="org-haskell-operator">$</span> sigHandler logger cont<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">Nothing</span>
    void <span class="org-haskell-operator">$</span> installHandler keyboardSignal <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Catch</span> <span class="org-haskell-operator">$</span> sigHandler logger cont<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">Nothing</span>
    <span class="org-haskell-operator">...</span>

<span class="org-haskell-definition">sigHandler</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Logger</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IORef</span> <span class="org-haskell-type">Bool</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">sigHandler</span> logger cont <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    infoIO logger <span class="org-string">"got a signal, shutting down"</span>
    writeIORef cont <span class="org-haskell-constructor">False</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8226fdb" class="outline-2">
<h2 id="org8226fdb">Probes</h2>
<div class="outline-text-2" id="text-org8226fdb">
<p>
Due to some details about how networking works in our platform it's currently
not possible to use network-based probing. Instead we have to use files. There
are two probes that are of interest
</p>

<ul class="org-ul">
<li>A startup probe, existance of the file signals that the service has started as
is about being processing.</li>
<li>A progress probe, a timestamp signals the time the most recent iteration of
processing finished<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.</li>
</ul>

<p>
I've written a little bit about the latter before in <a href="https://magnus.therning.org/2022-05-08-a-little-haskell:-epoch-timestamp.html">A little Haskell: epoch
timestamp</a>, but here I'm including both functions.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">createPidFile</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">FilePath</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">createPidFile</span> fn <span class="org-haskell-operator">=</span> getProcessID <span class="org-haskell-operator">&gt;&gt;=</span> writeFile fn <span class="org-haskell-operator">.</span> show

<span class="org-haskell-definition">writeTimestampFile</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">FilePath</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">writeTimestampFile</span> fn <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    getPOSIXTime <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-rainbow-delimiters-depth-1">(</span>writeFile fn <span class="org-haskell-operator">.</span> show<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">.</span> truncate <span class="org-haskell-operator">@</span><span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">@</span><span class="org-haskell-constructor">Int64</span> <span class="org-haskell-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">*</span> 1000<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
The actual probing is then done using a command that compares the saved
timestamp with the current time. As long as the difference is smaller than a
threshold the probe succeeds.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>

<div class="post-date">22 Mar 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-03-22-making-an-emacs-major-mode-for-cabal-using-tree-sitter.html">Making an Emacs major mode for Cabal using tree-sitter</a></h1>
<p>
A few days ago I <a href="https://www.reddit.com/r/haskell/comments/11uvhsk/cabal_grammar_for_treesitter_at_least_the/">posted on r/haskell</a> that I'm attempting to put together a <a href="https://cabal.readthedocs.io/en/stable/index.html">Cabal</a>
grammar for <a href="https://tree-sitter.github.io/tree-sitter/">tree-sitter</a>.  Some things are still missing, but it covers enough to
start doing what I initially intended: experiment with writing an alternative
Emacs major mode for Cabal.
</p>

<p>
The documentation for the tree-sitter integration is very nice, and several of
the major modes already have tree-sitter variants, called <code>X-ts-mode</code> where <code>X</code>
is e.g. <code>python</code>, so putting together the beginning of a major mode wasn't too
much work.
</p>

<div id="outline-container-orgaa93cd2" class="outline-2">
<h2 id="orgaa93cd2">Configuring Emacs</h2>
<div class="outline-text-2" id="text-orgaa93cd2">
<p>
First off I had to make sure the parser for Cabal was installed. The snippet for
that looks like this<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">use-package</span> <span class="org-constant">treesit</span>
  <span class="org-builtin">:straight</span> nil
  <span class="org-builtin">:ensure</span> nil
  <span class="org-builtin">:commands</span> <span class="org-rainbow-delimiters-depth-2">(</span>treesit-install-language-grammar<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-builtin">:init</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq</span> treesit-language-source-alist
        '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>cabal . <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"https://gitlab.com/magus/tree-sitter-cabal.git"</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
With that in place the parser is installed using <code>M-x
treesit-install-language-grammar</code> and choosing <code>cabal</code>.
</p>

<p>
After that I removed my configuration for <code>haskell-mode</code> and added the following
snippet to get my own major mode into my setup.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">use-package</span> <span class="org-constant">my-cabal-mode</span>
  <span class="org-builtin">:straight</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-builtin">:type</span> git
             <span class="org-builtin">:repo</span> <span class="org-string">"git@gitlab.com:magus/my-emacs-pkgs.git"</span>
             <span class="org-builtin">:branch</span> <span class="org-string">"main"</span>
             <span class="org-builtin">:files</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-builtin">:defaults</span> <span class="org-string">"my-cabal-mode/*el"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge3a4a9a" class="outline-2">
<h2 id="orge3a4a9a">The major mode and font-locking</h2>
<div class="outline-text-2" id="text-orge3a4a9a">
<p>
The built-in elisp documentation actually has a section on writing a major mode
with tree-sitter, so it was easy to get started. Setting up the font-locking
took a bit of trial-and-error, but once I had comments looking the way I wanted
it was easy to add to the setup. Oh, and yes, there's a section on font-locking
with tree-sitter in the documentation too. At the moment it looks like this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defvar</span> <span class="org-variable-name">cabal--treesit-font-lock-setting</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>treesit-font-lock-rules
   <span class="org-builtin">:feature</span> 'comment
   <span class="org-builtin">:language</span> 'cabal
   '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>comment<span class="org-rainbow-delimiters-depth-4">)</span> @font-lock-comment-face<span class="org-rainbow-delimiters-depth-3">)</span>

   <span class="org-builtin">:feature</span> 'cabal-version
   <span class="org-builtin">:language</span> 'cabal
   '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>cabal_version _<span class="org-rainbow-delimiters-depth-4">)</span> @font-lock-constant-face<span class="org-rainbow-delimiters-depth-3">)</span>

   <span class="org-builtin">:feature</span> 'field-name
   <span class="org-builtin">:language</span> 'cabal
   '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>field_name<span class="org-rainbow-delimiters-depth-4">)</span> @font-lock-keyword-face<span class="org-rainbow-delimiters-depth-3">)</span>

   <span class="org-builtin">:feature</span> 'section-name
   <span class="org-builtin">:language</span> 'cabal
   '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span> @font-lock-variable-name-face<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Tree-sitter font-lock settings."</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter">;;;</span><span class="org-comment">###</span><span class="org-comment"><span class="org-warning">autoload</span></span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">define-derived-mode</span> <span class="org-function-name">my-cabal-mode</span> fundamental-mode <span class="org-string">"My Cabal"</span>
  <span class="org-doc">"My mode for Cabal files"</span>

  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when</span> <span class="org-rainbow-delimiters-depth-3">(</span>treesit-ready-p 'cabal<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>treesit-parser-create 'cabal<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">set up treesit</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">setq-local</span> treesit-font-lock-feature-list
                '<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-rainbow-delimiters-depth-5">(</span>comment field-name section-name<span class="org-rainbow-delimiters-depth-5">)</span>
                  <span class="org-rainbow-delimiters-depth-5">(</span>cabal-version<span class="org-rainbow-delimiters-depth-5">)</span>
                  <span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">setq-local</span> treesit-font-lock-settings cabal--treesit-font-lock-setting<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>treesit-major-mode-setup<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter">;;;</span><span class="org-comment">###</span><span class="org-comment"><span class="org-warning">autoload</span></span>
<span class="org-rainbow-delimiters-depth-1">(</span>add-to-list 'auto-mode-alist '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\\.cabal\\'"</span> . my-cabal-mode<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5251e68" class="outline-2">
<h2 id="org5251e68">Navigation</h2>
<div class="outline-text-2" id="text-org5251e68">
<p>
One of the reasons I want to experiment with tree-sitter is to use it for code
navigation. My first attempt is to translate <code>haskell-cabal-section-beginning</code>
(in <code>haskell-mode</code>, <a href="https://github.com/haskell/haskell-mode/blob/master/haskell-cabal.el#L395">the source</a>) to using tree-sitter. First a convenience
function to recognise if a node is a section or not
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">cabal--node-is-section-p</span> <span class="org-rainbow-delimiters-depth-2">(</span>n<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Predicate to check if treesit node N is a Cabal section."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>member <span class="org-rainbow-delimiters-depth-3">(</span>treesit-node-type n<span class="org-rainbow-delimiters-depth-3">)</span>
          '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"benchmark"</span> <span class="org-string">"common"</span> <span class="org-string">"executable"</span> <span class="org-string">"flag"</span> <span class="org-string">"library"</span> <span class="org-string">"test_suite"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That makes it possible to use <code>treesit-parent-until</code> to traverse the nodes until
hitting a section node
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">cabal-goto-beginning-of-section</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Go to the beginning of the current section."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">interactive</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when-let*</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>node-at-point <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-at <span class="org-rainbow-delimiters-depth-6">(</span>point<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>section-node <span class="org-rainbow-delimiters-depth-5">(</span>treesit-parent-until node-at-point #'cabal--node-is-section-p<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>start-pos <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-start section-node<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>goto-char start-pos<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
And the companion function, to go to the end of a section is very similar
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">cabal-goto-end-of-section</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Go to the end of the current section."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">interactive</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when-let*</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>node-at-point <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-at <span class="org-rainbow-delimiters-depth-6">(</span>point<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>section-node <span class="org-rainbow-delimiters-depth-5">(</span>treesit-parent-until node-at-point #'cabal--node-is-section-p<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>end-pos <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-end section-node<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>goto-char end-pos<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I'm using <a href="https://github.com/radian-software/straight.el">straight.el</a> and <code>use-package</code> in my setup, but hopefully the
snippets can easily be converted to other ways of configuring Emacs.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-cabal.html">cabal</a> <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-tree-sitter.html">tree-sitter</a> </div>

<div class="post-date">08 Feb 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-02-08-logging-with-class.html">Logging with class</a></h1>
<p>
In two previous posts I've described how I currently compose <a href="https://magnus.therning.org/2023-01-29-a-take-on-log-messages.html">log messages</a> and
how I do the actual <a href="https://magnus.therning.org/2023-02-04-a-take-on-logging.html">logging</a>. This post wraps up this particular topic for now
with a couple of typeclasses, a default implementation, and an example showing
how I use them.
</p>

<div id="outline-container-org9c277ac" class="outline-2">
<h2 id="org9c277ac">The typeclasses</h2>
<div class="outline-text-2" id="text-org9c277ac">
<p>
First off I want a monad for the logging itself. It's just a collection of
functions taking a <code>LogMsg</code> and returning unit (in a monad).
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">class</span> <span class="org-tree-sitter-hl-faceXtype">Monad</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtype">LoggerActions</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">debug</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">info</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">warn</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">err</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">fatal</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
</pre>
</div>

<p>
In order to provide a default implementation I also need a way to extract the
logger itself.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">class</span> <span class="org-tree-sitter-hl-faceXtype">Monad</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtype">HasLogger</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXtype">Logger</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfc9e191" class="outline-2">
<h2 id="orgfc9e191">Default implementation</h2>
<div class="outline-text-2" id="text-orgfc9e191">
<p>
Using the two typeclasses above it's now possible to define a type with an
implementation of <code>LoggerActions</code> that is usable with <a href="https://magnus.therning.org/2023-01-15-composing-instances-using-~deriving-via~.html"><code>deriving
via</code></a>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">newtype</span> <span class="org-tree-sitter-hl-faceXtype">StdLoggerActions</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXtypeXargument">a</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXconstructor">MkStdZLA</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXtypeXargument">a</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Functor</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Applicative</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Monad</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">HasLogger</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>

<p>
And its implementattion of <code>LoggerActions</code> looks like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">instance</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">HasLogger</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtype">LoggerActions</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">StdLoggerActions</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">debug</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">&gt;&gt;=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">flip</span></span> <span class="org-tree-sitter-hl-faceXvariable">debugIO</span> <span class="org-tree-sitter-hl-faceXvariable">msg</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">info</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">&gt;&gt;=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">flip</span></span> <span class="org-tree-sitter-hl-faceXvariable">infoIO</span> <span class="org-tree-sitter-hl-faceXvariable">msg</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">warn</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">&gt;&gt;=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">flip</span></span> <span class="org-tree-sitter-hl-faceXvariable">warnIO</span> <span class="org-tree-sitter-hl-faceXvariable">msg</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">err</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">&gt;&gt;=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">flip</span></span> <span class="org-tree-sitter-hl-faceXvariable">errIO</span> <span class="org-tree-sitter-hl-faceXvariable">msg</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">fatal</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">&gt;&gt;=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">flip</span></span> <span class="org-tree-sitter-hl-faceXvariable">fatalIO</span> <span class="org-tree-sitter-hl-faceXvariable">msg</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org985e509" class="outline-2">
<h2 id="org985e509">An example</h2>
<div class="outline-text-2" id="text-org985e509">
<p>
Using the definitions above is fairly straight forward. First a type the derives
its implementaiton of <code>LoggerActions</code> from <code>StdLoggerActions</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">newtype</span> <span class="org-tree-sitter-hl-faceXtype">EnvT</span> <span class="org-tree-sitter-hl-faceXtypeXargument">a</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXconstructor">EnvT</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">{</span></span><span class="org-tree-sitter-hl-faceXvariable">runEnvT</span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">ReaderT</span> <span class="org-tree-sitter-hl-faceXtype">Logger</span> <span class="org-tree-sitter-hl-faceXtype">IO</span> <span class="org-tree-sitter-hl-faceXtypeXargument">a</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">}</span></span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXkeyword">newtype</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Functor</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Applicative</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Monad</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">MonadReader</span> <span class="org-tree-sitter-hl-faceXtype">Logger</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">LoggerActions</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXkeyword">via</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">StdLoggerActions</span> <span class="org-tree-sitter-hl-faceXtype">EnvT</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>

<p>
In order for it to work, and compile, it needs an implementation of <code>HasLogger</code> too.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">instance</span> <span class="org-tree-sitter-hl-faceXtype">HasLogger</span> <span class="org-tree-sitter-hl-faceXtype">EnvT</span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable">ask</span>
</pre>
</div>

<p>
All that's left is a function using a constraint on <code>LoggerActions</code> (<code>doStuff</code>)
and a <code>main</code> function creating a logger, constructing an <code>EnvT</code>, and then
running <code>doStuff</code> in it.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">doStuff</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LoggerActions</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">doStuff</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXkeyword">do</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">debug</span></span> <span class="org-tree-sitter-hl-faceXstring">"a log line"</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">info</span></span> <span class="org-tree-sitter-hl-faceXoperator">$</span> <span class="org-tree-sitter-hl-faceXstring">"another log line"</span> <span class="org-tree-sitter-hl-faceXoperator">#+</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">[</span></span><span class="org-tree-sitter-hl-faceXstring">"extras"</span> <span class="org-tree-sitter-hl-faceXoperator">.=</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-tree-sitter-hl-faceXnumber">42</span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">Int</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">]</span></span>

<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">main</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">IO</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">main</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">withLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">$</span> <span class="org-tree-sitter-hl-faceXoperator">\</span><span class="org-tree-sitter-hl-faceXvariable">logger</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">runReaderT</span></span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">runEnvT</span></span> <span class="org-tree-sitter-hl-faceXvariable">doStuff</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXvariable">logger</span>
</pre>
</div>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-logging.html">logging</a> </div>

<div class="post-date">04 Feb 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-02-04-a-take-on-logging.html">A take on logging</a></h1>
<p>
In my <a href="https://magnus.therning.org/2023-01-29-a-take-on-log-messages.html">previous post</a> I described a type, with instances and a couple of useful
functions for composing log messages. To actually make use of that there's a bit
more needed, i.e. the actual logging. In this post I'll share that part of the
logging setup I've been using in the Haskell services at <code>$DAYJOB</code>.
</p>

<div id="outline-container-orge3ca7c2" class="outline-2">
<h2 id="orge3ca7c2">The logger type</h2>
<div class="outline-text-2" id="text-orge3ca7c2">
<p>
The logger will be a wrapper around <a href="https://hackage.haskell.org/package/fast-logger">fast-logger</a>'s <code>FastLogger</code>, even though
that's not really visible.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">newtype</span> <span class="org-tree-sitter-hl-faceXtype">Logger</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXconstructor">Logger</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtype">IO</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>

<p>
It's nature as a wrapper makes it natural to follow the API of fast-logger, with
some calls to <code>liftIO</code> added.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">newLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Logger</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">newLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">liftIO</span></span> <span class="org-tree-sitter-hl-faceXoperator">$</span> <span class="org-tree-sitter-hl-faceXkeyword">do</span>
    <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXvariable">fastLogger</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXvariable">cleanUp</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXoperator">&lt;-</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">newFastLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">$</span> <span class="org-tree-sitter-hl-faceXconstructor">LogStdout</span> <span class="org-tree-sitter-hl-faceXvariable">defaultBufSize</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">pure</span></span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXconstructor">Logger</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">fastLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">.</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">toLogStr</span></span> <span class="org-tree-sitter-hl-faceXoperator">@</span><span class="org-tree-sitter-hl-faceXtype">LogMsg</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">liftIO</span></span> <span class="org-tree-sitter-hl-faceXvariable">cleanUp</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>

<p>
The implementation of <code>withLogger</code> is pretty much a copy of what I found in
fast-logger, just adapted to the <code>newLogger</code> above.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">withLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">MonadMask</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Logger</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">withLogger</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">go</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">bracket</span></span> <span class="org-tree-sitter-hl-faceXvariable">newLogger</span> <span class="org-tree-sitter-hl-faceXvariable">snd</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">go</span></span> <span class="org-tree-sitter-hl-faceXoperator">.</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">fst</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge51450b" class="outline-2">
<h2 id="orge51450b">Logging functions</h2>
<div class="outline-text-2" id="text-orge51450b">
<p>
All logging functions will follow the same pattern so it's easy to break out the
common parts.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">logIO</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtype">Text</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtype">Logger</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">logIO</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">lvl</span></span><span class="org-tree-sitter-hl-faceXvariableXparameter"> </span><span class="org-tree-sitter-hl-faceXvariableXparameter"><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span></span><span class="org-tree-sitter-hl-faceXvariableXparameter"><span class="org-tree-sitter-hl-faceXconstructor">Logger</span></span><span class="org-tree-sitter-hl-faceXvariableXparameter"> </span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">ls</span></span><span class="org-tree-sitter-hl-faceXvariableXparameter"><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span></span><span class="org-tree-sitter-hl-faceXvariableXparameter"> </span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXkeyword">do</span>
    <span class="org-tree-sitter-hl-faceXvariable">t</span> <span class="org-tree-sitter-hl-faceXoperator">&lt;-</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">formatTime</span></span> <span class="org-tree-sitter-hl-faceXvariable">defaultTimeLocale</span> <span class="org-tree-sitter-hl-faceXstring">"%y-%m-%dT%H:%M:%S%03QZ"</span> <span class="org-tree-sitter-hl-faceXoperator">&lt;$&gt;</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">liftIO</span></span> <span class="org-tree-sitter-hl-faceXvariable">getCurrentTime</span>
    <span class="org-tree-sitter-hl-faceXkeyword">let</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">bmsg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXstring">""</span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">[</span></span> <span class="org-tree-sitter-hl-faceXstring">"correlation-id"</span> <span class="org-tree-sitter-hl-faceXoperator">.=</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-tree-sitter-hl-faceXstring">"no-correlation-id"</span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">Text</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">)</span></span>
                     <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXstring">"timestamp"</span> <span class="org-tree-sitter-hl-faceXoperator">.=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">t</span></span>
                     <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXstring">"level"</span> <span class="org-tree-sitter-hl-faceXoperator">.=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">lvl</span></span>
                     <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">]</span></span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">liftIO</span></span> <span class="org-tree-sitter-hl-faceXoperator">$</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">ls</span></span> <span class="org-tree-sitter-hl-faceXoperator">$</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">bmsg</span></span> <span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">msg</span></span>
</pre>
</div>

<p>
With that in place the logging functions become very short and sweet.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">debugIO</span></span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">infoIO</span></span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">warnIO</span></span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">errIO</span></span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">fatalIO</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtype">Logger</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">debugIO</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">logIO</span></span> <span class="org-tree-sitter-hl-faceXstring">"debug"</span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">infoIO</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">logIO</span></span> <span class="org-tree-sitter-hl-faceXstring">"info"</span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">warnIO</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">logIO</span></span> <span class="org-tree-sitter-hl-faceXstring">"warn"</span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">errIO</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">logIO</span></span> <span class="org-tree-sitter-hl-faceXstring">"error"</span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">fatalIO</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">logIO</span></span> <span class="org-tree-sitter-hl-faceXstring">"fatal"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6e0d3f7" class="outline-2">
<h2 id="org6e0d3f7">Simple example of usage</h2>
<div class="outline-text-2" id="text-org6e0d3f7">
<p>
A very simple example showing how it could be used would be something like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">main</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">IO</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">main</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">withLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">$</span> <span class="org-tree-sitter-hl-faceXoperator">\</span><span class="org-tree-sitter-hl-faceXvariable">logger</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXkeyword">do</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">debugIO</span></span> <span class="org-tree-sitter-hl-faceXvariable">logger</span> <span class="org-tree-sitter-hl-faceXstring">"a log line"</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">infoIO</span></span> <span class="org-tree-sitter-hl-faceXvariable">logger</span> <span class="org-tree-sitter-hl-faceXoperator">$</span> <span class="org-tree-sitter-hl-faceXstring">"another log line"</span> <span class="org-tree-sitter-hl-faceXoperator">#+</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">[</span></span><span class="org-tree-sitter-hl-faceXstring">"extras"</span> <span class="org-tree-sitter-hl-faceXoperator">.=</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-tree-sitter-hl-faceXnumber">42</span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">Int</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">]</span></span>
</pre>
</div>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-logging.html">logging</a> </div>

<div class="post-date">29 Jan 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-01-29-a-take-on-log-messages.html">A take on log messages</a></h1>
<p>
At <code>$DAYJOB</code> we use structured logging with rather little actual structure, the only rules are
</p>

<ol class="org-ol">
<li>Log to <code>stdout</code>.</li>
<li>Log one JSON object per line.</li>
<li>The only required fields are
<ul class="org-ul">
<li><code>message</code> - a human readable string describing the event</li>
<li><code>level</code> - the severity of the event, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, or <code>fatal</code>.</li>
<li><code>timestamp</code> - the time of the event</li>
<li><code>correlation-id</code> - an ID passed between services to allow to find related events</li>
</ul></li>
</ol>

<p>
Beyond that pretty much anything goes, any other fields that are useful in that
service, or even in that one log message is OK.
</p>

<p>
My first take was very ad-hoc, mostly becuase there were other parts of the
question "How do I write a service in Haskell, actually?" that needed more
attention &#x2013; then I read <a href="https://jship.github.io/posts/2022-05-17-announcing-monad-logger-aeson/">Announcing monad-logger-aeson: Structured logging in
Haskell for cheap</a>. Sure, I'd looked at some of the logging libraries on
Hackage but not really found anything that seemed like it would fit very well.
Not until <a href="https://hackage.haskell.org/package/monad-logger-aeson">monad-logger-aeson</a>, that is. Well, at least until I realised it didn't
quite fit the rules we have.
</p>

<p>
It did give me some ideas of how to structure my current rather simple, but very
awkward to use, current loggging code. This is what I came up with, and after
using it in a handful services I find it kind of nice to work with. Let me know
what you think.
</p>

<div id="outline-container-org7a41693" class="outline-2">
<h2 id="org7a41693">The log message type</h2>
<div class="outline-text-2" id="text-org7a41693">
<p>
I decided that a log message must always contain the text describing the event.
It's the one thing that's sure to be known at the point where the developer
writes the code to log an event. All the other mandatory parts can, and probably
should as far as possible, be added by the logging library itself. So I ended up
with this type.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">data</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXtype">Text</span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">[</span></span><span class="org-tree-sitter-hl-faceXtype">Pair</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">]</span></span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Eq</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Show</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>

<p>
It should however be easy to add custom parts at the point of logging, so I
added an operator for that.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXoperator">#+</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">[</span></span><span class="org-tree-sitter-hl-faceXtype">Pair</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">]</span></span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span>
<span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXoperator">#+</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXvariable">msg</span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXvariable">ps0</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXvariable">ps1</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">ps0</span></span> <span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">ps1</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>

<p>
The ordering is important, i.e. <code>ps0 &lt;&gt; ps1</code>, as <a href="https://hackage.haskell.org/package/monad-logger-aeson">aeson</a>'s <code>object</code> function will
take the <i>last</i> value for a field and I want to be able to give keys in a log
message new values by overwriting them later on.
</p>
</div>
</div>

<div id="outline-container-org2d4772f" class="outline-2">
<h2 id="org2d4772f">Instances to use it with fast-logger</h2>
<div class="outline-text-2" id="text-org2d4772f">
<p>
The previous logging code used <a href="https://hackage.haskell.org/package/fast-logger">fast-logger</a> and it had worked really well so I
decided to stick with it. Making <code>LogMsg</code> and instance of <code>ToLogStr</code> is key, and
as the rules require logging of JSON objects it also needs to be an instance of
<code>ToJSON</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">instance</span> <span class="org-tree-sitter-hl-faceXtype">ToJSON</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">toJSON</span></span> <span class="org-tree-sitter-hl-faceXvariableXparameter"><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span></span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span><span class="org-tree-sitter-hl-faceXvariableXparameter"> </span><span class="org-tree-sitter-hl-faceXvariableXparameter"><span class="org-tree-sitter-hl-faceXoperator">:#</span></span><span class="org-tree-sitter-hl-faceXvariableXparameter"> </span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">ps</span></span><span class="org-tree-sitter-hl-faceXvariableXparameter"><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">object</span></span> <span class="org-tree-sitter-hl-faceXoperator">$</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">ps</span></span> <span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">[</span></span><span class="org-tree-sitter-hl-faceXstring">"message"</span> <span class="org-tree-sitter-hl-faceXoperator">.=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">msg</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">]</span></span>

<span class="org-tree-sitter-hl-faceXkeyword">instance</span> <span class="org-tree-sitter-hl-faceXtype">ToLogStr</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">toLogStr</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">toLogStr</span></span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">encode</span></span> <span class="org-tree-sitter-hl-faceXvariable">msg</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span> <span class="org-tree-sitter-hl-faceXstring">"\n"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org656d5ed" class="outline-2">
<h2 id="org656d5ed">Instance to make it easy to log a string</h2>
<div class="outline-text-2" id="text-org656d5ed">
<p>
It's common to just want to log a single string and nothing else, so it's handy
if <code>LogMsg</code> is an instance of <code>IsString</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">instance</span> <span class="org-tree-sitter-hl-faceXtype">IsString</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">fromString</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">pack</span></span> <span class="org-tree-sitter-hl-faceXvariable">msg</span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">[]</span></span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga6d25c3" class="outline-2">
<h2 id="orga6d25c3">Combining log messages</h2>
<div class="outline-text-2" id="text-orga6d25c3">
<p>
When writing the previous logging code I'd regularly felt pain from the lack of
a nice way to combine log messages. With the definition of <code>LogMsg</code> above it's
not difficult to come up with reasonable instances for both <code>Semigroup</code> and
<code>Monoid</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">instance</span> <span class="org-tree-sitter-hl-faceXtype">Semigroup</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXstring">""</span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXvariable">ps0</span> <span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span> <span class="org-tree-sitter-hl-faceXvariable">msg1</span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXvariable">ps1</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">msg1</span></span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">ps0</span></span> <span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">ps1</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
    <span class="org-tree-sitter-hl-faceXvariable">msg0</span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXvariable">ps0</span> <span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span> <span class="org-tree-sitter-hl-faceXstring">""</span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXvariable">ps1</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">msg0</span></span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">ps0</span></span> <span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">ps1</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
    <span class="org-tree-sitter-hl-faceXvariable">msg0</span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXvariable">ps0</span> <span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span> <span class="org-tree-sitter-hl-faceXvariable">msg1</span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXvariable">ps1</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">msg0</span></span> <span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span> <span class="org-tree-sitter-hl-faceXstring">" - "</span> <span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">msg1</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXoperator">:#</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">ps0</span></span> <span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">ps1</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>

<span class="org-tree-sitter-hl-faceXkeyword">instance</span> <span class="org-tree-sitter-hl-faceXtype">Monoid</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">mempty</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXstring">""</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0b45515" class="outline-2">
<h2 id="org0b45515">In closing</h2>
<div class="outline-text-2" id="text-org0b45515">
<p>
What's missing above is the automatic handling of the remaining fields. I'll try
to get back to that part soon. For now I'll just say that the log message API
above made the implementation nice and straight forward.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-logging.html">logging</a> </div>

<div class="post-date">15 Jan 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-01-15-composing-instances-using-~deriving-via~.html">Composing instances using <tt>deriving via</tt></a></h1>
<p>
Today I watched the very good, and short, video from Tweag on how to <a href="https://www.youtube.com/watch?v=UZaQuSIrO6s">Avoid
boilerplate instances with -XDerivingVia</a>. It made me realise that I've read
about this before, but then the topic was on reducing boilerplate with MTL-style
code.
</p>

<p>
Given that I'd forgotten about it I'm writing this mostly as a note to myself.
</p>

<div id="outline-container-orgd2c4425" class="outline-2">
<h2 id="orgd2c4425">The example from the Tweag video, slightly changed</h2>
<div class="outline-text-2" id="text-orgd2c4425">
<p>
The code for making film ratings into a <code>Monoid</code>, when translated to the UK,
would look something like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell">{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module DeriveMonoid <span class="org-tree-sitter-hl-faceXkeyword">where</span>

<span class="org-tree-sitter-hl-faceXkeyword">newtype</span> <span class="org-tree-sitter-hl-faceXtype">Supremum</span> <span class="org-tree-sitter-hl-faceXtype">a</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXconstructor">MkSup</span> <span class="org-tree-sitter-hl-faceXtype">a</span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXkeyword">stock</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Bounded</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Eq</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Ord</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXkeyword">newtype</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Show</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>

<span class="org-tree-sitter-hl-faceXkeyword">instance</span> <span class="org-tree-sitter-hl-faceXtype">Ord</span> <span class="org-tree-sitter-hl-faceXtype">a</span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtype">Semigroup</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Supremum</span> <span class="org-tree-sitter-hl-faceXtype">a</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXoperator">&lt;&gt;</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable">max</span>

<span class="org-tree-sitter-hl-faceXkeyword">instance</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Bounded</span> <span class="org-tree-sitter-hl-faceXtype">a</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Ord</span> <span class="org-tree-sitter-hl-faceXtype">a</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtype">Monoid</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Supremum</span> <span class="org-tree-sitter-hl-faceXtype">a</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXfunction"><span class="org-tree-sitter-hl-faceXvariable">mempty</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable">minBound</span>

<span class="org-tree-sitter-hl-faceXkeyword">data</span> <span class="org-tree-sitter-hl-faceXtype">FilmClassification</span>
    <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXconstructor">Universal</span>
    <span class="org-tree-sitter-hl-faceXoperator">|</span> <span class="org-tree-sitter-hl-faceXconstructor">ParentalGuidance</span>
    <span class="org-tree-sitter-hl-faceXoperator">|</span> <span class="org-tree-sitter-hl-faceXconstructor">Suitable12</span>
    <span class="org-tree-sitter-hl-faceXoperator">|</span> <span class="org-tree-sitter-hl-faceXconstructor">Suitable15</span>
    <span class="org-tree-sitter-hl-faceXoperator">|</span> <span class="org-tree-sitter-hl-faceXconstructor">Adults</span>
    <span class="org-tree-sitter-hl-faceXoperator">|</span> <span class="org-tree-sitter-hl-faceXconstructor">Restricted18</span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXkeyword">stock</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Bounded</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Eq</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Ord</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Monoid</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Semigroup</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXkeyword">via</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Supremum</span> <span class="org-tree-sitter-hl-faceXtype">FilmClassification</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org698756b" class="outline-2">
<h2 id="org698756b">Composing by deriving</h2>
<div class="outline-text-2" id="text-org698756b">
<p>
First let's write up a silly class for writing to <code>stdout</code>, a single operation will do.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">class</span> <span class="org-tree-sitter-hl-faceXtype">Monad</span> <span class="org-tree-sitter-hl-faceXtype">m</span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtype">StdoutWriter</span> <span class="org-tree-sitter-hl-faceXtype">m</span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXtype"><span class="org-tree-sitter-hl-faceXvariable">writeStdoutLn</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">String</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtype">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
</pre>
</div>

<p>
Then we'll need a type to attach the implementation to.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">newtype</span> <span class="org-tree-sitter-hl-faceXtype">SimpleStdoutWriter</span> <span class="org-tree-sitter-hl-faceXtype">m</span> <span class="org-tree-sitter-hl-faceXtype">a</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXconstructor">SimpleStdoutWriter</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">m</span> <span class="org-tree-sitter-hl-faceXtype">a</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Functor</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Applicative</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Monad</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>

<p>
and of course an implementation
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">instance</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span> <span class="org-tree-sitter-hl-faceXtype">m</span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtype">StdoutWriter</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">SimpleStdoutWriter</span> <span class="org-tree-sitter-hl-faceXtype">m</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXfunction"><span class="org-tree-sitter-hl-faceXvariable">writeStdoutLn</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXfunction"><span class="org-tree-sitter-hl-faceXvariable">liftIO</span></span> <span class="org-tree-sitter-hl-faceXoperator">.</span> <span class="org-tree-sitter-hl-faceXfunction"><span class="org-tree-sitter-hl-faceXvariable">putStrLn</span></span>
</pre>
</div>

<p>
Now let's create an app environment based on <code>ReaderT</code> and use <code>deriving via</code> to
give it an implementation of <code>StdoutWriter</code> via <code>SimpleStdoutWriter</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">newtype</span> <span class="org-tree-sitter-hl-faceXtype">AppEnv</span> <span class="org-tree-sitter-hl-faceXtype">a</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXconstructor">AppEnv</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">{</span></span><span class="org-tree-sitter-hl-faceXvariable">unAppEnv</span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">ReaderT</span> <span class="org-tree-sitter-hl-faceXtype">Int</span> <span class="org-tree-sitter-hl-faceXtype">IO</span> <span class="org-tree-sitter-hl-faceXtype">a</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">}</span></span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span>
        <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span> <span class="org-tree-sitter-hl-faceXtype">Functor</span>
        <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Applicative</span>
        <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Monad</span>
        <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span>
        <span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">MonadReader</span> <span class="org-tree-sitter-hl-faceXtype">Int</span>
        <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">StdoutWriter</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXkeyword">via</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">SimpleStdoutWriter</span> <span class="org-tree-sitter-hl-faceXtype">AppEnv</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>

<p>
Then a quick test to show that it actually works.
</p>

<div class="org-src-container">
<pre class="src src-ghci">λ&gt; runReaderT (unAppEnv $ writeStdoutLn "hello, world!") 0
hello, world!
</pre>
</div>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-monad_transformers.html">monad_transformers</a> </div>

<div class="post-date">21 Aug 2022</div><h1 class="post-title"><a href="https://magnus.therning.org/2022-08-21-patching-in-nix.html">Patching in Nix</a></h1>
<p>
Today I wanted to move one of my Haskell projects to GHC 9.2.4 and found that
<a href="https://hackage.haskell.org/package/envy-2.1.0.0">envy</a> didn't compile due to an upper bound on its dependency on <code>bytestring</code>, it
didn't allow <code>0.11.*</code>.
</p>

<p>
After creating a <a href="https://github.com/dmjio/envy/pull/49">PR</a> I decided I didn't want to wait for upstream so instead I
started looking into options for patching the source of a derivation of a
package from Hackage. In the past I've written about building <a href="https://magnus.therning.org/2020-11-30-1734-haskell__nix_and_using_packages_from_github.html">Haskell packages
from GitHub</a> and an older one were I used <code>callHackageDirect</code> to build <a href="https://magnus.therning.org/2020-02-02-000-my-ghcide-build-for-nix.html">Haskell
packages from Hackage</a>. I wasn't sure how to patch up a package from Hackage
though, but after a bit of digging through <a href="https://github.com/NixOS/nixpkgs/tree/master/pkgs/development/haskell-modules">haskell-modules</a> I found <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/lib/default.nix#L194">appendPatch</a>.
</p>

<p>
The patch wasn't too hard to put together once I recalled the name of the patch
queue tool I used regularly years ago, <a href="https://savannah.nongnu.org/projects/quilt/">quilt</a>. I put the resulting patch in the
<code>nix</code> folder I already had, and the full override ended up looking like this
</p>

<div class="org-src-container">
<pre class="src src-nix">...
<span class="org-nix-attribute">hl</span> = haskell.lib;
<span class="org-nix-attribute">hsPkgs</span> = haskell.packages.ghc924;

<span class="org-nix-attribute">extraHsPkgs</span> = hsPkgs.override <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">overrides</span> = self: super: <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-nix-attribute">envy</span> = hl.appendPatch <span class="org-rainbow-delimiters-depth-3">(</span>self.callHackageDirect <span class="org-rainbow-delimiters-depth-4">{</span>
      <span class="org-nix-attribute">pkg</span> = <span class="org-string">"envy"</span>;
      <span class="org-nix-attribute">ver</span> = <span class="org-string">"2.1.0.0"</span>;
      <span class="org-nix-attribute">sha256</span> =
        <span class="org-string">"sha256-yk8ARRyhTf9ImFJhDnVwaDiEQi3Rp4yBvswsWVVgurg="</span>;
    <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-4">{</span> <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-nix-constant">./nix/envy-fix-deps.patch</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
...
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>

<div class="post-date">08 May 2022</div><h1 class="post-title"><a href="https://magnus.therning.org/2022-05-08-a-little-haskell:-epoch-timestamp.html">A little Haskell: epoch timestamp</a></h1>
<p>
A need of getting the current <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX time</a> is something that comes up every now and
then. Just this week I needed it in order to add a <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-liveness-command">k8s liveness probe</a><sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.
</p>

<p>
While it's often rather straight forward to get the Unix time as an integer in
other languages<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>, in Haskell there's a bit of type tetris involved.
</p>


<ol class="org-ol">
<li><a href="https://hoogle.haskell.org/?hoogle=getPOSIXTime&amp;scope=set%3Astackage">getPOSIXTime</a> gives me a <a href="https://hoogle.haskell.org/?hoogle=POSIXTime&amp;scope=set%3Astackage">POSIXTime</a>, which is an alias for <a href="https://hoogle.haskell.org/?hoogle=NominalDiffTime&amp;scope=set%3Astackage">NominalDiffTime</a>.</li>
<li><code>NominalDiffTime</code> implements <a href="https://hoogle.haskell.org/?hoogle=RealFrac&amp;scope=set%3Astackage">RealFrac</a> and can thus be converted to anything
implementing <a href="https://hoogle.haskell.org/?hoogle=Integral&amp;scope=set%3Astackage">Integral</a> (I wanted it as <code>Int64</code>).</li>
<li><code>NominalDiffTime</code> also implements <a href="https://hoogle.haskell.org/?hoogle=Num&amp;scope=set%3Astackage">Num</a>, so if the timestamp needs better
precision than seconds it's easy to do (I needed milliseconds).</li>
</ol>


<p>
The combination of the above is something like
</p>

<div class="org-src-container">
<pre class="src src-haskell">truncate <span class="org-haskell-definition">&lt;$&gt;</span> getPOSIXTime
</pre>
</div>

<p>
In my case the full function of writing the timestamp to a file looks like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">writeTimestampFile</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Path</span> <span class="org-haskell-type">Abs</span> <span class="org-haskell-type">File</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">writeTimestampFile</span> afn <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    truncate <span class="org-haskell-operator">@</span><span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">@</span><span class="org-haskell-constructor">Int64</span> <span class="org-haskell-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">*</span> <span class="org-highlight-numbers-number">1000</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;$&gt;</span> getPOSIXTime <span class="org-haskell-operator">&gt;&gt;=</span> writeFile <span class="org-rainbow-delimiters-depth-1">(</span>fromAbsFile afn<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">.</span> show
</pre>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Over the last few days I've looked into <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">k8s probes</a>. Since we're using
<a href="https://istio.io/latest/">Istio</a> TCP probes are of very <a href="https://github.com/istio/istio/pull/28737#pullrequestreview-535660318">limited use</a>, and as the service in question doesn't
offer an HTTP API I decided to use a liveness command that checks that the
contents of a file is a sufficiently recent epoch timestamp.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Rust's Chrono package has <a href="https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html#method.timestamp">Utc.timestamp(t)</a>. Python has <a href="https://docs.python.org/3/library/time.html?highlight=time%20time#time.time">time.time()</a>.
Golang has <a href="https://pkg.go.dev/time#Time.Unix">Time.Unix</a>.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-k8s.html">k8s</a> </div>

<div class="post-date">13 Mar 2022</div><h1 class="post-title"><a href="https://magnus.therning.org/2022-03-13-simple-nix-flake-for-haskell-development.html">Simple nix flake for Haskell development</a></h1>
<p>
Recently I've moved over to using <a href="https://nixos.wiki/wiki/Flakes">flakes</a> in my Haskell development projects. It
took me a little while to arrive at a pattern a flake for Haskell development
that I like. I'm hoping sharing it might help others when doing the same change
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">inputs</span> = <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-nix-attribute">nixpkgs.url</span> = <span class="org-string">"github:nixos/nixpkgs"</span>;
    <span class="org-nix-attribute">flake-utils.url</span> = <span class="org-string">"github:numtide/flake-utils"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>;

  <span class="org-nix-attribute">outputs</span> = <span class="org-rainbow-delimiters-depth-2">{</span> self, nixpkgs, flake-utils <span class="org-rainbow-delimiters-depth-2">}</span>:
    flake-utils.lib.eachDefaultSystem <span class="org-rainbow-delimiters-depth-2">(</span>system:
      <span class="org-nix-keyword">with</span> nixpkgs.legacyPackages.$<span class="org-rainbow-delimiters-depth-3">{</span>system<span class="org-rainbow-delimiters-depth-3">}</span>;
      <span class="org-nix-keyword">let</span>
        <span class="org-nix-attribute">t</span> = lib.trivial;
        <span class="org-nix-attribute">hl</span> = haskell.lib;

        <span class="org-nix-attribute">name</span> = <span class="org-string">"project-name"</span>;

        <span class="org-nix-attribute">project</span> = devTools: <span class="org-comment"># [1]</span>
          <span class="org-nix-keyword">let</span> <span class="org-nix-attribute">addBuildTools</span> = <span class="org-rainbow-delimiters-depth-3">(</span>t.flip hl.addBuildTools<span class="org-rainbow-delimiters-depth-3">)</span> devTools;
          <span class="org-nix-keyword">in</span> haskellPackages.developPackage <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-nix-attribute">root</span> = lib.sourceFilesBySuffices <span class="org-nix-constant">./.</span> <span class="org-rainbow-delimiters-depth-4">[</span> <span class="org-string">".cabal"</span> <span class="org-string">".hs"</span> <span class="org-rainbow-delimiters-depth-4">]</span>;
            <span class="org-nix-attribute">name</span> = name;
            <span class="org-nix-attribute">returnShellEnv</span> = !<span class="org-rainbow-delimiters-depth-4">(</span>devTools == <span class="org-rainbow-delimiters-depth-5">[</span> <span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-comment"># [2]</span>

            <span class="org-nix-attribute">modifier</span> = <span class="org-rainbow-delimiters-depth-4">(</span>t.flip t.pipe<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">[</span>
              addBuildTools
              hl.dontHaddock
              hl.enableStaticLibraries
              hl.justStaticExecutables
              hl.disableLibraryProfiling
              hl.disableExecutableProfiling
            <span class="org-rainbow-delimiters-depth-4">]</span>;
          <span class="org-rainbow-delimiters-depth-3">}</span>;

      <span class="org-nix-keyword">in</span> <span class="org-rainbow-delimiters-depth-3">{</span>
        <span class="org-nix-attribute">packages.pkg</span> = project <span class="org-rainbow-delimiters-depth-4">[</span> <span class="org-rainbow-delimiters-depth-4">]</span>; <span class="org-comment"># [3]</span>

        <span class="org-nix-attribute">defaultPackage</span> = self.packages.$<span class="org-rainbow-delimiters-depth-4">{</span>system<span class="org-rainbow-delimiters-depth-4">}</span>.pkg;

        <span class="org-nix-attribute">devShell</span> = project <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-nix-keyword">with</span> haskellPackages; <span class="org-rainbow-delimiters-depth-5">[</span> <span class="org-comment"># [4]</span>
          cabal-fmt
          cabal-install
          haskell-language-server
          hlint
        <span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The main issue I ran into is getting a development shell out of
<code>haskellPackages.developPackage</code>, it requires <code>returnShellEnv</code> to be <code>true</code>.
Something that isn't too easy to find out. This means that the only solution
I've found to getting a development shell is to have separate expressions for
building and getting a shell. In the above flake the build expression, <i>[3]</i>,
passes an empty list of development tools, the argument <code>devTools</code> at <i>[1]</i>,
while the development shell expression, <i>[4]</i>, passes in a list of tools needed
for development only. The decision of whether the expression is for building or
for a development shell, <i>[2]</i>, then looks at the list of development tools
passed in.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>
<div class="post-date">27 Nov 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-11-27-fallback-of-actions.html">Fallback of actions</a></h1>
<p>
In a tool I'm writing I want to load a file that may reside on the local disk,
but if it isn't there I want to fetch it from the web. Basically it's very
similar to having a cache and dealing with a miss, except in my case I don't
populate the cache.
</p>

<p>
Let me first define the functions to play with
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">loadFromDisk</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">loadFromDisk</span> k<span class="org-haskell-operator">@</span><span class="org-string">"bad key"</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"local: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
    pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Left</span> <span class="org-haskell-operator">$</span> <span class="org-string">"no such local key: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
<span class="org-haskell-definition">loadFromDisk</span> k <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"local: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
    pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">$</span> length k

<span class="org-haskell-definition">loadFromWeb</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">loadFromWeb</span> k<span class="org-haskell-operator">@</span><span class="org-string">"bad key"</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"web: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
    pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Left</span> <span class="org-haskell-operator">$</span> <span class="org-string">"no such remote key: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
<span class="org-haskell-definition">loadFromWeb</span> k <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"web: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
    pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">$</span> length k
</pre>
</div>

<div id="outline-container-org06d71ff" class="outline-2">
<h2 id="org06d71ff">Discarded solution: using the <code>Alternative</code> of <code>IO</code> directly</h2>
<div class="outline-text-2" id="text-org06d71ff">
<p>
It's fairly easy to get the desired behaviour but <code>Alternative</code> of <code>IO</code> is based
on exceptions which doesn't strike me as a good idea unless one is using <code>IO</code>
directly. That is fine in a smallish application, but in my case it makes sense
to use tagless style (or <code>ReaderT</code> pattern) so I'll skip exploring this option
completely.
</p>
</div>
</div>

<div id="outline-container-org393493a" class="outline-2">
<h2 id="org393493a">First attempt: lifting into the <code>Alternative</code> of <code>Either e</code></h2>
<div class="outline-text-2" id="text-org393493a">
<p>
There's an instance of <code>Alternative</code> for <code>Either e</code> in version 0.5 of
<a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Error.html#section.orphans">transformers</a>. It's deprecated and it's gone in newer versions of the library as
one really should use <code>Except</code> or <code>ExceptT</code> instead. Even if I don't think it's
where I want to end up, it's not an altogether bad place to start.
</p>

<p>
Now let's define a function using <code>liftA2 (&lt;|&gt;)</code> to make it easy to see what the
behaviour is
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">::</span>
    <span class="org-haskell-type">Applicative</span> m <span class="org-haskell-operator">=&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> res<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">=</span> liftA2 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">&lt;|&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example" id="orgfc4f34e">
λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "good key"
local: bad key
web: good key
Right 8

λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "bad key"
local: bad key
web: bad key
Left "no such remote key: bad key"
</pre>

<p>
The first example shows that it falls back to loading form the web, and the
second one shows that it's only the last failure that survives. The latter part,
that only the last failure survives, isn't ideal but I think I can live with
that. If I were interested in collecting all failures I would reach for
<code>Validation</code> from <a href="https://hackage.haskell.org/package/validation-selective"><code>validation-selective</code></a> (there's one in <a href="https://hackage.haskell.org/package/validation-selective"><code>validation</code></a> that
should work too).
</p>

<p>
So far so good, but the next example shows a behaviour I don't want
</p>

<pre class="example" id="orgfe77c40">
λ&gt; loadFromDisk "good key" `fallBack` loadFromWeb "good key"
local: good key
web: good key
Right 8
</pre>

<p>
or to make it even more explicit
</p>

<pre class="example" id="org0b4b72a">
λ&gt; loadFromDisk "good key" `fallBack` undefined
local: good key
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err
  undefined, called at &lt;interactive&gt;:451:36 in interactive:Ghci4
</pre>

<p>
There's no short-circuiting!<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<p>
The behaviour I want is of course that if the first action is successful, then
the second action shouldn't take place at all.
</p>

<p>
It looks like either <code>&lt;|&gt;</code> is strict in its second argument, or maybe it's
<code>liftA2</code> that forces it. I've not bothered digging into the details, it's enough
to observe it to realise that this approach isn't good enough.
</p>
</div>
</div>

<div id="outline-container-second-attempt" class="outline-2">
<h2 id="second-attempt">Second attempt: cutting it short, manually</h2>
<div class="outline-text-2" id="text-second-attempt">
<p>
Fixing the lack of short-circuiting the evaluation after the first success isn't
too difficult to do manually. Something like this does it
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">::</span>
    <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">fallBack</span> first other <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    first <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
        r<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Right</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> pure r
        r<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Left</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>r <span class="org-haskell-operator">&lt;|&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;$&gt;</span> other
</pre>
</div>

<p>
It does indeed show the behaviour I want
</p>

<pre class="example" id="org3813a45">
λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "good key"
local: bad key
web: good key
Right 8

λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "bad key"
local: bad key
web: bad key
Left "no such remote key: bad key"

λ&gt; loadFromDisk "good key" `fallBack` undefined
local: good key
Right 8
</pre>

<p>
Excellent! And to switch over to use <code>Validation</code> one just have to switch
constructors, <code>Right</code> becomes <code>Success</code> and <code>Left</code> becomes <code>Failure</code>. Though
collecting the failures by concatenating strings isn't the best idea of course.
Switching to some other <code>Monoid</code> (that's the constraint on the failure type)
isn't too difficult.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">::</span>
    <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Monad</span> m, <span class="org-haskell-type">Monoid</span> e<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Validation</span> e a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Validation</span> e a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Validation</span> e a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">fallBack</span> first other <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    first <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
        r<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Success</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> pure r
        r<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Failure</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>r <span class="org-haskell-operator">&lt;|&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;$&gt;</span> other
</pre>
</div>
</div>
</div>

<div id="outline-container-org5d3ae21" class="outline-2">
<h2 id="org5d3ae21">Third attempt: pulling failures out to <code>MonadPlus</code></h2>
<div class="outline-text-2" id="text-org5d3ae21">
<p>
After writing the <code>fallBack</code> function I still wanted to explore other solutions.
There's almost always something more out there in the Haskell eco system, right?
So I asked in the <i>#haskell-beginners</i> channel on the Functional Programming
Slack. The way I asked the question resulted in answers that iterates over a
list of actions and cutting at the first success.
</p>

<p>
The first suggestion had me a little confused at first, but once I re-organised
the helper function a little it made more sense to me.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mFromRight</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadPlus</span> m <span class="org-haskell-operator">=&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> m res
<span class="org-haskell-definition">mFromRight</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>either <span class="org-rainbow-delimiters-depth-2">(</span>const mzero<span class="org-rainbow-delimiters-depth-2">)</span> return <span class="org-haskell-operator">=&lt;&lt;</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
To use it put the actions in a list, map the helper above, and finally run
<code>asum</code> on it all<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>. I think it makes it a little clearer what happens if
it's rewritten like this.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">firstRightM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadPlus</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>m <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> m res
<span class="org-haskell-definition">firstRightM</span> <span class="org-haskell-operator">=</span> asum <span class="org-haskell-operator">.</span> fmap go
  <span class="org-haskell-keyword">where</span>
    go m <span class="org-haskell-operator">=</span> m <span class="org-haskell-operator">&gt;&gt;=</span> either <span class="org-rainbow-delimiters-depth-1">(</span>const mzero<span class="org-rainbow-delimiters-depth-1">)</span> return
</pre>
</div>

<pre class="example" id="orgc0d84cf">
λ&gt; firstRightM [loadFromDisk "bad key", loadFromWeb "good key"]
local: bad key
web: good key
8

λ&gt; firstRightM [loadFromDisk "good key", undefined]
local: good key
8
</pre>

<p>
So far so good, but I left out the case where both fail, because that's sort of
the fly in the ointment here
</p>

<pre class="example" id="org9b2d311">
λ&gt; firstRightM [loadFromDisk "bad key", loadFromWeb "bad key"]
local: bad key
web: bad key
*** Exception: user error (mzero)
</pre>

<p>
It's not nice to be back to deal with exceptions, but it's possible to recover,
e.g. by appending <code>&lt;|&gt; pure 0</code>.
</p>

<pre class="example" id="org1198c83">
λ&gt; firstRightM [loadFromDisk "bad key", loadFromWeb "bad key"] &lt;|&gt; pure 0
local: bad key
web: bad key
0
</pre>

<p>
However that removes the ability to deal with the situation where all actions
fail. Not nice! Add to that the difficulty of coming up with a <i>good</i>
<code>MonadPlus</code> instance for an application monad; one basically have to resort to
the same thing as for <code>IO</code>, i.e. to throw an exception. Also not nice!
</p>
</div>
</div>

<div id="outline-container-fourth-attempt" class="outline-2">
<h2 id="fourth-attempt">Fourth attempt: wrapping in <code>ExceptT</code> to get its <code>Alternative</code> behaviour</h2>
<div class="outline-text-2" id="text-fourth-attempt">
<p>
This was another suggestion from the Slack channel, and it is the one I like the
most. Again it was suggested as a way to stop at the first successful action in
a list of actions.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">firstRightM</span> <span class="org-haskell-operator">::</span>
    <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Foldable</span> t, <span class="org-haskell-type">Functor</span> t, <span class="org-haskell-type">Monad</span> m, <span class="org-haskell-type">Monoid</span> err<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span>
    t <span class="org-rainbow-delimiters-depth-1">(</span>m <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">firstRightM</span> <span class="org-haskell-operator">=</span> runExceptT <span class="org-haskell-operator">.</span> asum <span class="org-haskell-operator">.</span> fmap <span class="org-haskell-constructor">ExceptT</span>
</pre>
</div>

<p>
Which can be used similarly to the previous one. It's also easy to write a
variant of <code>fallBack</code> for it.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">::</span>
    <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Monad</span> m, <span class="org-haskell-type">Monoid</span> err<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">fallBack</span> first other <span class="org-haskell-operator">=</span> runExceptT <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">ExceptT</span> first <span class="org-haskell-operator">&lt;|&gt;</span> <span class="org-haskell-constructor">ExceptT</span> other
</pre>
</div>

<pre class="example" id="orgb08a34f">
λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "good key"
local: bad key
web: good key
Right 8

λ&gt; loadFromDisk "good key" `fallBack` undefined
local: good key
Right 8

λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "bad key"
local: bad key
web: bad key
Left "no such local key: bad keyno such remote key: bad key"
</pre>

<p>
Yay! This solution has the short-circuiting behaviour I want, as well as
collecting all errors on failure.
</p>
</div>
</div>

<div id="outline-container-org63037a5" class="outline-2">
<h2 id="org63037a5">Conclusion</h2>
<div class="outline-text-2" id="text-org63037a5">
<p>
I'm still a little disappointed that <code>liftA2 (&lt;|&gt;)</code> isn't short-circuiting as I
still think it's the easiest of the approaches. However, it's a problem that one
has to rely on a deprecated instance of <code>Alternative</code> for <code>Either String</code>,
but switching to use <code>Validation</code> would be only a minor change.
</p>

<p>
Manually writing the <code>fallBack</code> function, as I did in the <a href="#second-attempt">second attempt</a>,
results in very explicit code which is nice as it often reduces the cognitive
load for the reader. It's a contender, but using the deprecated <code>Alternative</code>
instance is problematic and introducing <code>Validition</code>, an arguably not very
common type, takes away a little of the appeal.
</p>

<p>
In the end I prefer the <a href="#fourth-attempt">fourth attempt</a>. It behaves exactly like I want and even
though <code>ExpectT</code> lives in <i>transformers</i> I feel that it (I pull it in via <i>mtl</i>)
is in such wide use that most Haskell programmers will be familiar with it.
</p>

<p>
One final thing to add is that the <a href="https://hackage.haskell.org/package/validation-selective-0.1.0.1/docs/Validation.html">documentation of <code>Validation</code></a> is an excellent
inspiration when it comes to the behaviour of its instances. I wish that the
documentation of other packages, in particular commonly used ones like <i>base</i>,
<i>transformers</i>, and <i>mtl</i>, would be more like it.
</p>
</div>
</div>

<div id="outline-container-org1914c53" class="outline-2">
<h2 id="org1914c53">Comments, feedback, and questions</h2>
<div class="outline-text-2" id="text-org1914c53">
</div>
<div id="outline-container-org5082aab" class="outline-3">
<h3 id="org5082aab"><span class="timestamp-wrapper"><span class="timestamp">[2021-11-28 Sun] </span></span> Dustin Sallings</h3>
<div class="outline-text-3" id="text-org5082aab">
<div class="notes" id="org1f46424">
<p>
Dustin sent me a comment via email a while ago, it's now March 2022 so it's
taken me embarrassingly long to publish it here.
</p>

<p>
I removed a bit from the beginning of the email as it doesn't relate to this
post.
</p>

</div>

<p>
&#x2026; a thing I've written code for before that I was reasonably pleased with. I
have a suite of software for managing my GoPro media which involves doing some
metadata extraction from images and video. There will be multiple transcodings
of each medium with each that contains the metadata having it completely intact
(i.e., low quality encodings do not lose metadata fidelity). I also run this on
multiple machines and store a cache of Metadata in S3.
</p>

<p>
Sometimes, I've already processed the metadata on another machine. Often, I can
get it from the lowest quality. Sometimes, there's no metadata at all. The core
of my extraction looks like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell">ms <span class="org-haskell-operator">&lt;-</span> asum <span class="org-rainbow-delimiters-depth-1">[</span>
  <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">.</span> BL.toStrict <span class="org-haskell-operator">&lt;$&gt;</span> getMetaBlob mid,
  fv <span class="org-string">"mp4_low"</span> <span class="org-rainbow-delimiters-depth-2">(</span>fn <span class="org-string">"low"</span><span class="org-rainbow-delimiters-depth-2">)</span>,
  fv <span class="org-string">"high_res_proxy_mp4"</span> <span class="org-rainbow-delimiters-depth-2">(</span>fn <span class="org-string">"high"</span><span class="org-rainbow-delimiters-depth-2">)</span>,
  fv <span class="org-string">"source"</span> <span class="org-rainbow-delimiters-depth-2">(</span>fn <span class="org-string">"src"</span><span class="org-rainbow-delimiters-depth-2">)</span>,
  pure <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
The first version grabs the processed blob from S3. The next three fetch (and
process) increasingly larger variants of the uploaded media. The last one just
gives up and says there's no metadata available (and memoizes that in the local
DB and S3).
</p>

<p>
Some of these objects are in the tens of gigs, and I had a really bad internet
connection when I first wrote this software, so I needed it to work.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I'm not sure if it's a good term to use in this case as <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">Wikipedia</a> says
it's for Boolean operators. I hope it's not too far a stretch to use it in this
context too.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
In the version of <i>base</i> I'm using there is no <code>asum</code>, so I simply copied
the implementation from a later version:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">asum</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Foldable</span> t, <span class="org-haskell-type">Alternative</span> f<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> t <span class="org-rainbow-delimiters-depth-1">(</span>f a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> f a
<span class="org-haskell-definition">asum</span> <span class="org-haskell-operator">=</span> foldr <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">&lt;|&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> empty
</pre>
</div></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-alternative_typeclass.html">alternative_typeclass</a> <a href="https://magnus.therning.org/tag-caching.html">caching</a> <a href="https://magnus.therning.org/tag-fallback.html">fallback</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>
<div class="post-date">28 Sep 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-09-28-using-lens-to-set-a-value-based-on-another.html">Using lens to set a value based on another</a></h1>
<p>
I started writing a small tool for work that consumes YAML files and combines
the data into a single YAML file. To be specific it consumes YAML files
containing snippets of service specification for <a href="https://docs.docker.com/compose/">Docker Compose</a> and it produces
a YAML file for use with <code>docker-compose</code>. Besides being useful to me, I thought
it'd also be a good way to get some experience with <a href="https://hackage.haskell.org/package/lens">lens</a>.
</p>

<p>
The first transformation I wanted to write was one that puts in the correct
image name. So, only slightly simplified, it is transforming
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span class="org-variable-name">panda</span>:
    <span class="org-variable-name">x-image</span>: panda
<span class="org-variable-name">goat</span>:
    <span class="org-variable-name">x-image</span>: goat
<span class="org-variable-name">tapir</span>:
    <span class="org-variable-name">image</span>: incorrent
    <span class="org-variable-name">x-image</span>: tapir
</pre>
</div>

<p>
into
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span class="org-variable-name">panda</span>:
    <span class="org-variable-name">image</span>: panda:latest
    <span class="org-variable-name">x-image</span>: panda
<span class="org-variable-name">goat</span>:
    <span class="org-variable-name">image</span>: goat:latest
    <span class="org-variable-name">x-image</span>: goat
<span class="org-variable-name">tapir</span>:
    <span class="org-variable-name">image</span>: tapir:latest
    <span class="org-variable-name">x-image</span>: tapir
</pre>
</div>

<p>
That is, it creates a new key/value pair in each object based on the value of
<code>x-image</code> in the same object.
</p>

<div id="outline-container-org3bb936a" class="outline-2">
<h2 id="org3bb936a">First approach</h2>
<div class="outline-text-2" id="text-org3bb936a">
<p>
The first approach I came up with was to traverse the sub-objects and apply a
function that adds the <code>image</code> key.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">setImage</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">setImage</span> y <span class="org-haskell-operator">=</span> y <span class="org-haskell-operator">&amp;</span> members <span class="org-haskell-operator">%~</span> setImg
  <span class="org-haskell-keyword">where</span>
    setImg o <span class="org-haskell-operator">=</span>
        o
            <span class="org-haskell-operator">&amp;</span> _Object <span class="org-haskell-operator">.</span> at <span class="org-string">"image"</span>
            <span class="org-haskell-operator">?~</span> <span class="org-haskell-constructor">String</span> <span class="org-rainbow-delimiters-depth-1">(</span>o <span class="org-haskell-operator">^.</span> key <span class="org-string">"x-image"</span> <span class="org-haskell-operator">.</span> _String <span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">":latest"</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
It did make me wonder if this kind of problem, setting a value based on another
value, isn't so common that there's a nicer solution to it. Perhaps coded up in
a combinator that isn't mentioned in <a href="https://leanpub.com/optics-by-example">Optics By Example</a> (or mabye I've forgot it
was mentioned). That lead me to ask around a bit, which leads to approach two.
</p>
</div>
</div>

<div id="outline-container-orgf55f462" class="outline-2">
<h2 id="orgf55f462">Second approach</h2>
<div class="outline-text-2" id="text-orgf55f462">
<p>
Arguably there isn't much difference, it's still traversing the sub-objects and
applying a function. The function makes use of <code>view</code> being run in a monad and
<code>ASetter</code> being defined with <code>Identity</code> (a monad).
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">setImage'</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">setImage'</span> y <span class="org-haskell-operator">=</span>
    y
        <span class="org-haskell-operator">&amp;</span> members <span class="org-haskell-operator">.</span> _Object
        <span class="org-haskell-operator">%~</span> <span class="org-rainbow-delimiters-depth-1">(</span>set <span class="org-rainbow-delimiters-depth-2">(</span>at <span class="org-string">"image"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">.</span> <span class="org-rainbow-delimiters-depth-2">(</span>_Just <span class="org-haskell-operator">.</span> _String <span class="org-haskell-operator">%~</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">":latest"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&lt;&lt;</span> view <span class="org-rainbow-delimiters-depth-2">(</span>at <span class="org-string">"x-image"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I haven't made up my mind on whether I like this better than the first. It's
disappointingly similar to the first one.
</p>
</div>
</div>

<div id="outline-container-orge880fe2" class="outline-2">
<h2 id="orge880fe2">Third approach</h2>
<div class="outline-text-2" id="text-orge880fe2">
<p>
Then I it might be nice to split the fetching of <code>x-image</code> values from the
addition of <code>image</code> key/value pairs. By extracting with an index it's possible
to keep track of what sub-object each <code>x-image</code> value comes from. Then two steps
can be combined using <code>foldl</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">setImage''</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">setImage''</span> y <span class="org-haskell-operator">=</span> foldl setOne y vals
  <span class="org-haskell-keyword">where</span>
    vals <span class="org-haskell-operator">=</span> y <span class="org-haskell-operator">^@..</span> members <span class="org-haskell-operator">&lt;.</span> key <span class="org-string">"x-image"</span> <span class="org-haskell-operator">.</span> _String
    setOne y' <span class="org-rainbow-delimiters-depth-1">(</span>objKey, value<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span>
        y'
            <span class="org-haskell-operator">&amp;</span> key objKey <span class="org-haskell-operator">.</span> _Object <span class="org-haskell-operator">.</span> at <span class="org-string">"image"</span>
            <span class="org-haskell-operator">?~</span> <span class="org-haskell-constructor">String</span> <span class="org-rainbow-delimiters-depth-1">(</span>value <span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">":latest"</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I'm not convinced though. I guess I'm still holding out for a brilliant
combinator that fits my problem perfectly.
</p>

<p>
Please point me to "the perfect solution" if you have one, or if you just have
some general tips on optics that would make my code clearer, or shorter, or more
elegant, or maybe just more lens-y.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-lens.html">lens</a> <a href="https://magnus.therning.org/tag-optics.html">optics</a> </div>
<div class="post-date">03 Jul 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-07-03-the-timeout-manager-exception.html">The timeout manager exception</a></h1>
<p>
The other day I bumped the dependencies of a Haskell project at work and noticed
a new exception being thrown:
</p>

<blockquote>
<p>
Thread killed by timeout manager
</p>
</blockquote>

<p>
After a couple of false starts (it wasn't the <a href="https://hackage.haskell.org/package/resource-pool">connection pool</a>, nor was it
<a href="https://hackage.haskell.org/package/servant">servant</a>) I realised that a better approach would be to look at the list of
packages that were updated as part of the dependency bumping.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> Most of them
I thought would be <span class="underline">very</span> unlikely sources of it, but two in the list stood out:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Package</th>
<th scope="col" class="org-right">Pre</th>
<th scope="col" class="org-right">Post</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="https://hackage.haskell.org/package/unliftio">unliftio</a></td>
<td class="org-right">0.2.14</td>
<td class="org-right">0.2.18</td>
</tr>

<tr>
<td class="org-left"><a href="https://hackage.haskell.org/package/warp">warp</a></td>
<td class="org-right">3.3.15</td>
<td class="org-right">3.3.16</td>
</tr>
</tbody>
</table>

<p>
<code>warp</code> since the exception seemed to be thrown shortly after handling an HTTP
request, and <code>unliftio</code> since the exception was caught by the handler for
uncaught exceptions and its description contains "thread". Also, when looking at
the code changes in <code>warp</code> on GitHub<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> I found that some of the changes
introduced was increased use of <code>unliftio</code> for async stuff. The changes contain
mentions of <code>TimeoutThread</code> and <code>System.TimeManager</code>. That sounded promising,
and it lead me to the <a href="https://hackage.haskell.org/package/time-manager-0.0.0/docs/System-TimeManager.html#t:TimeoutThread">TimeoutThread</a> exception in <a href="https://hackage.haskell.org/package/time-manager">time-manager</a>.
</p>

<p>
With that knowledge I could quickly adjust the handler for uncaught exceptions
to not log <code>TimeoutThread</code> as fatal:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">lastExceptionHandler</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">SomeException</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">lastExceptionHandler</span> logger e
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-constructor">TimeoutThread</span> <span class="org-haskell-operator">&lt;-</span> fromException e <span class="org-haskell-operator">=</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
  <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      logFatalIoS logger <span class="org-haskell-operator">$</span> pack <span class="org-haskell-operator">$</span> <span class="org-string">"uncaught exception: "</span> <span class="org-haskell-operator">&lt;&gt;</span> displayException e
      flushLogStr logger
</pre>
</div>

<p>
I have to say it was a bit more work to arrive at this than I'd have liked. I
reckon there are easier ways to track down the information I needed. So I'd love
to hear what tricks and tips others have.
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
As a bonus it gave me a good reason to reach for <a href="https://man7.org/linux/man-pages/man1/comm.1.html"><code>comm</code></a>, a command that I
rarely use but for some reason always enjoy.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
GitHub's compare feature isn't very easy to discover, but a URL like this
<a href="https://github.com/yesodweb/wai/compare/warp-3.3.15...warp-3.3.16">https://github.com/yesodweb/wai/compare/warp-3.3.15&#x2026;warp-3.3.16</a> (note the 3
dots!) does the trick.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-warp.html">warp</a> <a href="https://magnus.therning.org/tag-servant.html">servant</a> </div>
<div class="post-date">27 Jun 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-06-27-a-first-look-at-hmock.html">A first look at HMock</a></h1>
<p>
The other day I found Chris Smith's <a href="https://itnext.io/hmock-first-rate-mocks-in-haskell-e59d7c3b066c">HMock: First Rate Mocks in Haskell</a> (<a href="https://hackage.haskell.org/package/HMock">link to
hackage</a>) and thought it could be nice see if it can clear up some of the tests I
have in a few of the Haskell projects at work. All the projects follow the
pattern of defining custom monads for effects (something like final tagless)
with instances implemented on a stack of monads from MTL. It's a pretty standard
thing in Haskell I'd say, especially since the monad stack very often ends up
being <code>ReaderT MyConfig IO</code>.
</p>

<p>
I decided to try it first on a single such custom monad, one for making HTTP
requests:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadHttpClient</span> m <span class="org-haskell-keyword">where</span>
  mHttpGet <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Status</span>, <span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span>
  mHttpPost <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Typeable</span> a, <span class="org-haskell-type">Postable</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Status</span>, <span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Yes, the underlying implementation uses <a href="https://hackage.haskell.org/package/wreq">wreq</a>, but I'm not too bothered by that
shining through. Also, initially I didn't have that <code>Typeable a</code> constraint on
<code>mHttpPost</code>, it got added after a short <a href="https://github.com/cdsmith/HMock/issues/1">exchange about <code>KnownSymbol</code></a> with Chris.
</p>

<p>
To dip a toe in the water I thought I'd simply write tests for the two effects
themselves. First of all there's an impressive list of extensions needed, and
then the monad needs to be made mockable:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE DataKinds #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE GADTs #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE ImportQualifiedPost #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE RankNTypes #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeApplications #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeFamilies #-}</span>

<span class="org-haskell-definition">makeMockable</span> ''<span class="org-haskell-constructor">MonadHttpClient</span>
</pre>
</div>

<p>
After that, writing a test with HMock for <code>mHttpGet</code> was fairly straight
forward, I could simply follow the examples in the package's documentation. I'm
using <a href="https://hackage.haskell.org/package/tasty">tasty</a> for organising the tests though:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">httpGetTest</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">TestTree</span>
<span class="org-haskell-definition">httpGetTest</span> <span class="org-haskell-operator">=</span> testCase <span class="org-string">"Get"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  <span class="org-rainbow-delimiters-depth-1">(</span>s, b<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> runMockT <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    expect <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MHttpGet</span> <span class="org-string">"url"</span> <span class="org-haskell-operator">|-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>status200, <span class="org-string">"result"</span><span class="org-rainbow-delimiters-depth-1">)</span>
    mHttpGet <span class="org-string">"url"</span>
  status200 <span class="org-haskell-operator">@=?</span> s
  <span class="org-string">"result"</span> <span class="org-haskell-operator">@=?</span> b
</pre>
</div>

<p>
The effect for sending a <code>POST</code> request was slightly trickier, as can be seen in
the issue linked above, but with some help I came up with the following:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">httpPostTest</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">TestTree</span>
<span class="org-haskell-definition">httpPostTest</span> <span class="org-haskell-operator">=</span> testCase <span class="org-string">"Post"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  <span class="org-rainbow-delimiters-depth-1">(</span>s, b<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> runMockT <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    expect <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MHttpPost_</span> <span class="org-rainbow-delimiters-depth-1">(</span>eq <span class="org-string">"url"</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>typed <span class="org-haskell-operator">@</span><span class="org-haskell-constructor">ByteString</span> anything<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">|-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>status201, <span class="org-string">"result"</span><span class="org-rainbow-delimiters-depth-1">)</span>
    mHttpPost <span class="org-string">"url"</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span>
  status201 <span class="org-haskell-operator">@=?</span> s
  <span class="org-string">"result"</span> <span class="org-haskell-operator">@=?</span> b
</pre>
</div>

<div id="outline-container-org07a2709" class="outline-2">
<h2 id="org07a2709">Next step</h2>
<div class="outline-text-2" id="text-org07a2709">
<p>
My hope is that using HMock will remove the need for creating a bunch of test
implementations for the various custom monads for effects<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> in the projects,
thereby reducing the amount of test code overall. I also suspect that it will
make the tests clearer and easier to read, as the behaviour of the mocks are
closer to the tests using the mocks.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Basically they could be looked at as hand-written mocks.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> <a href="https://magnus.therning.org/tag-mocks.html">mocks</a> </div>
<div class="post-date">07 May 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-05-07-working-with-hedis.html">Working with Hedis</a></h1>
<p>
I'm now writing the second Haskell service using <a href="https://redis.io/commands/incrby">Redis</a> to store data. There are
a few packages on <a href="https://hackage.haskell.org/">Hackage</a> related to Redis but I only found 2 client libraries,
<a href="https://hackage.haskell.org/package/redis-io">redis-io</a> and <a href="https://hackage.haskell.org/package/hedis">hedis</a>. I must say I like the API of redis-io better, but it breaks
a rule I hold very dear:
</p>

<blockquote>
<p>
Libraries should never log, that's the responsibility of the application.
</p>
</blockquote>

<p>
So, hedis it is. I tried using the API as is, but found it really cumbersome so
looked around and after some inspiration from <a href="https://hackage.haskell.org/package/hedis-simple">hedis-simple</a> I came up with the
following functions.
</p>

<p>
First a wrapper around a Redis function that put everything into <code>ExceptionT</code>
with a function that transforms a <code>reply</code> into an <code>Exception</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">lpush</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Exception</span> e <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Reply</span> <span class="org-haskell-operator">-&gt;</span> e<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ExceptionT</span> <span class="org-haskell-type">Redis</span> <span class="org-haskell-type">Integer</span>
<span class="org-haskell-definition">lpush</span> mapper key element <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ExceptionT</span> <span class="org-haskell-operator">$</span> replyToExc <span class="org-haskell-operator">&lt;$&gt;</span> R.lpush key element
  <span class="org-haskell-keyword">where</span>
    replyToExc <span class="org-haskell-operator">=</span> first <span class="org-rainbow-delimiters-depth-1">(</span>toException <span class="org-haskell-operator">.</span> mapper<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I found wrapping up functions like this is simple, but repetitive.
</p>

<p>
Finally I need a way to run the whole thing and unwrap it all back to <code>IO</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">runRedis</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Connection</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ExceptionT</span> <span class="org-haskell-type">Redis</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">SomeException</span> a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">runRedis</span> conn <span class="org-haskell-operator">=</span> R.runRedis conn <span class="org-haskell-operator">.</span> runExceptionT
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-redis.html">redis</a> </div>
<div class="post-date">21 Apr 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-04-21-first-contribution-to-nixpkgs.haskellpackages.html">First contribution to nixpkgs.haskellPackages</a></h1>
<p>
Nothing much to be proud of, but yesterday I found out that <a href="https://hackage.haskell.org/package/servant-docs">servant-docs</a> was
marked broken in <span class="underline">nixpkgs</span> even though it builds just fine and this morning I
decided to do something about it.
</p>

<p>
So, with the help of a <a href="https://discourse.nixos.org/t/call-to-action-for-updating-haskell-packages-after-bump-to-lts-15/6071">post on the NixOS discourse</a> I put together my first <a href="https://github.com/NixOS/nixpkgs/pull/120026">PR</a>.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-nix.html">nix</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>
<div class="post-date">20 Mar 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-03-20-barbie-and-json.html">Barbie and <strike>Ken</strike>JSON</a></h1>
<p>
After higher-kinded data (HKD) and <a href="https://hackage.haskell.org/package/barbies">barbies</a> were mentioned in <a href="https://haskellweekly.news/episode/35.html">episode 35 of
Haskell Weekly</a> I've been wondering if it could be used in combination with <a href="https://hackage.haskell.org/package/aeson">aeson</a>
to do validation when implementing web services.
</p>

<p>
TLDR; I think it'd work, but I have a feeling I'd have to spend some more time
on it to get an API with nice ergonomics.
</p>

<div id="outline-container-orga9a9fc9" class="outline-2">
<h2 id="orga9a9fc9">Defining a type to play with</h2>
<div class="outline-text-2" id="text-orga9a9fc9">
<p>
I opted to use <a href="https://hackage.haskell.org/package/barbies-th">barbies-th</a> to save on the typing a bit. Defining a simple type
holding a name and an age can then look like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">declareBareB</span>
  <span class="org-rainbow-delimiters-depth-1">[</span>d<span class="org-haskell-operator">|</span>
   <span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Person</span> <span class="org-rainbow-delimiters-depth-2">{</span>name <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span>, age <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-haskell-operator">|</span><span class="org-rainbow-delimiters-depth-1">]</span>

<span class="org-haskell-keyword">deriving</span> <span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Show</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">deriving</span> <span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Show</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">deriving</span> <span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Show</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The two functions from the <code>Barbies</code> module documentation, <code>addDefaults</code> and
<code>check</code>, can then be written like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">addDefaults</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span>
<span class="org-haskell-definition">addDefaults</span> <span class="org-haskell-operator">=</span> bzipWith trans
  <span class="org-haskell-keyword">where</span>
    trans m d <span class="org-haskell-operator">=</span> maybe d pure m

<span class="org-haskell-definition">check</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Either</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">check</span> pe <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> btraverse <span class="org-rainbow-delimiters-depth-1">(</span>either <span class="org-rainbow-delimiters-depth-2">(</span>const <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">.</span> <span class="org-haskell-constructor">Identity</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> pe <span class="org-haskell-keyword">of</span>
  <span class="org-haskell-constructor">Just</span> pin <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Right</span> pin
  <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Left</span> <span class="org-haskell-operator">$</span> bfoldMap <span class="org-rainbow-delimiters-depth-1">(</span>either <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-3">[]</span></span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>const <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-3">[]</span></span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> pe
</pre>
</div>

<p>
I found it straight forward to define some instances and play with those
functions a bit.
</p>
</div>
</div>

<div id="outline-container-orgc68301e" class="outline-2">
<h2 id="orgc68301e">Adding in JSON</h2>
<div class="outline-text-2" id="text-orgc68301e">
<p>
The bit that wasn't immediately obvious to me was how to use aeson to parse into
a type like <code>Person Covered (Either Text)</code>.
</p>

<p>
First off I needed some data to test things out with.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">bs0, bs1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span>
<span class="org-haskell-definition">bs0</span> <span class="org-haskell-operator">=</span> <span class="org-string">"{\"name\": \"the name\", \"age\": 17}"</span>
<span class="org-haskell-definition">bs1</span> <span class="org-haskell-operator">=</span> <span class="org-string">"{\"name\": \"the name\", \"age\": true}"</span>
</pre>
</div>

<p>
To keep things simple I took baby steps, first I tried parsing into <code>Person
Covered Identity</code>. It turns out that the <code>FromJSON</code> instance from that doesn't
need much thought at all. (It's a bit of a pain to have to specify types in GHCi
all the time, so I'm throwing in a specialised decoding function for each type
too.)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">FromJSON</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  parseJSON <span class="org-haskell-operator">=</span> withObject <span class="org-string">"Person"</span> <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">\</span>o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Person</span> <span class="org-haskell-operator">&lt;$&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"name"</span>
      <span class="org-haskell-operator">&lt;*&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"age"</span>

<span class="org-haskell-definition">decodePI</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">decodePI</span> <span class="org-haskell-operator">=</span> decode
</pre>
</div>

<p>
Trying it out on the test data gives the expected results
</p>

<pre class="example" id="orgbe631ca">
λ&gt; let i0 = decodePI bs0
λ&gt; i0
Just (Person {name = Identity "the name", age = Identity 17})
λ&gt; let i1 = decodePI bs1
λ&gt; i1
Nothing
</pre>

<p>
So far so good! Moving onto <code>Person Covered Maybe</code>. I spent some time trying to
use the combinators in <code>Data.Aeson</code> for dealing with parser failures, but in the
end I had to resort to using <code>&lt;|&gt;</code> from <code>Alternative</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">FromJSON</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  parseJSON <span class="org-haskell-operator">=</span> withObject <span class="org-string">"Person"</span> <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">\</span>o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Person</span> <span class="org-haskell-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>o <span class="org-haskell-operator">.:</span> <span class="org-string">"name"</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-operator">&lt;*&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>o <span class="org-haskell-operator">.:</span> <span class="org-string">"age"</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">decodePM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">decodePM</span> <span class="org-haskell-operator">=</span> decode
</pre>
</div>

<p>
Trying that out I saw exactly the behaviour I expected, i.e. that parsing won't
fail. (Well, at least not as long as it's a valid JSON object to being with.)
</p>

<pre class="example" id="orgec185e3">
λ&gt; let m0 = decodePM bs0
λ&gt; m0
Just (Person {name = Just "the name", age = Just 17})
λ&gt; let m1 = decodePM bs1
λ&gt; m1
Just (Person {name = Just "the name", age = Nothing})
</pre>

<p>
With that done I found that the instance for <code>Person Covered (Either Text)</code>
followed quite naturally. I had to spend a little time on getting the types
right to parse the fields properly. Somewhat disappointingly I didn't get type
errors when the behaviour of the code turned out to be wrong. I'm gussing
aeson's <code>Parser</code> was a little too willing to give me parser failures. Anyway, I
ended up with this instance
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">FromJSON</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  parseJSON <span class="org-haskell-operator">=</span> withObject <span class="org-string">"Person"</span> <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">\</span>o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Person</span> <span class="org-haskell-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">&lt;$&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"name"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Left</span> <span class="org-string">"A name is most needed"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-operator">&lt;*&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">&lt;$&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"age"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Left</span> <span class="org-string">"An integer age is needed"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">decodePE</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">decodePE</span> <span class="org-haskell-operator">=</span> decode
</pre>
</div>

<p>
That does exhibit the behaviour I want
</p>

<pre class="example" id="orgb5a080b">
λ&gt; let e0 = decodePE bs0
λ&gt; e0
Just (Person {name = Right "the name", age = Right 17})
λ&gt; let e1 = decodePE bs1
λ&gt; e1
Just (Person {name = Right "the name", age = Left "An integer age is needed"})
</pre>
</div>
</div>

<div id="outline-container-orgcfdacc1" class="outline-2">
<h2 id="orgcfdacc1">In closing</h2>
<div class="outline-text-2" id="text-orgcfdacc1">
<p>
I think everyone will agree that the <code>FromJSON</code> instances are increasingly
messy. I think that can be fixed by putting some thought into what a more
pleasing API should look like.
</p>

<p>
I'd also like to mix in validation beyond what aeson offers out-of-the-box,
which really only is "is the field present?" and "does the value have the
correct type?". For instance, Once we know there is a field called <code>age</code>, and
that it's an <code>Int</code>, then we might want to make sure it's non-negitive, or that
the person is at least 18. I'm guessing that wouldn't be too difficult.
</p>

<p>
Finally, I'd love to see examples of using HKDs for parsing/validation in the
wild. It's probably easiest to reach me at <a href="https://mastodon.technology/@magthe">@magthe@mastodon.technology</a>.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hkd.html">hkd</a> <a href="https://magnus.therning.org/tag-json.html">json</a> </div>
<div class="post-date">19 Mar 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-03-19-custom-monad-with-servant-and-throwing-errors.html">Custom monad with servant and throwing errors</a></h1>
<p>
In the past I've always used <a href="https://hackage.haskell.org/package/scotty">scotty</a> when writing web services. This was mostly
due to laziness, I found working out how to use scotty a lot easier than
<a href="https://hackage.haskell.org/package/servant">servant</a>, so basically I was being lazy. Fairly quickly I bumped into some
limitations in scotty, but at first the workarounds didn't add too much
complexity and were acceptable. A few weeks ago they started weighing on me
though and I decided to look into servant and since I really liked what I found
I've started moving all projects to use servant.
</p>

<p>
In several of the projects I've used tagless final style and defined a type
based on <code>ReaderT</code> holding configuration over <code>IO</code>, that is something like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unAppM <span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor">ReaderT</span> <span class="org-haskell-constructor">Config</span> <span class="org-haskell-constructor">IO</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span>
    <span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-haskell-constructor">Functor</span>,
      <span class="org-haskell-constructor">Applicative</span>,
      <span class="org-haskell-constructor">Monad</span>,
      <span class="org-haskell-constructor">MonadIO</span>,
      <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Config</span>
    <span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> a
<span class="org-haskell-definition">runAppM</span> app <span class="org-haskell-operator">=</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I found that servant is very well suited to this style through <a href="https://hoogle.haskell.org/?hoogle=hoistServer%20is%3Aexact&amp;scope=set:stackage"><code>hoistServer</code></a> and
there are several examples on how to use it with a <code>ReaderT</code>-based type like
above. The first one I found is in the <a href="https://docs.servant.dev/en/stable/cookbook/using-custom-monad/UsingCustomMonad.html">servant cookbook</a>. However, as I realised
a bit later, using a simple type like this doesn't make it easy to trigger
responses with status other than <code>200 OK</code>. When I looked at the definition of
the type for writing handlers that ships with servant, <a href="https://hoogle.haskell.org/?hoogle=Handler%20package%3Aservant-server%20is%3Aexact&amp;scope=set:stackage"><code>Handler</code></a>, I decided to
try to use the following type in my service
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unAppM <span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor">ReaderT</span> <span class="org-haskell-constructor">Config</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">ExceptT</span> <span class="org-haskell-constructor">ServerError</span> <span class="org-haskell-constructor">IO</span><span class="org-rainbow-delimiters-depth-2">)</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span>
    <span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-haskell-constructor">Functor</span>,
      <span class="org-haskell-constructor">Applicative</span>,
      <span class="org-haskell-constructor">Monad</span>,
      <span class="org-haskell-constructor">MonadIO</span>,
      <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Config</span>
    <span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">ServerError</span> a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">runAppM</span> app <span class="org-haskell-operator">=</span> runExceptT <span class="org-haskell-operator">.</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The natural transformation required by <code>hoistServer</code> can then be written like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">nt</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Handler</span> a
<span class="org-haskell-definition">nt</span> x <span class="org-haskell-operator">=</span>
  liftIO <span class="org-rainbow-delimiters-depth-1">(</span>runAppM x cfg<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
    <span class="org-haskell-constructor">Right</span> v <span class="org-haskell-operator">-&gt;</span> pure v
    <span class="org-haskell-constructor">Left</span> err <span class="org-haskell-operator">-&gt;</span> throwError err
</pre>
</div>

<p>
I particularly like how clearly this suggests a way to add custom errors if I
want that.
</p>

<ol class="org-ol">
<li>Swap out <code>ServerError</code> for my custom error type in <code>AppM</code>.</li>
<li>Write a function to transform my custom error type into a <code>ServerError</code>,
<code>transformCustomError :: CustomError -&gt; ServerError</code>.</li>
<li>use <code>throwError $ transformCustomError err</code> in the <code>Left</code> branch of <code>nt</code>.</li>
</ol>

<div id="outline-container-org656a1f3" class="outline-2">
<h2 id="org656a1f3">A slight complication with <code>MonadUnliftIO</code></h2>
<div class="outline-text-2" id="text-org656a1f3">
<p>
I was using <a href="https://hackage.haskell.org/package/unliftio">unliftio</a> in my service, and as long as I based my monad stack only
on <code>ReaderT</code> that worked fine. I even got the <code>MonadUnliftIO</code> instance for free
through automatic deriving. <code>ExceptT</code> isn't a stateless monad though, so using
unliftio is out of the question, instead I had to switch to <a href="https://hoogle.haskell.org/?hoogle=MonadBaseControl%20package%3Amonad-control&amp;scope=set:stackage"><code>MonadBaseControl</code></a>
and the packages that work with it. Defining and instance of <code>MonadBaseControl</code>
looked a bit daunting, but luckily <code>Handler</code> has an instance of it that I used
as inspiration.
</p>

<p>
First off <code>MonadBaseControl</code> requires the type to also be an instance of
<code>MonadBase</code>. There's an explicit implementation for <code>Handler</code>, but I found that
it can be derived automatically, so I took the lazy route.
</p>

<p>
The instance of <code>MonadBaseControl</code> for <code>AppM</code> ended up looking like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadBaseControl</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  <span class="org-haskell-keyword">type</span> <span class="org-haskell-type">StM</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-type">Either</span> <span class="org-haskell-type">ServerError</span> a

  liftBaseWith f <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">(</span>liftBaseWith <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>g <span class="org-haskell-operator">-&gt;</span> f <span class="org-rainbow-delimiters-depth-3">(</span>g <span class="org-haskell-operator">.</span> unAppM<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
  restoreM <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-haskell-operator">.</span> restoreM
</pre>
</div>

<p>
I can't claim to really understand what's going on in that definition, but I
have Alexis King's article on <a href="https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/">Demystifying MonadBaseControl</a> on my list of things
to read.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-servant.html">servant</a> </div>
<div class="post-date">05 Mar 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-03-05-000-flycheck-and-hls.html">Flycheck and HLS</a></h1>
<p>
I've been using LSP for most programming languages for a while now. HLS is
really very good now, but I've found that it doesn't warn on quite all things
I'd like it to so I find myself having to swap between the <code>'lsp</code> and
<code>'haskell-ghc</code> checkers. However, since <a href="https://www.flycheck.org/en/latest/">flycheck</a> supports chaining checkers I
thought there must be a way to have both checkers active at the same time.
</p>

<p>
The naive approach didn't work due to load order of things in Spacemacs so I had
to experiment a bit to find something that works.
</p>

<p>
The first issue was to make sure that HLS is available at all. I use <code>shell.nix</code>
together with <a href="https://direnv.net/">direnv</a> extensively and I had noticed that <code>lsp-mode</code> tried to load
HLS before <code>direnv</code> had put it in the <code>$PATH</code>. I think the
<code>'lsp-beforeinitialize-hook</code> is the hook to use for this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>add-hook 'lsp-before-initialize-hook #'direnv-update-environment<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-rainbow-delimiters-unmatched">)</span>
</pre>
</div>

<p>
I made a several attempt to chain the checkers but kept on getting
errors due to the <code>'lsp</code> checker not being defined yet. Another problem
I ran into was that the checkers were chained too late, resulting in
having to manually run <code>flycheck-buffer</code> on the first file I opened.
(Deferred loading is a brilliant thing, but make some things really
difficult to debug.) After quite a bit of experimenting and reading the
description of various hooks I did find something that works:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">with-eval-after-load</span> 'lsp-mode
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">defun</span> <span class="org-function-name">magthe:lsp-next-checker</span> <span class="org-rainbow-delimiters-depth-3">()</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>flycheck-add-next-checker 'lsp '<span class="org-rainbow-delimiters-depth-4">(</span>warning . haskell-ghc<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>add-hook 'lsp-lsp-haskell-after-open-hook
            #'magthe:lsp-next-checker<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Of course I have no idea if this is the easiest or most elegant solution but it
does work for my testcases:
</p>

<ol class="org-ol">
<li>Open a file in a project, <code>SPC p l</code> - choose project - choose a Haskell file.</li>
<li>Open a project, <code>SPC p l</code> followed by <code>C-d</code>, and then open a Haskell file.</li>
</ol>

<p>
Suggestions for improvements are more than welcome, of course.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-flycheck.html">flycheck</a> </div>
<div class="post-date">30 Nov 2020</div><h1 class="post-title"><a href="https://magnus.therning.org/2020-11-30-1734-haskell__nix_and_using_packages_from_github.html">Haskell, Nix and using packages from GitHub</a></h1>
<p>
The other day I bumped into what turned out to be a <a href="https://mail.haskell.org/pipermail/haskell-cafe/2020-November/133021.html">bug in Amazonka</a> where
sockets weren't closed in a timely fashion and thus the process ran out of file
descriptors. Some more digging and an <a href="https://github.com/brendanhay/amazonka/issues/608">issue</a> later I found that a fix most likely
already in place (mine was possibly a duplicate of an older <a href="https://github.com/brendanhay/amazonka/issues/490">issue</a>). Now I only
had to verify if that was the case by using the most recent, and unreleased code
on the <code>develop</code> branch of Amazonka.
</p>

<p>
My first thought was to attempt to instruct Cabal to build the bits of Amazonka
I need by putting a few <a href="https://cabal.readthedocs.io/en/3.4/cabal-project.html#specifying-packages-from-remote-version-control-locations"><code>source-repository-package</code> stanzas</a> in my config. That
quickly started to look like a bit of a rabbit hole, so I decided to use Nix
instead. After finding the <a href="https://stackoverflow.com/questions/54810851/how-can-i-build-a-haskell-dependency-from-a-github-source-nix-file-using-nix">perfect SO post</a> and looking up yet again how to do
overrides for Haskell I ran <code>cabal2nix</code> for the three packages I need:
</p>

<div class="org-src-container">
<pre class="src src-shell">cabal2nix --no-haddock --no-check --subpath amazonka <span class="org-sh-escaped-newline">\</span>
  git://github.com/brendanhay/amazonka.git &gt; amazonka.nix
cabal2nix --no-haddock --no-check --subpath core <span class="org-sh-escaped-newline">\</span>
  git://github.com/brendanhay/amazonka.git &gt; amazonka-core.nix
cabal2nix --no-haddock --no-check --subpath amazonka-sqs <span class="org-sh-escaped-newline">\</span>
  git://github.com/brendanhay/amazonka.git &gt; amazonka-sqs.nix
</pre>
</div>

<p>
The relevant part of the old Nix expression looked like this:
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-nix-attribute">thePkg</span> = haskellPackages.developPackage <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">root</span> = lib.cleanSource <span class="org-nix-constant">./.</span>;
  <span class="org-nix-attribute">name</span> = name;

  <span class="org-nix-attribute">modifier</span> = <span class="org-rainbow-delimiters-depth-2">(</span>t.flip t.pipe<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">[</span>hl.dontHaddock
     hl.enableStaticLibraries
     hl.justStaticExecutables
     hl.disableLibraryProfiling
     hl.disableExecutableProfiling<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
After adding the overrides it looked like this
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-nix-attribute">hp</span> = haskellPackages.override <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">overrides</span> = self: super: <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-nix-attribute">amazonka-core</span> = self.callPackage <span class="org-nix-constant">./amazonka-core.nix</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
    <span class="org-nix-attribute">amazonka</span> = self.callPackage <span class="org-nix-constant">./amazonka.nix</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
    <span class="org-nix-attribute">amazonka-sqs</span> = self.callPackage <span class="org-nix-constant">./amazonka-sqs.nix</span> <span class="org-rainbow-delimiters-depth-3">{}</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-nix-attribute">thePkg</span> = hp.developPackage <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-nix-attribute">root</span> = lib.cleanSource <span class="org-nix-constant">./.</span>;
  <span class="org-nix-attribute">name</span> = name;

  <span class="org-nix-attribute">modifier</span> = <span class="org-rainbow-delimiters-depth-2">(</span>t.flip t.pipe<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">[</span>hl.dontHaddock
     hl.enableStaticLibraries
     hl.justStaticExecutables
     hl.disableLibraryProfiling
     hl.disableExecutableProfiling<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
After a somewhat longer-than-usual build I could verify that I had indeed bumped
into the same issue and my issue was a duplicate.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>
<div class="post-date">11 Nov 2020</div><h1 class="post-title"><a href="https://magnus.therning.org/2020-11-11-2222-combining_amazonka_and_conduit.html">Combining Amazonka and Conduit</a></h1>
<p>
Combining <a href="https://hackage.haskell.org/package/amazonka">amazonka</a> and <a href="https://hackage.haskell.org/package/conduit">conduit</a> turned out to be easier than I had expected.
</p>

<p>
Here's an SNS sink I put together today
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">snsSink</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadAWS</span> m, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">T.Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">C.ConduitT</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-type">C.Void</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">snsSink</span> topic <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  C.await <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> pure <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-haskell-constructor">Just</span> msg <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">&lt;-</span> C.lift <span class="org-haskell-operator">$</span> publishSNS topic <span class="org-rainbow-delimiters-depth-1">(</span>TL.toStrict <span class="org-haskell-operator">$</span> TL.decodeUtf8 <span class="org-haskell-operator">$</span> encode msg<span class="org-rainbow-delimiters-depth-1">)</span>
      snsSink topic
</pre>
</div>

<p>
Putting it to use can be done with something like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="org-haskell-operator">...</span>
  awsEnv <span class="org-haskell-operator">&lt;-</span> newEnv <span class="org-haskell-constructor">Discover</span>
  runAWSCond awsEnv <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">&lt;</span>source producing <span class="org-haskell-constructor">Value</span><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-operator">.|</span> snsSink topicArn

  <span class="org-haskell-keyword">where</span>
    runAWSCond awsEnv <span class="org-haskell-operator">=</span> runResourceT <span class="org-haskell-operator">.</span> runAWS awsEnv <span class="org-haskell-operator">.</span> within <span class="org-haskell-constructor">Frankfurt</span> <span class="org-haskell-operator">.</span> C.runConduit
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-amazonka.html">amazonka</a> <a href="https://magnus.therning.org/tag-aws.html">aws</a> <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>
<div class="post-date">08 Apr 2020</div><h1 class="post-title"><a href="https://magnus.therning.org/2020-04-08-000-xray-and-wai.html">X-Ray and WAI</a></h1>
<p>
For a while we've been planning on introducing <a href="https://aws.amazon.com/xray/">AWS X-Ray</a> into our system at
work. There's official support for a few languages, but not too surprisingly
Haskell isn't on that list. I found <a href="https://github.com/freckle/aws-xray-client">freckle/aws-xray-client</a> on GitHub, which is
so unofficial that it isn't even published on Hackage. While it looks very good,
I suspect it does more than I need and since it lacks licensing information I
decided to instead implement a version tailored to our needs.
</p>

<p>
As a first step I implemented a WAI <i>middleware</i> that wraps an HTTP request and
reports the time it took to produce a response. Between the <a href="https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html">X-Ray Developer
Guide</a> and the code in Freckle's git repo it turned out to be fairly simple.
</p>

<p>
First off, this is the first step towards X-Ray nirvana, so all I'm aiming for
is minimal support. That means all I want is to send <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html#api-segmentdocuments-fields">minimal X-Ray segment</a>s,
with the small addition that I want to support <code>parent_id</code> from the start.
</p>

<p>
The first step then is to parse the HTTP header containing the X-Ray information
&#x2013; <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader"><code>X-Amzn-Trace-Id</code></a>. For now I'm only interested in two parts, <code>Root</code> and
<code>Parent</code>, so for simplicity's sake I use a tuple to keep them in. The idea is to
take the header's value, split on <code>;</code> to get the parts, then split each part in
two, a key and a value, and put them into an association list (<code>[(Text, Text)]</code>)
for easy lookup using, well <code>lookup</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">parseXRayTraceIdHdr</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">parseXRayTraceIdHdr</span> hdr <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  bits <span class="org-haskell-operator">&lt;-</span> traverse parseHeaderComponent <span class="org-haskell-operator">$</span> T.split <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">==</span> <span class="org-string">';'</span><span class="org-rainbow-delimiters-depth-1">)</span> hdr
  traceId <span class="org-haskell-operator">&lt;-</span> lookup <span class="org-string">"Root"</span> bits
  <span class="org-haskell-keyword">let</span> parent <span class="org-haskell-operator">=</span> lookup <span class="org-string">"Parent"</span> bits
  pure <span class="org-rainbow-delimiters-depth-1">(</span>traceId, parent<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">parseHeaderComponent</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">parseHeaderComponent</span> cmp <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> T.split <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">==</span> <span class="org-string">'='</span><span class="org-rainbow-delimiters-depth-1">)</span> cmp <span class="org-haskell-keyword">of</span>
                            <span class="org-rainbow-delimiters-depth-1">[</span>name, value<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-rainbow-delimiters-depth-1">(</span>name, value<span class="org-rainbow-delimiters-depth-1">)</span>
                            <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
</pre>
</div>

<p>
The start and end times for processing a request are also required. The docs say
that using at least millisecond resolution is a good idea, so I decided to do
exactly that. <code>NominalDiffTime</code>, which is what <code>getPOSIXTime</code> produces, supports
a resolution of picoseconds (though I doubt my system's clock does) which
requires a bit of (type-based) converting.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mkTimeInMilli</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Milli</span>
<span class="org-haskell-definition">mkTimeInMilli</span> <span class="org-haskell-operator">=</span> ndfToMilli <span class="org-haskell-operator">&lt;$&gt;</span> getPOSIXTime
  <span class="org-haskell-keyword">where</span>
    ndfToMilli <span class="org-haskell-operator">=</span> fromRational <span class="org-haskell-operator">.</span> toRational
</pre>
</div>

<p>
The last support function needed is one that creates the segment. Just
building the JSON object, using <i>aeson</i>'s <code>object</code>, is enough at this
point.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mkSegment</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Milli</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Milli</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">mkSegment</span> name id startTime endTime <span class="org-rainbow-delimiters-depth-1">(</span>root, parent<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span>
  object <span class="org-haskell-operator">$</span> <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-string">"name"</span> <span class="org-haskell-operator">.=</span> name
           , <span class="org-string">"id"</span> <span class="org-haskell-operator">.=</span> id
           , <span class="org-string">"trace_id"</span> <span class="org-haskell-operator">.=</span> root
           , <span class="org-string">"start_time"</span> <span class="org-haskell-operator">.=</span> startTime
           , <span class="org-string">"end_time"</span> <span class="org-haskell-operator">.=</span> endTime
           <span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">&lt;&gt;</span> p
  <span class="org-haskell-keyword">where</span>
    p <span class="org-haskell-operator">=</span> maybe <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> v <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"parent_id"</span> <span class="org-haskell-operator">.=</span> v<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> parent
</pre>
</div>

<p>
Armed with all this, I can now put together a WAI middleware that
</p>

<ol class="org-ol">
<li>records the start time of the call</li>
<li>processes the request</li>
<li>sends off the response and keeps the result of it</li>
<li>records the end time</li>
<li>parses the tracing header</li>
<li>builds the segment prepended with the <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-api-sendingdata.html#xray-api-daemon">X-Ray daemon header</a></li>
<li>sends the segment to the X-Ray daemon</li>
</ol>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">traceId</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Middleware</span>
<span class="org-haskell-definition">traceId</span> xrayName app req sendResponse <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  startTime <span class="org-haskell-operator">&lt;-</span> mkTimeInMilli
  app req <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span> res <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
    rr <span class="org-haskell-operator">&lt;-</span> sendResponse res
    endTime <span class="org-haskell-operator">&lt;-</span> mkTimeInMilli
    theId <span class="org-haskell-operator">&lt;-</span> T.pack <span class="org-haskell-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> v <span class="org-haskell-operator">-&gt;</span> showHex v <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;$&gt;</span> randomIO <span class="org-haskell-operator">@</span><span class="org-haskell-constructor">Word64</span>
    <span class="org-haskell-keyword">let</span> traceParts <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>decodeUtf8 <span class="org-haskell-operator">&lt;$&gt;</span> requestHeaderTraceId req<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;=</span> parseXRayTraceIdHdr
        segment <span class="org-haskell-operator">=</span> mkSegment xrayName theId startTime endTime <span class="org-haskell-operator">&lt;$&gt;</span> traceParts
    <span class="org-haskell-keyword">case</span> segment <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> pure <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
      <span class="org-haskell-constructor">Just</span> segment' <span class="org-haskell-operator">-&gt;</span> sendXRayPayload <span class="org-haskell-operator">$</span> toStrict <span class="org-haskell-operator">$</span> prepareXRayPayload segment'
    pure rr

  <span class="org-haskell-keyword">where</span>
    prepareXRayPayload segment <span class="org-haskell-operator">=</span>
      <span class="org-haskell-keyword">let</span> header <span class="org-haskell-operator">=</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"format"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"json"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-string">"version"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
      <span class="org-haskell-keyword">in</span> encode header <span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">"\n"</span> <span class="org-haskell-operator">&lt;&gt;</span> encode segment

    sendXRayPayload payload <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      addrInfos <span class="org-haskell-operator">&lt;-</span> S.getAddrInfo <span class="org-haskell-constructor">Nothing</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Just</span> <span class="org-string">"127.0.0.1"</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Just</span> <span class="org-string">"2000"</span><span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-keyword">case</span> addrInfos <span class="org-haskell-keyword">of</span>
        <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> pure <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-comment-delimiter">-- </span><span class="org-comment">silently skip</span>
        <span class="org-rainbow-delimiters-depth-1">(</span>xrayAddr<span class="org-haskell-constructor">:</span><span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
          sock <span class="org-haskell-operator">&lt;-</span> S.socket <span class="org-rainbow-delimiters-depth-1">(</span>S.addrFamily xrayAddr<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">S.Datagram</span> S.defaultProtocol
          S.connect sock <span class="org-rainbow-delimiters-depth-1">(</span>S.addrAddress xrayAddr<span class="org-rainbow-delimiters-depth-1">)</span>
          sendAll sock payload
          S.close sock
</pre>
</div>

<p>
The next step will be to instrument the actual processing. The service I'm
instrumenting is asynchronous, so all the work happens <i>after</i> the response has
been sent. My plan for this is to use subsegments to record it. That means I'll
have to
</p>

<ul class="org-ul">
<li>keep the <code>Root</code> and ID (<code>theId</code> in <code>traceId</code> above) for use in subsegments</li>
<li>keep the original tracing header, for use in outgoing calls</li>
<li>make sure all outgoing HTTP calls include a tracing header with a proper
<code>Parent</code></li>
<li>wrap all outgoing HTTP calls with time keeping and sending a subsegment to the
X-Ray daemon</li>
</ul>

<p>
I'm saving that work for a rainy day though, or rather, for a day when I'm so
upset at Clojure that I don't want to see another parenthesis.
</p>

<p>
<i>Edit (2020-04-10):</i> Corrected the segment field name for the parent ID, it
should be <code>parent_id</code>.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-aws.html">AWS</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-xray.html">XRay</a> </div>
<div class="post-date">02 Feb 2020</div><h1 class="post-title"><a href="https://magnus.therning.org/2020-02-02-000-my-ghcide-build-for-nix.html">My ghcide build for Nix</a></h1>
<p>
I was slightly disappointed to find out that not all packages on Hackage that
are marked as present in <a href="https://nixos.org/nixpkgs/">Nix(pkgs)</a> actually are available. Quite a few of them
are marked broken and hence not installable. One of these packages is <a href="https://hackage.haskell.org/package/ghcide">ghcide</a>.
</p>

<p>
There are of course expressions available for getting a working <code>ghcide</code>
executable installed, like <a href="https://github.com/hercules-ci/ghcide-nix">ghcide-nix</a>. However, since I have rather simple needs
for my Haskell projects I thought I'd play with my own approach to it.
</p>

<p>
What I care about is:
</p>

<ol class="org-ol">
<li>availability of the development tools I use, at the moment it's mainly
<code>ghcide</code> but I'm planning on making use of <a href="https://hackage.haskell.org/package/ormolu">ormolu</a> in the near future</li>
<li>pre-built packages</li>
<li>ease of use</li>
</ol>

<p>
So, I put together <a href="https://github.com/magthe/ghcide-for-nix">ghcide-for-nix</a>. It's basically just a constumized Nixpkgs
where the packages needed to un-break <code>ghcide</code> are present.
</p>

<p>
Usage is a simple <code>import</code> away:
</p>

<div class="org-src-container">
<pre class="src src-nix"><span class="org-nix-builtin">import</span> <span class="org-rainbow-delimiters-depth-1">(</span>builtins.fetchGit <span class="org-rainbow-delimiters-depth-2">{</span>
  <span class="org-nix-attribute">name</span> = <span class="org-string">"ghcide-for-nix"</span>;
  <span class="org-nix-attribute">url</span> = <span class="org-nix-constant">https://github.com/magthe/ghcide-for-nix</span>;
  <span class="org-nix-attribute">rev</span> = <span class="org-string">"927a8caa62cece60d9d66dbdfc62b7738d61d75f"</span>;
<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
and it'll give you a superset of Nixpkgs. Pre-built packages are available on
<a href="https://magthe.cachix.org/">Cachix</a>.
</p>

<p>
It's not sophisticated, but it's rather easy to use and suffices for my
purposes.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-nix.html">nix</a> </div>
<div class="post-date">19 Sep 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-09-19-000-haskell--ghcide--and-spacemacs.html">Haskell, ghcide, and Spacemacs</a></h1>
<p>
The other day I read Chris Penner's post on <a href="https://chrispenner.ca/posts/hie-core">Haskell IDE Support</a> and thought I'd
make an attempt to use it with Spacemacs.
</p>

<p>
After running <code>stack build hie-bios ghcide haskell-lsp --copy-compiler-tool</code> I
had a look at the <a href="https://github.com/haskell/haskell-ide-engine#using-hie-with-spacemacs">instructions on using <code>haskell-ide-engine</code> with Spacemacs</a>.
After a bit of trial and error I came up with these changes to my
<code>~/.spacemacs</code>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">dotspacemacs/layers</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq-default</span>
   dotspacemacs-configuration-layers
   '<span class="org-rainbow-delimiters-depth-3">(</span>
    ...
    lsp
    <span class="org-rainbow-delimiters-depth-4">(</span>haskell <span class="org-builtin">:variables</span>
             haskell-completion-backend 'lsp
             <span class="org-rainbow-delimiters-depth-4">)</span>
    ...<span class="org-rainbow-delimiters-depth-3">)</span>
  <span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">dotspacemacs/user-config</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq</span> lsp-haskell-process-args-hie '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"exec"</span> <span class="org-string">"ghcide"</span> <span class="org-string">"--"</span> <span class="org-string">"--lsp"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        lsp-haskell-process-path-hie <span class="org-string">"stack"</span>
        lsp-haskell-process-wrapper-function <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>argv<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">(</span>cons <span class="org-rainbow-delimiters-depth-5">(</span>car argv<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span>cddr argv<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>add-hook 'haskell-mode-hook
            #'lsp<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The slightly weird looking <code>lsp-haskell-process-wrapper-function</code> is removing
the pesky <code>--lsp</code> inserted by <a href="https://github.com/emacs-lsp/lsp-haskell/blob/64106be79350f9ce6903d22c66b29761dadb5001/lsp-haskell.el#L179">this line</a>.
</p>

<p>
That seems to work. Though I have to say I'm not ready to switch from <a href="https://hackage.haskell.org/package/intero">intero</a>
just yet. Two things in particular didn't work with =ghcide=/LSP:
</p>

<ol class="org-ol">
<li>Switching from one the <code>Main.hs</code> in one executable to the <code>Main.hs</code> of
another executable in the same project didn't work as expected &#x2013; I had hints
and types in the first, but nothing in the second.</li>
<li>Jump to the definition of a function defined in the package didn't work &#x2013;
I'm not willing to use <a href="https://www.gnu.org/software/global/">GNU GLOBAL</a> or some other source tagging system.</li>
</ol>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-lsp.html">lsp</a> <a href="https://magnus.therning.org/tag-spacemacs.html">spacemacs</a> </div>
<div class="post-date">19 Aug 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-08-19-000-hedgehog-on-a-rest-api--part-3.html">Hedgehog on a REST API, part 3</a></h1>
<p>
In my previous post on using Hedgehog on a REST API, <a href="2019-06-23-000-hedgehog-on-a-rest-api--part-2.html">Hedgehog on a REST API,
part 2</a> I ran the test a few times and adjusted the model to deal with the
incorrect assumptions I had initially made. In particular, I had to adjust how I
modelled the <i>User ID</i>. Because of the simplicity of the API that wasn't too
difficult. However, that kind of completely predictable ID isn't found in all
APIs. In fact, it's not uncommon to have completely random IDs in API (often
they are <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>s).
</p>

<p>
So, I set out to try to deal with that. I'm still using the simple API from the
previous posts, but this time I'm pretending that I can't build the ID into the
model myself, or, put another way, I'm capturing the ID from the responses.
</p>

<div id="outline-container-orgca4a77b" class="outline-2">
<h2 id="orgca4a77b">The model state</h2>
<div class="outline-text-2" id="text-orgca4a77b">
<p>
When capturing the ID it's no longer possible to use a simple <code>Map Int Text</code> for
the state, because I don't actually have the ID until I have an HTTP response.
However, the ID is playing an important role in the constructing of a sequence
of actions. The trick is to use <code>Var Int v</code> instead of an ordinary <code>Int</code>. As I
understand it, and I believe that's a good enough understanding to make use of
Hedgehog possible, is that this way the ID is an opaque blob in the construction
phase, and it's turned into a concrete value during execution. When in the
opaque state it implements enough type classes to be useful for my purposes.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Var</span> <span class="org-haskell-constructor">Int</span> v<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge3fe138" class="outline-2">
<h2 id="orge3fe138">The API calls: add user</h2>
<div class="outline-text-2" id="text-orge3fe138">
<p>
When taking a closer look at the <a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#t:Callback"><code>Callback</code></a> type not all the callbacks will get
the state in the same form, opaque or concrete, and one of them, <code>Update</code>
actually receives the state in both states depending on the phase of execution.
This has the most impact on the add user action. To deal with it there's a need
to rearrange the code a bit, to be specific, <code>commandExecute</code> can no longer
return a tuple of both the ID and the status of the HTTP response because the
update function can't reach into the tuple, which it needs to update the state.
</p>

<p>
That means the <code>commandExecute</code> function will have to do tests too. It <i>is</i> nice
to keep all tests in the callbacks, but by sticking a <code>MonadTest m</code> constraint
on the <code>commandExecute</code> it turns into a nice solution anyway.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m, <span class="org-haskell-type">MonadTest</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                           <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.text <span class="org-rainbow-delimiters-depth-1">(</span>Range.linear <span class="org-highlight-numbers-number">0</span> <span class="org-highlight-numbers-number">42</span><span class="org-rainbow-delimiters-depth-1">)</span> Gen.alpha

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      <span class="org-rainbow-delimiters-depth-1">(</span>s, ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
        mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
        addReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/users"</span>
        <span class="org-haskell-keyword">let</span> addReq' <span class="org-haskell-operator">=</span> addReq <span class="org-rainbow-delimiters-depth-1">{</span> requestBody <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RequestBodyLBS</span> <span class="org-rainbow-delimiters-depth-2">(</span>encode <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">User</span> <span class="org-highlight-numbers-number">0</span> n<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>
        addResp <span class="org-haskell-operator">&lt;-</span> httpLbs addReq' mgr
        <span class="org-haskell-keyword">let</span> user <span class="org-haskell-operator">=</span> decode <span class="org-rainbow-delimiters-depth-1">(</span>responseBody addResp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">User</span>
        return <span class="org-rainbow-delimiters-depth-1">(</span>responseStatus addResp, user<span class="org-rainbow-delimiters-depth-1">)</span>
      status201 <span class="org-haskell-operator">===</span> s
      assert <span class="org-haskell-operator">$</span> isJust ui
      <span class="org-rainbow-delimiters-depth-1">(</span>userName <span class="org-haskell-operator">&lt;$&gt;</span> ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">Just</span> n
      return <span class="org-haskell-operator">$</span> userId <span class="org-haskell-operator">$</span> fromJust ui

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.insert o n m<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I found that once I'd come around to folding the <code>Ensure</code> callback into the
<code>commandExecute</code> function the rest fell out from the types.
</p>
</div>
</div>

<div id="outline-container-orgf9cfdae" class="outline-2">
<h2 id="orgf9cfdae">The API calls: delete user</h2>
<div class="outline-text-2" id="text-orgf9cfdae">
<p>
The other actions, deleting a user and getting a user, required only minor
changes and the changes were rather similar in both cases.
</p>

<p>
Not the type for the action needs to take a <code>Var Int v</code> instead of just a plain
<code>Int</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Var</span> <span class="org-haskell-constructor">Int</span> v<span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Which in turn affect the implementation of <code>HTraversable</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-haskell-keyword">where</span>
  htraverse f <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> vi<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> htraverse f vi
</pre>
</div>

<p>
Then the changes to the <code>Command</code> mostly comprise use of <a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#v:concrete"><code>concrete</code></a> in places
where the real ID is needed.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                              , <span class="org-haskell-constructor">Require</span> r
                              , <span class="org-haskell-constructor">Ensure</span> e
                              <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
      ks <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.element ks

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> vi<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      delReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"DELETE http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show <span class="org-rainbow-delimiters-depth-1">(</span>concrete vi<span class="org-rainbow-delimiters-depth-1">)</span>
      delResp <span class="org-haskell-operator">&lt;-</span> httpNoBody delReq mgr
      return <span class="org-haskell-operator">$</span> responseStatus delResp

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.delete i m

    r <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> i <span class="org-haskell-operator">`elem`</span> M.keys m

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> r <span class="org-haskell-operator">=</span> r <span class="org-haskell-operator">===</span> status200
</pre>
</div>
</div>
</div>

<div id="outline-container-org24f01b8" class="outline-2">
<h2 id="org24f01b8">Conclusion</h2>
<div class="outline-text-2" id="text-org24f01b8">
<p>
This post concludes my playing around with state machines in Hedgehog for this
time. I certainly hope I find the time to put it to use on some larger API soon.
In particular I'd love to put it to use at work; I think it'd be an excellent
addition to the integration tests we currently have.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hedgehog.html">hedgehog</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>
<div class="post-date">10 Aug 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-08-10-000-architecture-of-a-service.html">Architecture of a service</a></h1>
<p>
Early this summer it was finally time to put this one service I've been working
on into our sandbox environment. It's been running without hickups so last week
I turned it on for production as well. In this post I thought I'd document the
how and why of the service in the hope that someone will find it useful.
</p>

<p>
The service functions as an interface to external SMS-sending services, offering
a single place to change if we find that we are unhappy with the service we're
using.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> This service replaces an older one, written in Ruby and no one really
dares touch it. Hopefully the Haskell version will prove to be a joy to work
with over time.
</p>

<div id="outline-container-orga8a66cc" class="outline-2">
<h2 id="orga8a66cc">Overview of the architecture</h2>
<div class="outline-text-2" id="text-orga8a66cc">
<p>
The service is split into two parts, one web server using <a href="https://hackage.haskell.org/package/scotty">scotty</a>, and streaming
data processing using <a href="https://hackage.haskell.org/package/conduit">conduit</a>. Persistent storage is provided by a <a href="https://www.postgresql.org/">PostgreSQL</a>
database. The general idea is that events are picked up from the database, acted
upon, which in turn results in other events which written to the database. Those
are then picked up and round and round we go. The web service accepts requests,
turns them into events and writes the to the database.
</p>

<p>
Hopefully this crude diagram clarifies it somewhat.
</p>


<figure id="org603b78a">
<img src="static/2019-08-10-architecture.png" alt="2019-08-10-architecture.png">

<figcaption><span class="figure-number">Figure 1: </span>Diagram of the service architecture</figcaption>
</figure>

<p>
There are a few things that might need some explanation
</p>

<ul class="org-ul">
<li><p>
In the past we've wanted to have the option to use multiple external SMS
services at the same time. One is randomly chosen as the request comes in.
There's also a possibility to configure the frequency for each external
service.
</p>

<p>
<i>Picker</i> implements the random picking and I've written about that earlier in
<a href="2019-02-17-000-choosing-a-conduit-randomly.html">Choosing a conduit randomly</a>.
</p>

<p>
<i>Success</i> and <i>fail</i> are dummy senders. They don't actually send anything, and
the former succeeds at it while the latter fails. I found them useful for
manual testing.
</p></li>

<li><p>
Successfully sending off a request to an external SMS service, getting status
200 back, doesn't actually mean that the SMS has been sent, or even that it
ever will be. Due to the nature of SMS messaging there are no guarantees of
timeliness at all. Since we are interested in finding out whether an SMS
actually is sent a delayed action is scheduled, which will fetch the status of
a sent SMS after a certain time (currently 2 minutes). If an SMS hasn't been
sent after that time it might as well never be &#x2013; it's too slow for our
end-users.
</p>

<p>
This is what <i>report-fetcher</i> and <i>fetcher-func</i> do.
</p></li>

<li>The <i>queue sink</i> and <i>queue src</i> are actually <a href="https://hackage.haskell.org/package/stm-conduit-4.0.1/docs/Data-Conduit-TQueue.html#v:sourceTQueue"><code>sourceTQueue</code></a> and <a href="https://hackage.haskell.org/package/stm-conduit-4.0.1/docs/Data-Conduit-TQueue.html#v:sinkTQueue"><code>sinkTQueue</code></a>.
Splitting the stream like that makes it trivial to push in events by using
<a href="https://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM-TQueue.html#v:writeTQueue"><code>writeTQueue</code></a>.</li>

<li>I use <a href="https://hackage.haskell.org/package/conduit-1.3.1.1/docs/Data-Conduit.html#v:sequenceConduits"><code>sequenceConduits</code></a> in order to send a single event to multiple
=Conduit=s and then combine all their results back into a single stream. The
ease with which this can be done in <a href="https://hackage.haskell.org/package/conduit">conduit</a> is one of the main reasons why I
choose to use it.<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup></li>
</ul>
</div>
</div>

<div id="outline-container-org495919d" class="outline-2">
<h2 id="org495919d">Effects and tests</h2>
<div class="outline-text-2" id="text-org495919d">
<p>
I started out writing everything based on a type like <code>ReaderT &lt;my cfg type&gt; IO</code>
and using <code>liftIO</code> for effects that needed lifting. This worked nicely while I
was setting up the basic structure of the service, but as soon as I hooked in
the database I really wanted to do some testing also of the effectful code.
</p>

<p>
After reading <a href="https://serokell.io/blog/2018/12/07/tagless-final">Introduction to Tagless Final</a> and
<a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">The ReaderT Design Patter</a>, playing a bit with both approaches, and writing
<a href="2019-01-20-000-tagless-final-and-scotty.html">Tagless final and Scotty</a> and
<a href="2019-02-02-000-the-readert-design-pattern-or-tagless-final-.html">The ReaderT design pattern or tagless final?</a>, I finally chose to go down the route
of <i>tagless final</i>. There's no strong reason for that decision, maybe it was
just because I read about it first and found it very easy to move in that
direction in small steps.
</p>

<p>
There's a split between property tests and unit tests:
</p>

<ul class="org-ul">
<li>Data types, their monad instances (like JSON (de-)serialisation), pure
functions and a few effects are tested using properties. I'm using <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>
for that. I've since looked a little closer at <a href="https://hackage.haskell.org/package/hedgehog">hedgehog</a> and if I were to do a
major overhaul of the property tests I might be tempted to rewrite them using
that library instead.</li>

<li>Most of the =Conduit=s are tested using <a href="https://hackage.haskell.org/package/HUnit">HUnit</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-orged81fcb" class="outline-2">
<h2 id="orged81fcb">Configuration</h2>
<div class="outline-text-2" id="text-orged81fcb">
<p>
The service will be run in a container and we try to follow the <a href="https://12factor.net/">12-factor app
rules</a>, where the third one says that configuration should be stored in the
environment. All previous Haskell projects I've worked on have been command line
tools were configuration is done (mostly) using command line argument. For that
I usually use <a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a>, but it's not applicable in this setting.
</p>

<p>
After a bit of searching on <a href="https://hackage.haskell.org/">hackage</a> I settled on <a href="https://hackage.haskell.org/package/etc">etc</a>. It turned out to be nice
an easy to work with. The configuration is written in JSON and only specifies
environment variables. It's then embedded in the executable using <a href="https://hackage.haskell.org/package/file-embed">file-embed</a>.
The only thing I miss is a <a href="https://hackage.haskell.org/package/aeson/docs/Data-Aeson.html#t:ToJSON"><code>ToJSON</code></a> instance for <a href="https://hackage.haskell.org/package/etc-0.4.1.0/docs/System-Etc.html#t:Config"><code>Config</code></a> &#x2013; we've found it
quite useful to log the active configuration when starting a service and that
log entry would become a bit nicer if the message was JSON rather than the
(somewhat difficult to read) string that <code>Config</code>'s <code>Show</code> instance produces.
</p>
</div>
</div>

<div id="outline-container-orgf3bc0ed" class="outline-2">
<h2 id="orgf3bc0ed">Logging</h2>
<div class="outline-text-2" id="text-orgf3bc0ed">
<p>
There are two requirements we have when it comes to logging
</p>

<ol class="org-ol">
<li>All log entries tied to a request should have a <a href="https://hilton.org.uk/blog/microservices-correlation-id">correlation ID</a>.</li>
<li>Log requests and responses</li>
</ol>

<p>
I've written about correlation ID before, <a href="2018-10-01-000-using-a-configuration-in-scotty.html">Using a configuration in Scotty</a>.
</p>

<p>
Logging requests and responses is an area where I'm not very happy with <a href="https://hackage.haskell.org/package/scotty">scotty</a>.
It feels natural to solve it using middleware (i.e. using <a href="https://hackage.haskell.org/package/scotty/docs/Web-Scotty.html#v:middleware"><code>middleware</code></a>) but the
representation, especially of responses, is a bit complicated so for the time
being I've skipped logging the body of both. I'd be most interested to hear of
libraries that could make that easier.
</p>
</div>
</div>

<div id="outline-container-org5f31ed4" class="outline-2">
<h2 id="org5f31ed4">Data storage and picking up new events</h2>
<div class="outline-text-2" id="text-org5f31ed4">
<p>
The data stream processing depends heavily on being able to pick up when new
events are written to the database. Especially when there are more than one
instance running (we usually have at least two instance running in the
production environment). To get that working I've used <a href="https://hackage.haskell.org/package/postgresql-simple">postgresql-simple</a>'s
support for <a href="https://www.postgresql.org/docs/current/sql-listen.html"><code>LISTEN</code></a> and <a href="https://www.postgresql.org/docs/current/sql-notify.html"><code>NOTIFY</code></a> via the function <a href="https://hackage.haskell.org/package/postgresql-simple-0.6.2/docs/Database-PostgreSQL-Simple-Notification.html#v:getNotification"><code>getNotification</code></a>.
</p>

<p>
When I wrote about this earlier, <a href="2019-03-03-000-conduit-and-postgresql.html">Conduit and PostgreSQL</a> I got some really good
feedback that made my solution more robust.
</p>
</div>
</div>

<div id="outline-container-org04b2853" class="outline-2">
<h2 id="org04b2853">Delayed actions</h2>
<div class="outline-text-2" id="text-org04b2853">
<p>
Some things in Haskell feel almost like cheating. The light-weight threading
makes me confident that a <a href="https://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkIO"><code>forkIO</code></a> followed by a <a href="https://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:threadDelay"><code>threadDelay</code></a> (or in my case,
the ones from <a href="https://hackage.haskell.org/package/unliftio">unliftio</a>) will suffice.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
It has happened in the past that we've changed SMS service after finding
that they weren't living up to our expectations.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
A while ago I was experimenting with other streaming libraries, but I
gave up on getting re-combination to work &#x2013; <a href="2018-10-16-000-zipping-streams.html">Zipping streams</a>
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> <a href="https://magnus.therning.org/tag-scotty.html">scotty</a> <a href="https://magnus.therning.org/tag-postgresql.html">postgresql</a> <a href="https://magnus.therning.org/tag-tagless_final.html">tagless_final</a> </div>
<div class="post-date">23 Jun 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-06-23-000-hedgehog-on-a-rest-api--part-2.html">Hedgehog on a REST API, part 2</a></h1>
<p>
This is a short follow-up to <a href="2019-05-30-000-hedgehog-on-a-rest-api.html">Hedgehog on a REST API</a> where I actually run the
tests in that post.
</p>

<div id="outline-container-org27855a2" class="outline-2">
<h2 id="org27855a2">Fixing an issue with the model</h2>
<div class="outline-text-2" id="text-org27855a2">
<p>
The first issue I run into is
</p>

<pre class="example" id="orgdd312b9">
━━━ Main ━━━
  ✗ sequential failed after 18 tests and 1 shrink.

        ┏━━ tst/test-01.hs ━━━
     89 ┃ getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     90 ┃ getUser = Command gen exec [ Require r
     91 ┃                            , Ensure e
     92 ┃                            ]
     93 ┃   where
     94 ┃     gen (State m) = case M.keys m of
     95 ┃       [] -&gt; Nothing
     96 ┃       ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     97 ┃
     98 ┃     exec (GetUser i) = liftIO $ do
     99 ┃       mgr &lt;- newManager defaultManagerSettings
    100 ┃       getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
    101 ┃       getResp &lt;- httpLbs getReq mgr
    102 ┃       let us = decode $ responseBody getResp :: Maybe [User]
    103 ┃       return (status200 == responseStatus getResp, us)
    104 ┃
    105 ┃     r (State m) (GetUser i) = i `elem` M.keys m
    106 ┃
    107 ┃     e _ _ (GetUser _) (r, us) = do
    108 ┃       r === True
    109 ┃       assert $ isJust us
    110 ┃       (length &lt;$&gt; us) === Just 1
        ┃       ^^^^^^^^^^^^^^^^^^^^^^^^^^
        ┃       │ Failed (- lhs =/= + rhs)
        ┃       │ - Just 0
        ┃       │ + Just 1

        ┏━━ tst/test-01.hs ━━━
    118 ┃ prop_seq :: Property
    119 ┃ prop_seq = property $ do
    120 ┃   actions &lt;- forAll $ Gen.sequential (Range.linear 1 10) initialState [addUser, deleteUser, getUser]
        ┃   │ Var 0 = AddUser ""
        ┃   │ Var 1 = GetUser 1
    121 ┃   resetWS
    122 ┃   executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 17) (Seed 2158538972777046104 (-1442908127347265675)) sequential

  ✗ 1 failed.
</pre>

<p>
It's easy to verify this using <a href="https://httpie.org/">httpie</a>:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ http -p b POST :3000/users userId:=<span class="org-highlight-numbers-number">0</span> <span class="org-string">"userName="</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-string">"userId"</span>: <span class="org-highlight-numbers-number">0,</span>
    <span class="org-string">"userName"</span>: <span class="org-string">""</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
$ http -p b GET :3000/users/1
<span class="org-rainbow-delimiters-depth-1">[]</span>
</pre>
</div>

<p>
It's clear that my assumption that <i>User ID</i> starts at 1 is wrong. Luckily
fixing that isn't too difficult. Instead of defining the update function for
<code>addUser</code> as
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">u</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> _o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.insert k n m
  <span class="org-haskell-keyword">where</span>
    k <span class="org-haskell-operator">=</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.keys m<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I define it as
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">u</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> _o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.insert k n m
  <span class="org-haskell-keyword">where</span>
    k <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-highlight-numbers-number">0</span>
      ks <span class="org-haskell-operator">-&gt;</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> ks
</pre>
</div>

<p>
The complete code at this point can be found <a href="https://gist.github.com/8cbbfdb130a173bb51c317df0c00aa15">here</a>.
</p>
</div>
</div>

<div id="outline-container-org9c34f53" class="outline-2">
<h2 id="org9c34f53">Fixing another issue with the model</h2>
<div class="outline-text-2" id="text-org9c34f53">
<p>
With that fix in place another issue with the model shows up
</p>

<pre class="example" id="orga71bb89">
━━━ Main ━━━
  ✗ sequential failed after 74 tests and 2 shrinks.

        ┏━━ tst/test-01.hs ━━━
     91 ┃ getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     92 ┃ getUser = Command gen exec [ Require r
     93 ┃                            , Ensure e
     94 ┃                            ]
     95 ┃   where
     96 ┃     gen (State m) = case M.keys m of
     97 ┃       [] -&gt; Nothing
     98 ┃       ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     99 ┃
    100 ┃     exec (GetUser i) = liftIO $ do
    101 ┃       mgr &lt;- newManager defaultManagerSettings
    102 ┃       getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
    103 ┃       getResp &lt;- httpLbs getReq mgr
    104 ┃       let us = decode $ responseBody getResp :: Maybe [User]
    105 ┃       return (status200 == responseStatus getResp, us)
    106 ┃
    107 ┃     r (State m) (GetUser i) = i `elem` M.keys m
    108 ┃
    109 ┃     e _ _ (GetUser _) (r, us) = do
    110 ┃       r === True
    111 ┃       assert $ isJust us
    112 ┃       (length &lt;$&gt; us) === Just 1
        ┃       ^^^^^^^^^^^^^^^^^^^^^^^^^^
        ┃       │ Failed (- lhs =/= + rhs)
        ┃       │ - Just 0
        ┃       │ + Just 1

        ┏━━ tst/test-01.hs ━━━
    120 ┃ prop_seq :: Property
    121 ┃ prop_seq = property $ do
    122 ┃   actions &lt;- forAll $ Gen.sequential (Range.linear 1 10) initialState [addUser, deleteUser, getUser]
        ┃   │ Var 0 = AddUser ""
        ┃   │ Var 1 = DeleteUser 0
        ┃   │ Var 2 = AddUser ""
        ┃   │ Var 3 = GetUser 0
    123 ┃   resetWS
    124 ┃   executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 73) (Seed 3813043122711576923 (-444438259649958339)) sequential

  ✗ 1 failed.
</pre>

<p>
Again, verifying this using <a href="https://httpie.org/">httpie</a> shows what the issue is
</p>

<div class="org-src-container">
<pre class="src src-shell">$ http -p b POST :3000/users userId:=<span class="org-highlight-numbers-number">0</span> <span class="org-string">"userName="</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-string">"userId"</span>: <span class="org-highlight-numbers-number">0,</span>
    <span class="org-string">"userName"</span>: <span class="org-string">""</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
$ http -p b DELETE :3000/users/0
$ http -p b POST :3000/users userId:=<span class="org-highlight-numbers-number">0</span> <span class="org-string">"userName="</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-string">"userId"</span>: <span class="org-highlight-numbers-number">1,</span>
    <span class="org-string">"userName"</span>: <span class="org-string">""</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
$ http -p b GET :3000/users/0
<span class="org-rainbow-delimiters-depth-1">[]</span>
</pre>
</div>

<p>
In other words, the model assumes that the 0 <i>User ID</i> get's re-used.
</p>

<p>
To fix this I need a bigger change. The central bit is that the state is changed
to keep track of the index more explicitly. That is, it changes from
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
to
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-constructor">Int</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That change does, quite obviously, require a bunch of other changes in the other
functions dealing with the state. The complete file can be viewed <a href="https://gist.github.com/e3c3f4a3c35ab8a529045f90f9f4ba71">here</a>.
</p>
</div>
</div>

<div id="outline-container-org5f32fc1" class="outline-2">
<h2 id="org5f32fc1">All is well, or is it?</h2>
<div class="outline-text-2" id="text-org5f32fc1">
<p>
After this the tests pass, so all is good in the world, right?
</p>

<p>
In the test I defined the <a href="2019-05-30-000-hedgehog-on-a-rest-api.html#MissingReference">property</a> over rather short sequences of commands. What
happens if I increase the (maximum) length of the sequences a bit? Instead using
<code>Range.linear 1 10</code> I'll use <code>Range.linear 1 1000</code>. Well, besides taking
slightly longer to run I get another sequence of commands that triggers an
issue:
</p>

<pre class="example" id="org112d5bd">
━━━ Main ━━━
  ✗ sequential failed after 13 tests and 29 shrinks.

        ┏━━ tst/test-01.hs ━━━
     87 ┃ getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     88 ┃ getUser = Command gen exec [ Require r
     89 ┃                            , Ensure e
     90 ┃                            ]
     91 ┃   where
     92 ┃     gen (State _ m) = case M.keys m of
     93 ┃       [] -&gt; Nothing
     94 ┃       ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     95 ┃
     96 ┃     exec (GetUser i) = liftIO $ do
     97 ┃       mgr &lt;- newManager defaultManagerSettings
     98 ┃       getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
     99 ┃       getResp &lt;- httpLbs getReq mgr
    100 ┃       let us = decode $ responseBody getResp :: Maybe [User]
    101 ┃       return (status200 == responseStatus getResp, us)
    102 ┃
    103 ┃     r (State _ m) (GetUser i) = i `elem` M.keys m
    104 ┃
    105 ┃     e _ _ (GetUser _) (r, us) = do
    106 ┃       r === True
    107 ┃       assert $ isJust us
    108 ┃       (length &lt;$&gt; us) === Just 1
        ┃       ^^^^^^^^^^^^^^^^^^^^^^^^^^
        ┃       │ Failed (- lhs =/= + rhs)
        ┃       │ - Just 0
        ┃       │ + Just 1

        ┏━━ tst/test-01.hs ━━━
    116 ┃ prop_seq :: Property
    117 ┃ prop_seq = property $ do
    118 ┃   actions &lt;- forAll $ Gen.sequential (Range.linear 1 1000) initialState [addUser, deleteUser, getUser]
        ┃   │ Var 0 = AddUser ""
        ┃   │ Var 2 = AddUser ""
        ┃   │ Var 5 = AddUser ""
        ┃   │ Var 7 = AddUser ""
        ┃   │ Var 9 = AddUser ""
        ┃   │ Var 11 = AddUser ""
        ┃   │ Var 20 = AddUser ""
        ┃   │ Var 28 = AddUser ""
        ┃   │ Var 30 = AddUser ""
        ┃   │ Var 32 = AddUser ""
        ┃   │ Var 33 = AddUser ""
        ┃   │ Var 34 = AddUser ""
        ┃   │ Var 37 = AddUser ""
        ┃   │ Var 38 = AddUser ""
        ┃   │ Var 41 = AddUser ""
        ┃   │ Var 45 = AddUser ""
        ┃   │ Var 47 = GetUser 15
    119 ┃   resetWS
    120 ┃   executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 12) (Seed 2976784816810995551 (-47094630645854485)) sequential

  ✗ 1 failed.
</pre>

<p>
That is, after inserting 16 users, we don't see any user when trying to get that
16th user (<i>User ID</i> 15). That's a proper bug in the server.
</p>

<p>
As a matter of fact, this is the bug I put into the server and was hoping to
find. In particular, I wanted <i>hedgehog</i> to find the minimal sequence leading to
this bug.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> Which it clearly has!
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
If you recall from the <a href="2019-05-30-000-hedgehog-on-a-rest-api.html">previous post</a>, I was interested in the integrated
shrinking offered by <i>hedgehog</i>.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hedgehog.html">hedgehog</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>
<div class="post-date">30 May 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-05-30-000-hedgehog-on-a-rest-api.html">Hedgehog on a REST API</a></h1>
<p>
Last year I wrote a little bit about my attempt to use <a href="2018-07-14-000-quickcheck-on-a-rest-api.html"><i>QuickCheck</i> to test a
REST API</a>. Back then I got as far as generating test programs, running them, and
validating an in-test model against the observed behaviour of the web service
under test. One thing that I didn't implement was shrinking. I had some ideas,
and got some better ideas in a comment on that post, but I've not taken the time
to actually sit down and work it out. Then, during this spring, a couple of blog
posts from Oskar Wickström (<a href="https://wickstrom.tech/programming/2019/03/02/property-based-testing-in-a-screencast-editor-introduction.html">intro</a>, <a href="https://wickstrom.tech/programming/2019/03/24/property-based-testing-in-a-screencast-editor-case-study-1.html">part 1</a>, <a href="https://wickstrom.tech/programming/2019/04/17/property-based-testing-in-a-screencast-editor-case-study-2.html">part 2</a>) made me aware of another
library for doing property-based testing, <a href="https://hackage.haskell.org/package/hedgehog"><i>hedgehog</i></a>. It differs quite a bit
from <a href="https://hackage.haskell.org/package/QuickCheck"><i>QuickCheck</i></a>, most notably the way it uses to generate random data, and,
this is the bit that made me sit up and pay attention, it has integrated
shrinking.
</p>

<p>
My first plan was to use the same approach as I used with <i>QuickCheck</i>, but
after finding out that there's explicit support for <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#g:5">state machine tests</a>
everything turned out to be a bit easier than I had expected.
</p>

<p>
Well, it still wasn't exactly easy to work out the details, but the <a href="https://github.com/hedgehogqa/haskell-hedgehog/blob/master/hedgehog-example/src/Test/Example/Registry.hs">registry
example</a> in the <i>hedgehog</i> source repo together with a (slightly dated) <a href="https://teh.id.au/posts/2017/07/15/state-machine-testing/index.html">example</a> I
managed to work it out (I think).
</p>

<div id="outline-container-org2176560" class="outline-2">
<h2 id="org2176560">The REST API</h2>
<div class="outline-text-2" id="text-org2176560">
<p>
The API is the same as in the <a href="http://magnus.therning.org/posts/2018-07-14-000-quickcheck-on-a-rest-api.html">post on using <i>QuickCheck</i></a>, with one little
difference, I've been lazy when implementing <code>GET /users/:id</code> and return a list
of users (that makes it easy to represent a missing <code>:id</code>).
</p>


<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Method</th>
<th scope="col" class="org-left">Route</th>
<th scope="col" class="org-left">Example in</th>
<th scope="col" class="org-left">Example out</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>POST</code></td>
<td class="org-left"><code>/users</code></td>
<td class="org-left"><code>{"userId": 0, "userName": "Yogi Berra"}</code></td>
<td class="org-left"><code>{"userId": 42, "userName": "Yogi Berra"}</code></td>
</tr>

<tr>
<td class="org-left"><code>DELETE</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>[0,3,7]</code></td>
</tr>

<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>[{"userId": 42, "userName": "Yogi Berra"}]</code></td>
</tr>

<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>[]</code> (when there's no user with <code>:id</code>)</td>
</tr>

<tr>
<td class="org-left"><code>POST</code></td>
<td class="org-left"><code>/reset</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org1474dbe" class="outline-2">
<h2 id="org1474dbe">The model state</h2>
<div class="outline-text-2" id="text-org1474dbe">
<p>
Just like last time I'm using as simple a model as I think I can get away with,
based on the API above:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">initialState</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> v
<span class="org-haskell-definition">initialState</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> M.empty
</pre>
</div>

<p>
That extra <code>v</code> is something that <i>hedgehog</i> requires. Why? I don't really know,
and luckily I don't have to care to make it all work. One thing though, the
language pragma <code>KindSignatures</code> is necessary to use that kind of syntax.
</p>
</div>
</div>

<div id="outline-container-org31f59b7" class="outline-2">
<h2 id="org31f59b7">Representing API calls</h2>
<div class="outline-text-2" id="text-org31f59b7">
<p>
Representing an API call requires three things
</p>

<ol class="org-ol">
<li>a type</li>
<li>an implementation of <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:HTraversable"><code>HTraversable</code></a> for the type</li>
<li>a function producing a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Command"><code>Command</code></a> for the type</li>
</ol>

<p>
I represent the three API calls with these three types
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AddUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-constructor">Text</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-constructor">Int</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">GetUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">GetUser</span> <span class="org-haskell-constructor">Int</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Again that <code>v</code> pops up, but as with the model state, there's no need to pay any
attention to it.
</p>

<p>
For the implementation of <code>HTraversable</code> I was greatly helped by the <a href="https://github.com/hedgehogqa/haskell-hedgehog/blob/master/hedgehog-example/src/Test/Example/Registry.hs">registry
example</a>. Their implementations are fairly straight forward, which is a good
thing since the need for them is internal to <i>hedgehog</i>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">AddUser</span> <span class="org-haskell-keyword">where</span>
  htraverse <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> pure n

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-haskell-keyword">where</span>
  htraverse <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> pure i

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">GetUser</span> <span class="org-haskell-keyword">where</span>
  htraverse <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">GetUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">GetUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> pure i
</pre>
</div>

<p>
Once these two things are out of the way we get to the meat of the
implementation of the API calls, a function creating a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Command"><code>Command</code></a> instance for
each type of API call. The exact type for all three functions will be
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">MonadGen</span> n, <span class="org-haskell-constructor">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-constructor">Command</span> n m <span class="org-haskell-constructor">State</span>
</pre>
</div>

<p>
which doesn't say a whole lot, I think. After reading the documentation I found
it a little clearer, but the two examples, <a href="https://teh.id.au/posts/2017/07/15/state-machine-testing/index.html">state machine testing</a> and <a href="https://github.com/hedgehogqa/haskell-hedgehog/blob/master/hedgehog-example/src/Test/Example/Registry.hs">registry</a>,
was what cleared things up for me.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> In an attempt at being overly explicit I
wrote these functions in the same style. This is what it ended up looking like
for the <code>AddUser</code> type:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                           , <span class="org-haskell-constructor">Ensure</span> e
                           <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.text <span class="org-rainbow-delimiters-depth-1">(</span>Range.linear <span class="org-highlight-numbers-number">0</span> <span class="org-highlight-numbers-number">42</span><span class="org-rainbow-delimiters-depth-1">)</span> Gen.alpha

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      addReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/users"</span>
      <span class="org-haskell-keyword">let</span> addReq' <span class="org-haskell-operator">=</span> addReq <span class="org-rainbow-delimiters-depth-1">{</span> requestBody <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RequestBodyLBS</span> <span class="org-rainbow-delimiters-depth-2">(</span>encode <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">User</span> <span class="org-highlight-numbers-number">0</span> n<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>
      addResp <span class="org-haskell-operator">&lt;-</span> httpLbs addReq' mgr
      <span class="org-haskell-keyword">let</span> user <span class="org-haskell-operator">=</span> decode <span class="org-rainbow-delimiters-depth-1">(</span>responseBody addResp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">User</span>
      return <span class="org-rainbow-delimiters-depth-1">(</span>responseStatus addResp, user<span class="org-rainbow-delimiters-depth-1">)</span>

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> _o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.insert k n m
      <span class="org-haskell-keyword">where</span>
        k <span class="org-haskell-operator">=</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.keys m<span class="org-rainbow-delimiters-depth-1">)</span>

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>r, ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      r <span class="org-haskell-operator">===</span> status201
      assert <span class="org-haskell-operator">$</span> isJust ui
      <span class="org-rainbow-delimiters-depth-1">(</span>userName <span class="org-haskell-operator">&lt;$&gt;</span> ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">Just</span> n
</pre>
</div>

<p>
Piece by piece:
</p>

<ol class="org-ol">
<li><code>gen</code> is the generator of data. It takes one argument, the current state, but
for <code>AddUser</code> I have no use for it. The user name is generated using a
generator for <code>Text</code>, and rather arbitrarily I limit the names to 42
characters.</li>
<li><code>exec</code> is the action that calls the web service. Here I'm using <a href="https://hackage.haskell.org/package/http-client">http-client</a>
to make the call and <a href="https://hackage.haskell.org/package/aeson">aeson</a> to parse the response into a <code>User</code>. It produces
<i>output</i>.</li>
<li><code>u</code> is a function for updating the model state. It's given the current state,
the command and the <i>output</i>. All I need to to do for <code>AddUser</code> is to pick a
<code>userId</code> and associate it with the generated name.</li>
<li><code>e</code> is a function for checking post-conditions, in other words checking
properties that must hold after <code>exec</code> has run and the state has been
updated. It's given four arguments, the previous state, the updated state,
the command and the <i>output</i>. The tests here are on the HTTP response code
and the returned user name. I think that will do for the time being.</li>
</ol>

<p>
The function for <code>DeleteUser</code> follows the same pattern
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                              , <span class="org-haskell-constructor">Require</span> r
                              , <span class="org-haskell-constructor">Ensure</span> e
                              <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
      ks <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.element ks

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      delReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"DELETE http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show i
      delResp <span class="org-haskell-operator">&lt;-</span> httpNoBody delReq mgr
      return <span class="org-haskell-operator">$</span> responseStatus delResp

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.delete i m

    r <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> i <span class="org-haskell-operator">`elem`</span> M.keys m

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> r <span class="org-haskell-operator">=</span> r <span class="org-haskell-operator">===</span> status200
</pre>
</div>

<p>
I think only two pieces need further explanation:
</p>

<ol class="org-ol">
<li><code>gen</code> only returns a <code>DeleteUser</code> with an index actually present in the model
state. If there are no users in the model then <code>Nothing</code> is returned. As far
as I understand that means that generated programs will only make calls to
delete existing users.<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup></li>
<li><code>r</code> is a pre-condition that programs only delete users that exist. At first I
had skipped this pre-condition, thinking that it'd be enough to have <code>gen</code>
only create delete calls for existing users. However, after reading the
documentation of <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Command"><code>Command</code></a> and <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Callback"><code>Callback</code></a> a bit more closely I realised that
I might need a pre-condition to make sure that this holds true also while
shrinking.</li>
</ol>

<p>
The final function, for <code>GetUser</code> requires no further explanation so I only
present it here
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">getUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">getUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Require</span> r
                           , <span class="org-haskell-constructor">Ensure</span> e
                           <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
      ks <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">GetUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.element ks

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">GetUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      getReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"GET http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show i
      getResp <span class="org-haskell-operator">&lt;-</span> httpLbs getReq mgr
      <span class="org-haskell-keyword">let</span> us <span class="org-haskell-operator">=</span> decode <span class="org-haskell-operator">$</span> responseBody getResp <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">User</span><span class="org-rainbow-delimiters-depth-1">]</span>
      return <span class="org-rainbow-delimiters-depth-1">(</span>status200 <span class="org-haskell-operator">==</span> responseStatus getResp, us<span class="org-rainbow-delimiters-depth-1">)</span>

    r <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">GetUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> i <span class="org-haskell-operator">`elem`</span> M.keys m

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">GetUser</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>r, us<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      r <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">True</span>
      assert <span class="org-haskell-operator">$</span> isJust us
      <span class="org-rainbow-delimiters-depth-1">(</span>length <span class="org-haskell-operator">&lt;$&gt;</span> us<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">Just</span> <span class="org-highlight-numbers-number">1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org17f0c42" class="outline-2">
<h2 id="org17f0c42">The property and test</h2>
<div class="outline-text-2" id="text-org17f0c42">
<p>
It looks like there are two obvious top-level properties
</p>

<ol class="org-ol">
<li>the web service works as expected when all calls are made one at a time
(sequential), and</li>
<li>the web service works as expected when all calls are made in parallel.</li>
</ol>

<p>
<i>Hedgehog</i> provides two pairs of functions for this
</p>

<ol class="org-ol">
<li>a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog-Gen.html#v:sequential"><code>sequential</code> generator</a> with <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#v:executeSequential"><code>executeSequential</code></a>, and</li>
<li>a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog-Gen.html#v:parallel"><code>parallel</code> generator</a> with <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#v:executeParallel"><code>executeParallel</code></a>.</li>
</ol>

<p>
I started with the former only
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">prop_seq</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Property</span>
<span class="org-haskell-definition">prop_seq</span> <span class="org-haskell-operator">=</span> property <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  actions <span class="org-haskell-operator">&lt;-</span> forAll <span class="org-haskell-operator">$</span> Gen.sequential <span class="org-rainbow-delimiters-depth-1">(</span>Range.linear <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-1">)</span> initialState <span class="org-rainbow-delimiters-depth-1">[</span>addUser, deleteUser, getUser<span class="org-rainbow-delimiters-depth-1">]</span>
  resetWS
  executeSequential initialState actions
</pre>
</div>

<p>
This first creates a generator of programs of at most length 10<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>, then
turning that into a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Sequential"><code>Sequential</code></a> which can be passed to <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#v:executeSequential"><code>executeSequential</code></a> to
turn into a <a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#t:Property"><code>Property</code></a>.
</p>

<p>
The function <code>resetWS</code> clears out the web service to make sure that the tests
start with a clean slate each time. Its definition is
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">resetWS</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">resetWS</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
  resetReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/reset"</span>
  void <span class="org-haskell-operator">$</span> httpNoBody resetReq mgr
</pre>
</div>

<p>
The final bit is the <code>main</code> function, which I wrote like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  res <span class="org-haskell-operator">&lt;-</span> checkSequential <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Group</span> <span class="org-string">"Main"</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"sequential"</span>, prop_seq<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
  unless res exitFailure
</pre>
</div>

<p>
That is, first run the property sequentially (<a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#v:checkSequential"><code>checkSequential</code></a>) and if that
fails exit with failure.
</p>
</div>
</div>

<div id="outline-container-orgde41804" class="outline-2">
<h2 id="orgde41804">Running the test</h2>
<div class="outline-text-2" id="text-orgde41804">
<p>
When running the test fails and gives me a program that breaks the property, and
exactly what fails:
</p>

<pre class="example" id="orgcb6c8d9">
━━━ Main ━━━
  ✗ sequential failed after 13 tests and 1 shrink.

        ┏━━ tst/test-01.hs ━━━
     89 ┃ getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     90 ┃ getUser = Command gen exec [ Require r
     91 ┃                            , Ensure e
     92 ┃                            ]
     93 ┃   where
     94 ┃     gen (State m) = case M.keys m of
     95 ┃       [] -&gt; Nothing
     96 ┃       ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     97 ┃
     98 ┃     exec (GetUser i) = liftIO $ do
     99 ┃       mgr &lt;- newManager defaultManagerSettings
    100 ┃       getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
    101 ┃       getResp &lt;- httpLbs getReq mgr
    102 ┃       let us = decode $ responseBody getResp :: Maybe [User]
    103 ┃       return (status200 == responseStatus getResp, us)
    104 ┃
    105 ┃     r (State m) (GetUser i) = i `elem` M.keys m
    106 ┃
    107 ┃     e _ _ (GetUser _) (r, us) = do
    108 ┃       r === True
    109 ┃       assert $ isJust us
    110 ┃       (length &lt;$&gt; us) === Just 1
        ┃       ^^^^^^^^^^^^^^^^^^^^^^^^^^
        ┃       │ Failed (- lhs =/= + rhs)
        ┃       │ - Just 0
        ┃       │ + Just 1

        ┏━━ tst/test-01.hs ━━━
    118 ┃ prop_seq :: Property
    119 ┃ prop_seq = property $ do
    120 ┃   actions &lt;- forAll $ Gen.sequential (Range.linear 1 10) initialState [addUser, deleteUser, getUser]
        ┃   │ Var 0 = AddUser ""
        ┃   │ Var 1 = GetUser 1
    121 ┃   resetWS
    122 ┃   executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 12) (Seed 6041776208714975061 (-2279196309322888437)) sequential

  ✗ 1 failed.
</pre>

<p>
My goodness, that is pretty output!
</p>

<p>
Anyway, I'd say that the failing program has been shrunk to be minimal so I'd
say that all in all this is a big step up from what I had earlier. Sure, using
the <i>hedgehog</i> state machine API is slightly involved, but once worked out I
find it fairly straight-forward and it most likely is written by people much
more knowledgable than me and better than anything I could produce. Having to
use generators explicitly (the <i>hedgehog</i> way) is neither easier nor more
complicated than defining a few type class instances (the <i>QuickCheck</i> way).
Finally, the integrated shrinking is rather brilliant and <i>not</i> having to
implement that myself is definitely a big benefit.
</p>

<p>
Now I only have to fix the errors in the web service that the test reveal. This
post is already rather long, so I'll keep that for a future post.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
There is still one thing that's unclear to me though, and that's how to
get to the output in an update function.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Put another way, programs will never test how the web service behaves
when asking for non-existing users. I think that, if I want to test that, I'll
opt for using a separate API call type for it.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
At least that's my understanding of the impact of <code>Range.linear 1 10</code>.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hedgehog.html">hedgehog</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>
<div class="post-date">22 Apr 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-04-22-000-comonadic-builders--minor-addition.html">Comonadic builders, minor addition</a></h1>
<p>
When reading about <a href="https://chshersh.github.io/posts/2019-03-25-comonadic-builders">Comonadic builders</a> the other day I reacted to this comment:
</p>

<blockquote>
<p>
The <code>comonad</code> package has the <a href="https://hackage.haskell.org/package/comonad-5.0.4/docs/Control-Comonad-Trans-Traced.html#t:TracedT">Traced</a> <code>newtype</code> wrapper around the function
<code>(-&gt;)</code>. The <code>Comonad</code> instance for this <code>newtype</code> gives us the desired
behaviour. However, dealing with the <code>newtype</code> wrapping and unwrapping makes our
code noisy and truly harder to understand, so let's use the <code>Comonad</code> instance
for the arrow <code>(-&gt;)</code> itself
</p>
</blockquote>

<p>
So, just for fun I thought I work out the "noisy and truly harder" bits.
</p>

<p>
To begin with I needed two language extensions and two imports
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE OverloadedStrings#-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE RecordWildCards #-}</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Control.Comonad.Traced</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Text</span>
</pre>
</div>

<p>
After that I could copy quite a bit of stuff directly from the other post
</p>

<ul class="org-ul">
<li><code>Settings</code> definition</li>
<li>The <code>Semigroup</code> instance for <code>Settings</code></li>
<li>The <code>Monoid</code> instance for <code>Settings</code></li>
<li><code>Project</code> definition</li>
</ul>

<p>
After this everything had only minor changes. First off the <code>ProjectBuilder</code>
type had to be changed to
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">ProjectBuilder</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">Traced</span> <span class="org-haskell-type">Settings</span> <span class="org-haskell-type">Project</span>
</pre>
</div>

<p>
With that done the types of all the functions can actually be left as they are,
but of course the definitions have to modified. However, it turned out that the
necessary modifications were rather smaller than I had expected. First out
<code>buildProject</code> which I decided to call <code>buildProjectW</code> to make it possible to
keep the original code and the new code in the same file without causing name
clashes:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">buildProjectW</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ProjectBuilder</span>
<span class="org-haskell-definition">buildProjectW</span> <span class="org-haskell-operator">=</span> traced <span class="org-haskell-operator">.</span> buildProject
  <span class="org-haskell-keyword">where</span>
    buildProject projectName <span class="org-haskell-constructor">Settings</span><span class="org-rainbow-delimiters-depth-1">{</span><span class="org-haskell-operator">..</span><span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Project</span>
      <span class="org-rainbow-delimiters-depth-1">{</span> projectHasLibrary <span class="org-haskell-operator">=</span> getAny settingsHasLibrary
      , projectGitHub     <span class="org-haskell-operator">=</span> getAny settingsGitHub
      , projectTravis     <span class="org-haskell-operator">=</span> getAny settingsTravis
      , <span class="org-haskell-operator">..</span>
      <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The only difference is the addition of <code>traced .</code> to wrap it up in the
<code>newtype</code>, the rest is copied straight from the original article.
</p>

<p>
The two simple project combinator functions, which I call <code>hasLibraryBW</code> and
<code>gitHubBW</code>, needed a bit of tweaking. In the original version combinators take a
<code>builder</code> which is an ordinary function, so it can just be called. Now however,
the function is wrapped in a <code>newtype</code> so a bit of unwrapping is necessary:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">hasLibraryBW</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ProjectBuilder</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Project</span>
<span class="org-haskell-definition">hasLibraryBW</span> builder <span class="org-haskell-operator">=</span> runTraced builder <span class="org-haskell-operator">$</span> mempty <span class="org-rainbow-delimiters-depth-1">{</span> settingsHasLibrary <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Any</span> <span class="org-haskell-constructor">True</span> <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-haskell-definition">gitHubBW</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ProjectBuilder</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Project</span>
<span class="org-haskell-definition">gitHubBW</span> builder <span class="org-haskell-operator">=</span> runTraced builder <span class="org-haskell-operator">$</span> mempty <span class="org-rainbow-delimiters-depth-1">{</span> settingsGitHub <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Any</span> <span class="org-haskell-constructor">True</span> <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Once again it's rather small differences from the code in the article.
</p>

<p>
As for the final combinator, which I call <code>travisBW</code>, actually needed no changes
at all. I only rewrote it using a <code>when</code> clause, because I prefer that style
over <code>let</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">travisBW</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ProjectBuilder</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Project</span>
<span class="org-haskell-definition">travisBW</span> builder <span class="org-haskell-operator">=</span> project <span class="org-rainbow-delimiters-depth-1">{</span> projectTravis <span class="org-haskell-operator">=</span> projectGitHub project <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">where</span>
    project <span class="org-haskell-operator">=</span> extract builder
</pre>
</div>

<p>
Finally, to show that this implementation hasn't really changed the behaviour
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">&#955;</span> extract <span class="org-haskell-operator">$</span> buildProjectW <span class="org-string">"travis"</span> <span class="org-haskell-operator">=&gt;&gt;</span> travisBW
<span class="org-haskell-constructor">Project</span> <span class="org-rainbow-delimiters-depth-1">{</span> projectName <span class="org-haskell-operator">=</span> <span class="org-string">"travis"</span>
        , projectHasLibrary <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
        , projectGitHub <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
        , projectTravis <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
        <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-haskell-definition">&#955;</span> extract <span class="org-haskell-operator">$</span> buildProjectW <span class="org-string">"github-travis"</span> <span class="org-haskell-operator">=&gt;&gt;</span> gitHubBW <span class="org-haskell-operator">=&gt;&gt;</span> travisBW
<span class="org-haskell-constructor">Project</span> <span class="org-rainbow-delimiters-depth-1">{</span> projectName <span class="org-haskell-operator">=</span> <span class="org-string">"github-travis"</span>
        , projectHasLibrary <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
        , projectGitHub <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
        , projectTravis <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
        <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-haskell-definition">&#955;</span> extract <span class="org-haskell-operator">$</span> buildProjectW <span class="org-string">"travis-github"</span> <span class="org-haskell-operator">=&gt;&gt;</span> travisBW <span class="org-haskell-operator">=&gt;&gt;</span> gitHubBW
<span class="org-haskell-constructor">Project</span> <span class="org-rainbow-delimiters-depth-1">{</span> projectName <span class="org-haskell-operator">=</span> <span class="org-string">"travis-github"</span>
        , projectHasLibrary <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
        , projectGitHub <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
        , projectTravis <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
        <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-comonad.html">comonad</a> <a href="https://magnus.therning.org/tag-builder_pattern.html">builder_pattern</a> </div>
<div class="post-date">03 Mar 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-03-03-000-conduit-and-postgresql.html">Conduit and PostgreSQL</a></h1>
<p>
For a while now I've been playing around with an event-drive software design
(<a href="https://en.wikipedia.org/wiki/Event-driven_architecture">EDA</a>) using <a href="https://hackage.haskell.org/package/conduit"><code>conduit</code></a> for processing of events. For this post the processing can
basically be viewed as the following diagram
</p>

<pre class="example" id="org234dea9">
+-----------+   +------------+   +---------+
|           |   |            |   |         |
| PG source |--&gt;| Processing |--&gt;| PG sink |
|           |   |            |   |         |
+-----------+   +------------+   +---------+
     ^                                |
     |            +------+            |
     |            |      |            |
     |            |  PG  |            |
     +------------|  DB  |&lt;-----------+
                  |      |
                  +------+
</pre>

<p>
I started out looking for Conduit components for PostgreSQL on <a href="https://hackage.haskell.org/">Hackage</a> but
failed to find something fitting so I started looking into writing them myself
using <a href="https://hackage.haskell.org/package/postgresql-simple"><code>postgresql-simple</code></a>.
</p>

<p>
The sink wasn't much of a problem, use <code>await</code> to get an event (a tuple) and
write it to the database. My almost complete ignorance of using databases
resulted in a first version of the source was rather naive and used
busy-waiting. Then I stumbled on PostgreSQL's support for notifications through
the <code>LISTEN</code> and <code>NOTIFY</code> commands. I rather like the result and it seems to
work well.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<p>
It looks like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Control.Monad.IO.Class</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">MonadIO</span>, liftIO<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Data.Aeson</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Value</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Conduit</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">C</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Conduit.Combinators</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">CC</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Data.Text</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Data.Time.Clock</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">UTCTime</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Data.UUID</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">UUID</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Database.PostgreSQL.Simple</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Connection</span>, <span class="org-haskell-constructor">Only</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">..</span><span class="org-rainbow-delimiters-depth-2">)</span>, execute, execute_, query<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Database.PostgreSQL.Simple.Notification</span> <span class="org-rainbow-delimiters-depth-1">(</span>getNotification<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">fst8</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span>a, b, c, d, e, f, g, h<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> a
<span class="org-haskell-definition">fst8</span> <span class="org-rainbow-delimiters-depth-1">(</span>a, <span class="org-haskell-keyword">_</span>, <span class="org-haskell-keyword">_</span>, <span class="org-haskell-keyword">_</span>, <span class="org-haskell-keyword">_</span>, <span class="org-haskell-keyword">_</span>, <span class="org-haskell-keyword">_</span>, <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> a

<span class="org-haskell-definition">dbSource</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Connection</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">C.ConduitT</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Int</span>, <span class="org-haskell-type">UTCTime</span>, <span class="org-haskell-type">Int</span>, <span class="org-haskell-type">Int</span>, <span class="org-haskell-type">Bool</span>, <span class="org-haskell-type">UUID</span>, <span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Value</span><span class="org-rainbow-delimiters-depth-1">)</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">dbSource</span> conn ver <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  res <span class="org-haskell-operator">&lt;-</span> liftIO <span class="org-haskell-operator">$</span> query conn <span class="org-string">"SELECT * from events where id &gt; (?) ORDER BY id"</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Only</span> ver<span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">case</span> res <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      liftIO <span class="org-haskell-operator">$</span> execute_ conn <span class="org-string">"LISTEN MyEvent"</span>
      liftIO <span class="org-haskell-operator">$</span> getNotification conn
      dbSource conn ver
    <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      <span class="org-haskell-keyword">let</span> ver' <span class="org-haskell-operator">=</span> maximum <span class="org-haskell-operator">$</span> map fst8 res
      CC.yieldMany res
      dbSource conn ver'

<span class="org-haskell-definition">dbSink</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Connection</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">C.ConduitT</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Int</span>, <span class="org-haskell-type">Int</span>, <span class="org-haskell-type">Bool</span>, <span class="org-haskell-type">UUID</span>, <span class="org-haskell-type">Text</span>, <span class="org-haskell-type">Value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-type">C.Void</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">dbSink</span> conn <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  evt <span class="org-haskell-operator">&lt;-</span> C.await
  <span class="org-haskell-keyword">case</span> evt <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-haskell-constructor">Just</span> event <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      liftIO <span class="org-haskell-operator">$</span> execute conn <span class="org-string">"INSERT INTO events \</span>
<span class="org-string">                            \(srv_id, stream_id, cmd, cmd_id, correlation_id, event_data) \</span>
<span class="org-string">                            \VALUES (?, ?, ?, ?, ?, ?)"</span> event
      liftIO <span class="org-haskell-operator">$</span> execute_ conn <span class="org-string">"NOTIFY MyEvent"</span>
      dbSink conn
</pre>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
If I've missed something crucial I would of course love to hear about it.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> <a href="https://magnus.therning.org/tag-event_sourcing.html">event_sourcing</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-postgresql.html">postgresql</a> </div>
<div class="post-date">17 Feb 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-02-17-000-choosing-a-conduit-randomly.html">Choosing a conduit randomly</a></h1>
<p>
Lately I've been playing around <a href="https://hackage.haskell.org/package/conduit">conduit</a>. One thing I wanted to try out was to
set up processing where one processing step was chosen on random from a number
of components, based on weights. In short I guess I wanted a function with a
type something like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Int</span>, <span class="org-haskell-type">ConduitT</span> i o m r<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ConduitT</span> i o m r
</pre>
</div>

<p>
I have to admit I don't even know where to start writing such a function<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
but after a little bit of thinking I realised I could get the same effect by
controlling how chunks of data is routed. That is, instead of choosing a
component randomly, I can choose a route randomly. It would look something like
when choosing from three components
</p>

<pre class="example" id="org60d40ef">
                        +---------+   +----------+   +-------------+
                        | Filter  |   | Drop tag |   | Component A |
                    +--&gt;| Value-0 |--&gt;|          |--&gt;|             |--+
                    |   +---------+   +----------+   +-------------+  |
+----------------+  |   +---------+   +----------+   +-------------+  |
| Choose random  |  |   | Filter  |   | Drop tag |   | Component B |  |
| value based on +-----&gt;| Value-1 |--&gt;|          |--&gt;|             |-----&gt;
| weights        |  |   +---------+   +----------+   +-------------+  |
+----------------+  |   +---------+   +----------+   +-------------+  |
                    |   | Filter  |   | Drop tag |   | Component C |  |
                    +--&gt;| Value-2 |--&gt;|          |--&gt;|             |--+
                        +---------+   +----------+   +-------------+
</pre>

<p>
That is
</p>

<ol class="org-ol">
<li>For each chunk that comes in, choose a value randomly based on weights and
tag the chunk with the choosen value, then</li>
<li>split the processing into one route for each component,</li>
<li>in each route filter out chunks tagged with a single value, and</li>
<li>remove the tag, then</li>
<li>pass the chunk to the component, and finally</li>
<li>bring the routes back together again.</li>
</ol>

<p>
Out of these steps all but the very first one are already available in <a href="https://hackage.haskell.org/package/conduit">conduit</a>:
</p>

<ul class="org-ul">
<li>for splitting routes combining them again, use <a href="https://hackage.haskell.org/package/conduit-1.3.1/docs/Data-Conduit.html#v:sequenceConduits"><code>sequenceConduits</code></a></li>
<li>for filtering, use <a href="https://hackage.haskell.org/package/conduit-1.3.1/docs/Data-Conduit-Combinators.html#v:filter"><code>filter</code></a></li>
<li>for dropping the tag, use <a href="https://hackage.haskell.org/package/conduit-1.3.1/docs/Data-Conduit-Combinators.html#v:map"><code>map</code></a></li>
</ul>

<p>
What's left is the beginning. I started with a function to pick a value on
random based on weights<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">pickByWeight</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Int</span>, b<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> b
<span class="org-haskell-definition">pickByWeight</span> xs <span class="org-haskell-operator">=</span> randomRIO <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">1</span>, tot<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span> n <span class="org-haskell-operator">-&gt;</span> return <span class="org-rainbow-delimiters-depth-1">(</span>pick n xs<span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">where</span>
    tot <span class="org-haskell-operator">=</span> sum <span class="org-haskell-operator">$</span> map fst xs

    pick n <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>k, x<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-haskell-constructor">:</span>xs<span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-operator">|</span> n <span class="org-haskell-operator">&lt;=</span> k <span class="org-haskell-operator">=</span> x
      <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> pick <span class="org-rainbow-delimiters-depth-1">(</span>n <span class="org-haskell-operator">-</span> k<span class="org-rainbow-delimiters-depth-1">)</span> xs
    pick <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> error <span class="org-string">"pick error"</span>
</pre>
</div>

<p>
Using that I then made a component that tags chunks
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">picker</span> ws <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  evt <span class="org-haskell-operator">&lt;-</span> await
  <span class="org-haskell-keyword">case</span> evt <span class="org-haskell-keyword">of</span>
    <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-haskell-constructor">Just</span> e <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
      p <span class="org-haskell-operator">&lt;-</span> liftIO <span class="org-haskell-operator">$</span> pickByWeight ws
      yield <span class="org-rainbow-delimiters-depth-1">(</span>p, e<span class="org-rainbow-delimiters-depth-1">)</span>
      picker ws
</pre>
</div>

<p>
I was rather happy with this&#x2026;
</p>

<blockquote>
<p>
<a href="https://twitter.com/snoyberg">@snoyberg</a> just have to let you know, conduit is a joy to use. Thanks for sharing it.
</p>

<p>
&#x2013; Magnus Therning (<a href="https://twitter.com/magthe">@magthe</a>) <a href="https://twitter.com/magthe/status/1093175648993140736">February 6, 2019</a>
</p>
</blockquote>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Except maybe by using Template Haskell to generate the code I did come up
with.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
I used <code>Quickcheck</code>'s <a href="https://hackage.haskell.org/package/QuickCheck-2.12.6.1/docs/Test-QuickCheck-Gen.html#v:frequency"><code>frequency</code></a> as inspiration for writing it.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> </div>
<div class="post-date">10 Feb 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-02-10-000-using-stack-to-get-around-upstream-bugs.html">Using stack to get around upstream bugs</a></h1>
<p>
Recently I bumped into <a href="https://github.com/brendanhay/amazonka/issues/517">a bug in <i>amazonka</i></a>.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> I can't really sit around
waiting for Amazon to fix it, and then for <i>amazonka</i> to use the fixed
documentation to generate the code and make another release.
</p>

<p>
Luckily <a href="https://docs.haskellstack.org/en/stable/README/"><code>stack</code></a> contains features that make it fairly simple to work around this
bug until it's properly fixed. Here's how.
</p>

<ol class="org-ol">
<li>Put the upstream code in a git repository of your own. In my case I simply
forked the <a href="https://github.com/brendanhay/amazonka"><i>amazonka</i> repository on github</a> (my fork is <a href="https://github.com/magthe/amazonka">here</a>).</li>

<li>Fix the bug and commit the change. <a href="https://github.com/magthe/amazonka/commit/1543b65e3a8b692aa9038ada68aaed9967752983">My change to <i>amazonka-codepipeline</i></a> was
simply to remove the missing fields &#x2013; it was easier than trying to make them
optional (i.e. wrapping them in =Maybe=s).</li>

<li>Tell <code>slack</code> to use the code from your modified git repository. In my case I
added the following to my <code>slack.yaml</code>:</li>
</ol>

<pre class="example" id="org3a0d6eb">
extra-deps:
  - github: magthe/amazonka
    commit: 1543b65e3a8b692aa9038ada68aaed9967752983
    subdirs:
      - amazonka-codepipeline
</pre>

<p>
That's it!
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
The guilty party is Amazon, not <i>amazonka</i>, though I was a little
surprised that there doesn't seem to be any established way to modify the Amazon
API documentation before it's used to autogenerate the Haskell code.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-amazonka.html">amazonka</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-stack.html">stack</a> </div>
<div class="post-date">02 Feb 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-02-02-000-the-readert-design-pattern-or-tagless-final-.html">The ReaderT design pattern or tagless final?</a></h1>
<p>
The other week I read V. Kevroletin's <a href="https://serokell.io/blog/2018/12/07/tagless-final">Introduction to Tagless Final</a> and realised
that a couple of my projects, both at work and at home, would benefit from a
refactoring to that approach. All in all I was happy with the changes I made,
even though I haven't made use of all the way. In particular there I could
further improve the tests in a few places by adding more typeclasses. For now
it's good enough and I've clearly gotten some value out of it.
</p>

<p>
I found mr. Kevroletin's article to be a good introduction so I've been passing
it on when people on the <a href="https://functionalprogramming.slack.com/">Functional programming slack</a> bring up questions about
how to organize their code as applications grow. In particular if they mention
that they're using monad transformers. I did exactly that just the other day
<i>@solomon</i> wrote
</p>

<blockquote>
<p>
so i've created a rats nest of IO where almost all the functions in my program
are in <code>ReaderT Env IO ()</code> and I'm not sure how to purify everything and move
the IO to the edge of the program
</p>
</blockquote>

<p>
I proposed tagless final and passed the URL on, and then I got a pointer to the
article <a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">The ReaderT Design Patter</a> which I hadn't seen before.
</p>

<p>
The two approches are similar, at least to me, and I can't really judge if one's
better than the other. Just to get a feel for it I thought I'd try to rewrite
the example in the <code>ReaderT</code> article in a tagless final style.
</p>

<div id="outline-container-org6b0a206" class="outline-2">
<h2 id="org6b0a206">A slightly changed example of <code>ReaderT</code> design pattern</h2>
<div class="outline-text-2" id="text-org6b0a206">
<p>
I decided to make a few changes to the example in the article:
</p>

<ul class="org-ul">
<li>I removed the <code>modify</code> function, instead the code uses the typeclass function
<code>modifyBalance</code> directly.</li>
<li>I separated the instances needed for the tests spatially in the code just to
make it easier to see what's "production" code and what's test code.</li>
<li>I combined the <code>main</code> functions from the various examples to that both an
example (<code>main0</code>) and the test (<code>main1</code>) are run.</li>
<li>I switched from <code>Control.Concurrent.Async.Lifted.Safe</code> (from <code>monad-control</code>)
to <code>UnliftIO.Async</code> (from <code>unliftio</code>)</li>
</ul>

<p>
After that the code looks like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE FlexibleInstances #-}</span>

<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Control.Concurrent.STM</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Control.Monad.Reader</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Control.Monad.State.Strict</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">State</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Say</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Test.Hspec</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">UnliftIO.Async</span>

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Env</span>
  <span class="org-rainbow-delimiters-depth-1">{</span> envLog <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">!</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-3">()</span></span><span class="org-rainbow-delimiters-depth-2">)</span>
  , envBalance <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">!</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">TVar</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-haskell-keyword">class</span> <span class="org-haskell-type">HasLog</span> a <span class="org-haskell-keyword">where</span>
  getLog <span class="org-haskell-operator">::</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HasLog</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-keyword">where</span>
  getLog <span class="org-haskell-operator">=</span> envLog

<span class="org-haskell-keyword">class</span> <span class="org-haskell-type">HasBalance</span> a <span class="org-haskell-keyword">where</span>
  getBalance <span class="org-haskell-operator">::</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">TVar</span> <span class="org-haskell-type">Int</span>

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HasBalance</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-keyword">where</span>
  getBalance <span class="org-haskell-operator">=</span> envBalance

<span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadBalance</span> m <span class="org-haskell-keyword">where</span>
  modifyBalance <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>

<span class="org-haskell-keyword">instance</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">HasBalance</span> env, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadBalance</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">ReaderT</span> env m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  modifyBalance f <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    env <span class="org-haskell-operator">&lt;-</span> ask
    liftIO <span class="org-haskell-operator">$</span> atomically <span class="org-haskell-operator">$</span> modifyTVar' <span class="org-rainbow-delimiters-depth-1">(</span>getBalance env<span class="org-rainbow-delimiters-depth-1">)</span> f

<span class="org-haskell-definition">logSomething</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadReader</span> env m, <span class="org-haskell-type">HasLog</span> env, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">logSomething</span> msg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  env <span class="org-haskell-operator">&lt;-</span> ask
  liftIO <span class="org-haskell-operator">$</span> getLog env msg

<span class="org-haskell-definition">main0</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main0</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  ref <span class="org-haskell-operator">&lt;-</span> newTVarIO <span class="org-highlight-numbers-number">4</span>
  <span class="org-haskell-keyword">let</span> env <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Env</span> <span class="org-rainbow-delimiters-depth-1">{</span> envLog <span class="org-haskell-operator">=</span> sayString , envBalance <span class="org-haskell-operator">=</span> ref <span class="org-rainbow-delimiters-depth-1">}</span>
  runReaderT
    <span class="org-rainbow-delimiters-depth-1">(</span>concurrently_
      <span class="org-rainbow-delimiters-depth-2">(</span>modifyBalance <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">+</span> <span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
      <span class="org-rainbow-delimiters-depth-2">(</span>logSomething <span class="org-string">"Increasing account balance"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
    env
  balance <span class="org-haskell-operator">&lt;-</span> readTVarIO ref
  sayString <span class="org-haskell-operator">$</span> <span class="org-string">"Final balance: "</span> <span class="org-haskell-operator">++</span> show balance

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HasLog</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  getLog <span class="org-haskell-operator">=</span> id

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HasBalance</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">TVar</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  getBalance <span class="org-haskell-operator">=</span> id

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadBalance</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">State.StateT</span> <span class="org-haskell-type">Int</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  modifyBalance <span class="org-haskell-operator">=</span> State.modify

<span class="org-haskell-definition">main1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main1</span> <span class="org-haskell-operator">=</span> hspec <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  describe <span class="org-string">"modify"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    it <span class="org-string">"works, IO"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      var <span class="org-haskell-operator">&lt;-</span> newTVarIO <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>
      runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>modifyBalance <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">+</span> <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> var
      res <span class="org-haskell-operator">&lt;-</span> readTVarIO var
      res <span class="org-haskell-operator">`shouldBe`</span> <span class="org-highlight-numbers-number">3</span>
    it <span class="org-string">"works, pure"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      <span class="org-haskell-keyword">let</span> res <span class="org-haskell-operator">=</span> State.execState <span class="org-rainbow-delimiters-depth-1">(</span>modifyBalance <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">+</span> <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>
      res <span class="org-haskell-operator">`shouldBe`</span> <span class="org-highlight-numbers-number">3</span>
  describe <span class="org-string">"logSomething"</span> <span class="org-haskell-operator">$</span>
    it <span class="org-string">"works"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      var <span class="org-haskell-operator">&lt;-</span> newTVarIO <span class="org-string">""</span>
      <span class="org-haskell-keyword">let</span> logFunc msg <span class="org-haskell-operator">=</span> atomically <span class="org-haskell-operator">$</span> modifyTVar var <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">++</span> msg<span class="org-rainbow-delimiters-depth-1">)</span>
          msg1 <span class="org-haskell-operator">=</span> <span class="org-string">"Hello "</span>
          msg2 <span class="org-haskell-operator">=</span> <span class="org-string">"World\n"</span>
      runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>logSomething msg1 <span class="org-haskell-operator">&gt;&gt;</span> logSomething msg2<span class="org-rainbow-delimiters-depth-1">)</span> logFunc
      res <span class="org-haskell-operator">&lt;-</span> readTVarIO var
      res <span class="org-haskell-operator">`shouldBe`</span> <span class="org-rainbow-delimiters-depth-1">(</span>msg1 <span class="org-haskell-operator">++</span> msg2<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> main0 <span class="org-haskell-operator">&gt;&gt;</span> main1
</pre>
</div>

<p>
I think the distinguising features are
</p>

<ul class="org-ul">
<li>The application environmant, <code>Env</code> will contain configuraiton values (not in
this example), state, <code>envBalance</code>, and functions we might want to vary,
<code>envLog</code></li>
<li>There is no explicit type representing the execution context</li>
<li>Typeclasses are used to abstract over application environment, <code>HasLog</code> and
<code>HasBalance</code></li>
<li>Typeclasses are used to abstract over operations, <code>MonadBalance</code></li>
<li>Typeclasses are implemented for both the application environment, <code>HasLog</code> and
<code>HasBalance</code>, and the execution context, <code>MonadBalance</code></li>
</ul>

<p>
In the end this makes for code with very loose couplings; there's not really any
single concrete type that implements all the constraints to work in the "real"
main function (<code>main0</code>). I could of course introduce a type synonym for it
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">App</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ReaderT</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-type">IO</span>
</pre>
</div>

<p>
but it brings no value &#x2013; it wouldn't be used explicitly anywhere.
</p>
</div>
</div>

<div id="outline-container-org65b3426" class="outline-2">
<h2 id="org65b3426">A tagless final version</h2>
<div class="outline-text-2" id="text-org65b3426">
<p>
In order to compare the <code>ReaderT</code> design pattern to tagless final (as I
understand it) I made an attempt to translate the code above. The code below is
the result.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeFamilies #-}</span>

<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Control.Concurrent.STM</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Control.Monad.Identity</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">Id</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Control.Monad.Reader</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Control.Monad.State.Strict</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">State</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Say</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">Test.Hspec</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">UnliftIO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">MonadUnliftIO</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">import</span>           <span class="org-haskell-constructor">UnliftIO.Async</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Env</span> <span class="org-rainbow-delimiters-depth-1">{</span>envBalance <span class="org-haskell-operator">::</span> <span class="org-haskell-type">TVar</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ReaderT</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-type">IO</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span>, <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Env</span>, <span class="org-haskell-constructor">MonadUnliftIO</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Env</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> a
<span class="org-haskell-definition">runAppM</span> env app <span class="org-haskell-operator">=</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span> env

<span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">ModifyM</span> m <span class="org-haskell-keyword">where</span>
  mModify <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>

<span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">LogSomethingM</span> m <span class="org-haskell-keyword">where</span>
  mLogSomething <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> m<span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">ModifyM</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mModify f <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    ref <span class="org-haskell-operator">&lt;-</span> asks envBalance
    liftIO <span class="org-haskell-operator">$</span> atomically <span class="org-haskell-operator">$</span> modifyTVar' ref f

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">LogSomethingM</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mLogSomething <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">.</span> sayString

<span class="org-haskell-definition">main0</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main0</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  ref <span class="org-haskell-operator">&lt;-</span> newTVarIO <span class="org-highlight-numbers-number">4</span>
  <span class="org-haskell-keyword">let</span> env <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Env</span> ref
  runAppM env
    <span class="org-rainbow-delimiters-depth-1">(</span>concurrently_
      <span class="org-rainbow-delimiters-depth-2">(</span>mModify <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">+</span> <span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
      <span class="org-rainbow-delimiters-depth-2">(</span>mLogSomething <span class="org-string">"Increasing account balance"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
  balance <span class="org-haskell-operator">&lt;-</span> readTVarIO ref
  sayString <span class="org-haskell-operator">$</span> <span class="org-string">"Final balance: "</span> <span class="org-haskell-operator">++</span> show balance

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">ModifyAppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ModifyAppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unModifyAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State.StateT</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-type">Id.Identity</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">State.MonadState</span> <span class="org-haskell-constructor">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runModifyAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ModifyAppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>a, <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">runModifyAppM</span> s app <span class="org-haskell-operator">=</span> Id.runIdentity <span class="org-haskell-operator">$</span> State.runStateT <span class="org-rainbow-delimiters-depth-1">(</span>unModifyAppM app<span class="org-rainbow-delimiters-depth-1">)</span> s

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">ModifyM</span> <span class="org-haskell-type">ModifyAppM</span> <span class="org-haskell-keyword">where</span>
  mModify <span class="org-haskell-operator">=</span> State.modify'

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">LogAppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">LogAppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unLogAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ReaderT</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">TVar</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-type">IO</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span>, <span class="org-haskell-constructor">MonadReader</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">TVar</span> <span class="org-haskell-constructor">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runLogAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">TVar</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">LogAppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> a
<span class="org-haskell-definition">runLogAppM</span> env app <span class="org-haskell-operator">=</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unLogAppM app<span class="org-rainbow-delimiters-depth-1">)</span> env

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">LogSomethingM</span> <span class="org-haskell-type">LogAppM</span> <span class="org-haskell-keyword">where</span>
  mLogSomething msg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    var <span class="org-haskell-operator">&lt;-</span> ask
    liftIO <span class="org-haskell-operator">$</span> atomically <span class="org-haskell-operator">$</span> modifyTVar var <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">++</span> msg<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">main1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main1</span> <span class="org-haskell-operator">=</span> hspec <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  describe <span class="org-string">"mModify"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    it <span class="org-string">"works, IO"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      var <span class="org-haskell-operator">&lt;-</span> newTVarIO <span class="org-highlight-numbers-number">1</span>
      runAppM <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Env</span> var<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>mModify <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">+</span> <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
      res <span class="org-haskell-operator">&lt;-</span> readTVarIO var
      res <span class="org-haskell-operator">`shouldBe`</span> <span class="org-highlight-numbers-number">3</span>
    it <span class="org-string">"works, pure"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      <span class="org-haskell-keyword">let</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-keyword">_</span>, res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> runModifyAppM <span class="org-highlight-numbers-number">1</span> <span class="org-rainbow-delimiters-depth-1">(</span>mModify <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">+</span> <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
      res <span class="org-haskell-operator">`shouldBe`</span> <span class="org-highlight-numbers-number">3</span>
  describe <span class="org-string">"mLogSomething"</span> <span class="org-haskell-operator">$</span>
    it <span class="org-string">"works"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      var <span class="org-haskell-operator">&lt;-</span> newTVarIO <span class="org-string">""</span>
      runLogAppM var <span class="org-rainbow-delimiters-depth-1">(</span>mLogSomething <span class="org-string">"Hello"</span> <span class="org-haskell-operator">&gt;&gt;</span> mLogSomething <span class="org-string">"World!"</span><span class="org-rainbow-delimiters-depth-1">)</span>
      res <span class="org-haskell-operator">&lt;-</span> readTVarIO var
      res <span class="org-haskell-operator">`shouldBe`</span> <span class="org-string">"HelloWorld!"</span>

<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> main0 <span class="org-haskell-operator">&gt;&gt;</span> main1
</pre>
</div>

<p>
The steps for the "real" part of the program were
</p>

<ol class="org-ol">
<li>Introduce an execution type, <code>AppM</code>, with a convenience function for running
it, <code>runAppM</code></li>
<li>Remove the log function from the environment type, <code>envLog</code> in <code>Env</code></li>
<li>Remove all the <code>HasX</code> classes</li>
<li>Create a new operations typeclass for logging, <code>LogSomethingM</code></li>
<li>Rename the operations typeclass for modifying the balance to match the naming
found in the <a href="https://serokell.io/blog/2018/12/07/tagless-final">tagless article</a> a bit better, <code>ModifyM</code></li>
<li>Implement instances of both operations typeclasses for <code>AppM</code></li>
</ol>

<p>
For testing the steps were
</p>

<ol class="org-ol">
<li>Define an execution type for each test, <code>ModifyAppM</code> and <code>LogAppM</code>, with some
convenience functions for running them, <code>runModifyAppM</code> and <code>runLogAppM</code></li>
<li>Write instances for the operations typeclasses, one for each</li>
</ol>

<p>
So I think the distinguising features are
</p>

<ul class="org-ul">
<li>There's both an environment type, <code>Env</code>, and an execution type <code>AppM</code> that
wraps it</li>
<li>The environment holds only configuration values (none in this example), and
state (<code>envBalance</code>)</li>
<li>Typeclasses are used to abstract over operations, <code>LogSomethingM</code> and
<code>ModifyM</code></li>
<li>Typeclasses are only implemented for the execution type</li>
</ul>

<p>
This version has slightly more coupling, the execution type specifies the
environment to use, and the operations are tied directly to the execution type.
However, this coupling doesn't really make a big difference &#x2013; looking at the
pure modify test the amount of code don't differ by much.
</p>
</div>

<div id="outline-container-org9a9bb0f" class="outline-3">
<h3 id="org9a9bb0f">A short note (mostly to myself)</h3>
<div class="outline-text-3" id="text-org9a9bb0f">
<p>
I did write it using <code>monad-control</code> first, and then I needed an instance for
<code>MonadBaseControl IO</code>. Deriving it automatically requires <code>UndecidableInstances</code>
and I didn't really dare turn that on, so I ended up writing the instance. After
some help on <a href="https://mail.haskell.org/pipermail/haskell-cafe/2019-February/130667.html">haskell-cafe</a> it ended up looking like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadBaseControl</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  <span class="org-haskell-keyword">type</span> <span class="org-haskell-type">StM</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> a
  liftBaseWith f <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">(</span>liftBaseWith <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span> run <span class="org-haskell-operator">-&gt;</span> f <span class="org-rainbow-delimiters-depth-2">(</span>run <span class="org-haskell-operator">.</span> unAppM<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
  restoreM <span class="org-haskell-operator">=</span> return
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge8c9125" class="outline-2">
<h2 id="orge8c9125">Conclusion</h2>
<div class="outline-text-2" id="text-orge8c9125">
<p>
My theoretical knowledge isn't anywhere near good enough to say anything
objectively about the difference in expressiveness of the two design patterns.
That means that my conclusion comes down to taste, do you like the <code>readerT</code>
patter or tagless final better?
</p>

<p>
I like the slightly looser coupling I get with the <code>ReaderT</code> pattern. Loose
coupling is (almost) always a desirable goal. However, I can see that tying the
typeclass instances directly to a concrete execution type results in the intent
being communicated a little more clearly. Clearly communicating intent in code
is also a desirable goal. In particular I suspect it'll result in more
actionable error messages when making changes to the code &#x2013; the error will tell
me that my execution type lacks an instance of a specific typeclass, instead of
it telling me that a particular transformer stack does. On the other hand, in
the <code>ReaderT</code> pattern that stack is very shallow.
</p>

<p>
One possibility would be that one pattern is better suited for libraries and the
other for applications. I don't think that's the case though as in both cases
the library code would be written in a style that results in typeclass
constraints on the caller and providing instances for those typeclasses is
roughly an equal amount of work for both styles.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Please do point out any mistakes I've made in this, in particular if they
stem from me misunderstanding tagless final completely.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-tagless_final.html">tagless_final</a> <a href="https://magnus.therning.org/tag-readert.html">readert</a> <a href="https://magnus.therning.org/tag-monad.html">monad</a> <a href="https://magnus.therning.org/tag-monad_transformers.html">monad_transformers</a> </div>
<div class="post-date">28 Jan 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-01-28-000-a-missing-piece-in-my-emacs-spacemacs-setup-for-haskell-development.html">A missing piece in my Emacs/Spacemacs setup for Haskell development</a></h1>
<p>
With the help of a work mate I've finally found this gem that's been missing
from my Spacemacs setup
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">with-eval-after-load</span> 'intero
  <span class="org-rainbow-delimiters-depth-2">(</span>flycheck-add-next-checker 'intero '<span class="org-rainbow-delimiters-depth-3">(</span>warning . haskell-hlint<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>flycheck-add-next-checker 'intero '<span class="org-rainbow-delimiters-depth-3">(</span>warning . haskell-stack-ghc<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-spacemacs.html">spacemacs</a> </div>
<div class="post-date">20 Jan 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-01-20-000-tagless-final-and-scotty.html">Tagless final and Scotty</a></h1>
<p>
For a little while I've been playing around with event sourcing in Haskell using
<a href="https://hackage.haskell.org/package/conduit"><code>Conduit</code></a> and <a href="https://hackage.haskell.org/package/scotty"><code>Scotty</code></a>. I've come far enough that the basic functionality I'm
after is there together with all those little bits that make it a piece of
software that's fit for deployment in production (configuration, logging, etc.).
There's just one thing that's been nagging me, testability.
</p>

<p>
The app is built of two main parts, a web server (<code>Scotty</code>) and a pipeline of
stream processing components (<code>Conduit</code>). The part using <code>Scotty</code> is utilising a
simple monad stack, <code>ReaderT Config IO</code>, and the <code>Conduit</code> part is using
<code>Conduit In Out IO</code>. This means that in both parts the outer edge, the part
dealing with the outside world, is running in <code>IO</code> directly. Something that
isn't really aiding in testing.
</p>

<p>
I started out thinking that I'd rewrite what I have using a free monad with a
bunch of interpreters. Then I remembered that I have "check out tagless final".
This post is a record of the small experiments I did to see how to use it with
<code>Scotty</code> to achieve (and actually improve) on the code I have in my
production-ready code.
</p>

<div id="outline-container-org70bf102" class="outline-2">
<h2 id="org70bf102">1 - Use tagless final with <code>Scotty</code></h2>
<div class="outline-text-2" id="text-org70bf102">
<p>
As a first simple little experiment I wrote a tiny little web server that would
print a string to <code>stdout</code> when receiving the request to <code>GET /route0</code>.
</p>

<p>
The printing to <code>stdout</code> is the operation I want to make abstract.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadPrinter</span> m <span class="org-haskell-keyword">where</span>
  mPutStrLn <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
</pre>
</div>

<p>
I then created an application type that is an instance of that class.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span> unAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> a <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadPrinter</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mPutStrLn t <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> putStrLn <span class="org-rainbow-delimiters-depth-1">(</span>unpack t<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Then I added a bit of <code>Scotty</code> boilerplate. It's not strictly necessary, but
does make the code a bit nicer to read.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">FooM</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ScottyT</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-type">AppM</span>
<span class="org-haskell-keyword">type</span> <span class="org-haskell-type">FooActionM</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ActionT</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-type">AppM</span>

<span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Port</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ScottyT</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">foo</span> port <span class="org-haskell-operator">=</span> scottyT port unAppM
</pre>
</div>

<p>
With that in place the web server itself is just a matter of tying it all
together.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  foo <span class="org-highlight-numbers-number">3000</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    get <span class="org-string">"/route0"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      lift <span class="org-haskell-operator">$</span> mPutStrLn <span class="org-string">"getting /route0"</span>
      json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"route0"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"ok"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    notFound <span class="org-haskell-operator">$</span> json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"error"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"not found"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
That was simple enough.
</p>
</div>
</div>

<div id="outline-container-org032b911" class="outline-2">
<h2 id="org032b911">2 - Add configuration</h2>
<div class="outline-text-2" id="text-org032b911">
<p>
In order to try out how to deal with configuration I added a class for doing
some simple logging
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadLogger</span> m <span class="org-haskell-keyword">where</span>
  mLog <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
</pre>
</div>

<p>
The straight forward way to deal with configuration is to create a monad stack
with <code>ReaderT</code> and since it's logging I want to do the configuration consists of
a single <code>LoggerSet</code> (from <a href="https://hackage.haskell.org/package/fast-logger"><code>fast-logger</code></a>).
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span> unAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ReaderT</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-type">IO</span> a <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span>, <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">LoggerSet</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That means the class instance can be implemented like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadLogger</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mLog msg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    ls <span class="org-haskell-operator">&lt;-</span> ask
    liftIO <span class="org-haskell-operator">$</span> pushLogStrLn ls <span class="org-haskell-operator">$</span> toLogStr msg
</pre>
</div>

<p>
Of course <code>foo</code> has to be changed too, and it becomes a little easier with a
wrapper for <code>runReaderT</code> and <code>unAppM</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Port</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ScottyT</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">foo</span> ls port <span class="org-haskell-operator">=</span> scottyT port <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">`runAppM`</span> ls<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> a
<span class="org-haskell-definition">runAppM</span> app ls <span class="org-haskell-operator">=</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span> ls
</pre>
</div>

<p>
With that in place the printing to <code>stdout</code> can be replaced by a writing to the
log.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  ls <span class="org-haskell-operator">&lt;-</span> newStdoutLoggerSet defaultBufSize
  foo ls <span class="org-highlight-numbers-number">3000</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    get <span class="org-string">"/route0"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      lift <span class="org-haskell-operator">$</span> mLog <span class="org-string">"log: getting /route0"</span>
      json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"route0"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"ok"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    notFound <span class="org-haskell-operator">$</span> json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"error"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"not found"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
Not really a big change, I'd say. Extending the configuration is clearly
straight forward too.
</p>
</div>
</div>

<div id="outline-container-org9bf256e" class="outline-2">
<h2 id="org9bf256e">3 - Per-request configuration</h2>
<div class="outline-text-2" id="text-org9bf256e">
<p>
At work we use correlation IDs<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> and I think that the most convenient way to
deal with it is to put the correlation ID into the configuration after
extracting it. That is, I want to modify the configuration on each request.
Luckily it turns out to be possible to do that, despite using <code>ReaderT</code> for
holding the configuration.
</p>

<p>
I can't be bothered with a full implementation of correlation ID for this little
experiment, but as long as I can get a new <code>AppM</code> by running a function on the
configuration it's just a matter of extracting the correct header from the
request. For this experiment it'll do to just modify an integer in the
configuration.
</p>

<p>
I start with defining a type for the configuration and changing <code>AppM</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">LoggerSet</span>, <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span> unAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ReaderT</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-type">IO</span> a <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span>, <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Config</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The logger instance has to be changed accordingly of course.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadLogger</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mLog msg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>ls, i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> ask
    liftIO <span class="org-haskell-operator">$</span> pushLogStrLn ls <span class="org-haskell-operator">$</span> toLogStr msg <span class="org-haskell-operator">&lt;&gt;</span> toLogStr <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">":"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;&gt;</span> toLogStr <span class="org-rainbow-delimiters-depth-1">(</span>show i<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The <code>get</code> function that comes with <code>scotty</code> isn't going to cut it, since it has
no way of modifying the configuration, so I'll need a new one.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mGet</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ScottyError</span> e <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">RoutePattern</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ActionT</span> e <span class="org-haskell-type">AppM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ScottyT</span> e <span class="org-haskell-type">AppM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">mGet</span> p a <span class="org-haskell-operator">=</span> get p <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  withCfg <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> <span class="org-rainbow-delimiters-depth-2">(</span>ls, i<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span>ls, succ i<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> a
</pre>
</div>

<p>
The tricky bit is in the <code>withCfg</code> function. It's indeed not very easy to read,
I think
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">withCfg</span> <span class="org-haskell-operator">=</span> mapActionT <span class="org-haskell-operator">.</span> withAppM
  <span class="org-haskell-keyword">where</span>
    mapActionT f <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">ActionT</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ActionT</span> <span class="org-haskell-operator">$</span> <span class="org-rainbow-delimiters-depth-1">(</span>mapExceptT <span class="org-haskell-operator">.</span> mapReaderT <span class="org-haskell-operator">.</span> mapStateT<span class="org-rainbow-delimiters-depth-1">)</span> f a
    withAppM f a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-haskell-operator">$</span> withReaderT f <span class="org-rainbow-delimiters-depth-1">(</span>unAppM a<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Basically it reaches into the guts of <code>scotty</code>'s <code>ActionT</code> type (the details are
exposed in <code>Web.Scotty.Internal.Types</code>, thanks for not hiding it completely),
and modifies the <code>ReaderT Config</code> I've supplied.
</p>

<p>
The new server has two routes, the original one and a new one at <code>GET /route1</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  putStrLn <span class="org-string">"Starting"</span>
  ls <span class="org-haskell-operator">&lt;-</span> newStdoutLoggerSet defaultBufSize
  foo <span class="org-rainbow-delimiters-depth-1">(</span>ls, <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-highlight-numbers-number">3000</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    get <span class="org-string">"/route0"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      lift <span class="org-haskell-operator">$</span> mLog <span class="org-string">"log: getting /route0"</span>
      json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"route0"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"ok"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    mGet <span class="org-string">"/route1"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      lift <span class="org-haskell-operator">$</span> mLog <span class="org-string">"log: getting /route1"</span>
      json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"route1"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"bar"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    notFound <span class="org-haskell-operator">$</span> json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"error"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"not found"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
It's now easy to verify that the original route, <code>GET /route0</code>, logs a string
containing the integer '0', while the new route, <code>GET /route1</code>, logs a string
containing the integer '1'.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
If you don't know what it is you'll find multiple sources by searching
for "http correlation-id". <a href="https://theburningmonk.com/2015/05/a-consistent-approach-to-track-correlation-ids-through-microservices/">A consistent approach to track correlation IDs
through microservices</a> is as good a place to start as any.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-scotty.html">scotty</a> <a href="https://magnus.therning.org/tag-tagless_final.html">tagless_final</a> </div>
<div class="post-date">16 Oct 2018</div><h1 class="post-title"><a href="https://magnus.therning.org/2018-10-16-000-zipping-streams.html">Zipping streams</a></h1>
<p>
Writing the following is easy after glancing through the documentation for
<a href="https://hackage.haskell.org/package/conduit">conduit</a>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">let</span> src <span class="org-haskell-operator">=</span> mapM_ C.yield <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">0</span><span class="org-haskell-operator">..</span><span class="org-highlight-numbers-number">9</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">]</span>
          p0 <span class="org-haskell-operator">=</span> CC.map <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> i <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"p0"</span>, succ i<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
          p1 <span class="org-haskell-operator">=</span> CC.filter odd <span class="org-haskell-operator">.|</span> CC.map <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> i <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"p1"</span>, i<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
          p <span class="org-haskell-operator">=</span> C.getZipConduit <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">C.ZipConduit</span> p0 <span class="org-haskell-operator">&lt;*</span> <span class="org-haskell-constructor">C.ZipConduit</span> p1
          sink <span class="org-haskell-operator">=</span> CC.mapM_ print
      <span class="org-haskell-keyword">in</span> C.runConduit <span class="org-haskell-operator">$</span> src <span class="org-haskell-operator">.|</span> p <span class="org-haskell-operator">.|</span> sink
</pre>
</div>

<p>
Neither <a href="https://hackage.haskell.org/package/pipes">pipes</a> nor <a href="https://hackage.haskell.org/package/streaming">streaming</a> make it as easy to figure out. I must be missing
something! What functions should I be looking at?
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> <a href="https://magnus.therning.org/tag-pipes.html">pipes</a> <a href="https://magnus.therning.org/tag-streaming.html">streaming</a> </div>
<div class="post-date">01 Oct 2018</div><h1 class="post-title"><a href="https://magnus.therning.org/2018-10-01-000-using-a-configuration-in-scotty.html">Using a configuration in Scotty</a></h1>
<p>
At work we're only now getting around to put <a href="https://hilton.org.uk/blog/microservices-correlation-id">correlation IDs</a> into use. We write
most our code in Clojure but since I'd really like to use more Haskell at work I
thought I'd dive into <a href="https://hackage.haskell.org/package/scotty">Scotty</a> and see how to deal with logging and then
especially how to get correlation IDs into the logs.
</p>

<div id="outline-container-org908bdc9" class="outline-2">
<h2 id="org908bdc9">The types</h2>
<div class="outline-text-2" id="text-org908bdc9">
<p>
For configuration it decided to use the reader monad inside <code>ActionT</code> from
Scotty. Enter Chell:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">ChellM</span> c <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ScottyT</span> <span class="org-haskell-type">Text</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">ReaderT</span> c <span class="org-haskell-type">IO</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">type</span> <span class="org-haskell-type">ChellActionM</span> c <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ActionT</span> <span class="org-haskell-type">Text</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">ReaderT</span> c <span class="org-haskell-type">IO</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
In order to run it I wrote a function corresponding to <code>scotty</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">chell</span> <span class="org-haskell-operator">::</span> c <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Port</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">chell</span> cfg port a <span class="org-haskell-operator">=</span> scottyOptsT opts <span class="org-rainbow-delimiters-depth-1">(</span>flip runReaderT cfg<span class="org-rainbow-delimiters-depth-1">)</span> a
  <span class="org-haskell-keyword">where</span>
    opts <span class="org-haskell-operator">=</span> def <span class="org-rainbow-delimiters-depth-1">{</span> verbose <span class="org-haskell-operator">=</span> <span class="org-highlight-numbers-number">0</span>
               , settings <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-2">(</span>settings def<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> settingsPort <span class="org-haskell-operator">=</span> port <span class="org-rainbow-delimiters-depth-2">}</span>
               <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6fb6127" class="outline-2">
<h2 id="org6fb6127">Correlation ID</h2>
<div class="outline-text-2" id="text-org6fb6127">
<p>
To deal with the correlation ID each incoming request should be checked for the
HTTP header <code>X-Correlation-Id</code> and if present it should be used during logging.
If no such header is present then a new correlation ID should be created. Since
it's per request it feels natural to create a WAI middleware for this.
</p>

<p>
The easiest way I could come up with was to push the correlation ID into the
request's headers before it's passed on:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">requestHeaderCorrelationId</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Request</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">ByteString</span>
<span class="org-haskell-definition">requestHeaderCorrelationId</span> <span class="org-haskell-operator">=</span> lookup <span class="org-string">"X-Correlation-Id"</span> <span class="org-haskell-operator">.</span> requestHeaders

<span class="org-haskell-definition">correlationId</span> <span class="org-haskell-operator">::</span>  <span class="org-haskell-type">Middleware</span>
<span class="org-haskell-definition">correlationId</span> app req sendResponse <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  u <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-1">(</span>randomIO <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">UUID</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">let</span> corrId <span class="org-haskell-operator">=</span> maybe <span class="org-rainbow-delimiters-depth-1">(</span>toASCIIBytes u<span class="org-rainbow-delimiters-depth-1">)</span> id <span class="org-rainbow-delimiters-depth-1">(</span>requestHeaderCorrelationId req<span class="org-rainbow-delimiters-depth-1">)</span>
      newHeaders <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"X-Correlation-Id"</span>, corrId<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">:</span> <span class="org-rainbow-delimiters-depth-1">(</span>requestHeaders req<span class="org-rainbow-delimiters-depth-1">)</span>
  app <span class="org-rainbow-delimiters-depth-1">(</span>req <span class="org-rainbow-delimiters-depth-2">{</span> requestHeaders <span class="org-haskell-operator">=</span> newHeaders <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span> res <span class="org-haskell-operator">-&gt;</span> sendResponse res
</pre>
</div>

<p>
It also turns out to be useful to have both a default correlation ID and a
function for pulling it out of the headers:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">defaultCorrelationString</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ByteString</span>
<span class="org-haskell-definition">defaultCorrelationString</span> <span class="org-haskell-operator">=</span> <span class="org-string">"no-correlation-id"</span>

<span class="org-haskell-definition">getCorrelationId</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Request</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ByteString</span>
<span class="org-haskell-definition">getCorrelationId</span> r <span class="org-haskell-operator">=</span> maybe defaultCorrelationString id <span class="org-rainbow-delimiters-depth-1">(</span>requestHeaderCorrelationId r<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org210c543" class="outline-2">
<h2 id="org210c543">Getting the correlation ID into the configuration</h2>
<div class="outline-text-2" id="text-org210c543">
<p>
Since the correlation ID should be picked out of the request on handling of
every request it's useful to have it the configuration when running the
<code>ChellActionM</code> actions. However, since the correlation ID isn't available when
running the reader (the call to <code>runReaderT</code> in <code>chell</code>) something else is
called for. When looking around I found <code>local</code> (and later I was pointed to the
more general <code>withReaderT</code>) but it doesn't have a suitable type. After some <a href="https://twitter.com/EyalL/status/1046696148218580993">help
on Twitter</a> I arrived at <code>withConfig</code> which allows me to run an action in a
modified configuration:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">withConfig</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span>c <span class="org-haskell-operator">-&gt;</span> c'<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellActionM</span> c' <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellActionM</span> c <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">withConfig</span> <span class="org-haskell-operator">=</span> mapActionT <span class="org-haskell-operator">.</span> withReaderT
  <span class="org-haskell-keyword">where</span>
    mapActionT f <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">ActionT</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ActionT</span> <span class="org-haskell-operator">$</span> <span class="org-rainbow-delimiters-depth-1">(</span>mapExceptT <span class="org-haskell-operator">.</span> mapReaderT <span class="org-haskell-operator">.</span> mapStateT<span class="org-rainbow-delimiters-depth-1">)</span> f a
</pre>
</div>
</div>
</div>

<div id="outline-container-org5962f2c" class="outline-2">
<h2 id="org5962f2c">Making it handy to use</h2>
<div class="outline-text-2" id="text-org5962f2c">
<p>
Armed with this I can put together some functions to replace Scotty's <code>get</code>,
<code>post</code>, etc. With a configuration type like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Cfg</span> <span class="org-haskell-constructor">LoggerSet</span> <span class="org-haskell-constructor">ByteString</span>
</pre>
</div>

<p>
The modified <code>get</code> looks like this (Scotty's original is <code>S.get</code>)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">get</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">RoutePattern</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellActionM</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellM</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">get</span> p a <span class="org-haskell-operator">=</span> S.get p <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  r <span class="org-haskell-operator">&lt;-</span> request
  <span class="org-haskell-keyword">let</span> corrId <span class="org-haskell-operator">=</span> getCorrelationId r
  withConfig <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Cfg</span> l <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Cfg</span> l corrId<span class="org-rainbow-delimiters-depth-1">)</span> a
</pre>
</div>

<p>
With this in place I can use the simpler <code>ReaderT Config IO</code> for inner functions
that need to log.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-scotty.html">scotty</a> <a href="https://magnus.therning.org/tag-monad.html">monad</a> </div>
<div class="post-date">14 Jul 2018</div><h1 class="post-title"><a href="https://magnus.therning.org/2018-07-14-000-quickcheck-on-a-rest-api.html">QuickCheck on a REST API</a></h1>
<p>
Since I'm working with web stuff nowadays I thought I'd play a little with
translating my old post on <a href="2015-06-15-000-using-quickcheck-to-test-c-apis.html">using QuickCheck to test C APIs</a> to the web.
</p>

<div id="outline-container-orgd2e8eeb" class="outline-2">
<h2 id="orgd2e8eeb">The goal and how to reach it</h2>
<div class="outline-text-2" id="text-orgd2e8eeb">
<p>
I want to use <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> to test a REST API, just like in the case of the C API
the idea is to
</p>

<ol class="org-ol">
<li>generate a sequence of API calls (a <i>program</i>), then</li>
<li>run the sequence against a model, as well as</li>
<li>run the sequence against the web service, and finally</li>
<li>compare the resulting model against reality.</li>
</ol>
</div>
</div>

<div id="outline-container-org776189d" class="outline-2">
<h2 id="org776189d">The REST API</h2>
<div class="outline-text-2" id="text-org776189d">
<p>
I'll use a small web service I'm working on, and then concentrate on only a
small part of the API to begin with.
</p>

<p>
The parts of the API I'll use for the programs at this stage are
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Method</th>
<th scope="col" class="org-left">Route</th>
<th scope="col" class="org-left">Example in</th>
<th scope="col" class="org-left">Example out</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>POST</code></td>
<td class="org-left"><code>/users</code></td>
<td class="org-left"><code>{"userId": 0, "userName": "Yogi Berra"}</code></td>
<td class="org-left"><code>{"userId": 42, "userName": "Yogi Berra"}</code></td>
</tr>

<tr>
<td class="org-left"><code>DELETE</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
The following API calls will also be used, but not in the programs
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Method</th>
<th scope="col" class="org-left">Route</th>
<th scope="col" class="org-left">Example in</th>
<th scope="col" class="org-left">Example out</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>[0,3,7]</code></td>
</tr>

<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>{"userId": 42, "userName": "Yogi Berra"}</code></td>
</tr>

<tr>
<td class="org-left"><code>POST</code></td>
<td class="org-left"><code>/reset</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org45a80a7" class="outline-2">
<h2 id="org45a80a7">Representing API calls</h2>
<div class="outline-text-2" id="text-org45a80a7">
<p>
Given the information about the API above it seems the following is enough to
represent the two calls of interest together with a constructor representing the
end of a program
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">ApiCall</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-constructor">Text</span>
             <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-constructor">Int</span>
             <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">EndProgram</span>
             <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
and a program is just a sequence of calls, so list of <code>ApiCall</code> will do.
However, since I want to generate sequences of calls, i.e. implement
<code>Arbitrary</code>, I'll wrap it in a <code>newtype</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Prog</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-constructor">ApiCall</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8734229" class="outline-2">
<h2 id="org8734229">Running against a model (simulation)</h2>
<div class="outline-text-2" id="text-org8734229">
<p>
First of all I need to decide what model to use. Based on the part of the API
I'm using I'll use an ordinary dictionary of <code>Int</code> and <code>Text</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">Model</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">M.Map</span> <span class="org-haskell-type">Int</span> <span class="org-haskell-type">Text</span>
</pre>
</div>

<p>
Simulating execution of a program is simulating each call against a
model that's updated with each step. I expect the final model to
correspond to the state of the real service after the program is run for
real. The simulation begins with an empty dictionary.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">simulateProgram</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Model</span>
<span class="org-haskell-definition">simulateProgram</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Prog</span> cs<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> foldl simulateCall M.empty cs
</pre>
</div>

<p>
The simulation of the API calls must then be a function taking a model and a
call, returning an updated model
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">simulateCall</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Model</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ApiCall</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Model</span>
<span class="org-haskell-definition">simulateCall</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> t<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> M.insert k t m
  <span class="org-haskell-keyword">where</span>
    k <span class="org-haskell-operator">=</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.keys m<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">simulateCall</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> k<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> M.delete k m
<span class="org-haskell-definition">simulateCall</span> m <span class="org-haskell-constructor">EndProgram</span> <span class="org-haskell-operator">=</span> m
</pre>
</div>

<p>
Here I have to make a few assumptions. First, I assume the indeces for the users
start on <code>1</code>. Second, that the next index used always is the successor of
highest currently used index. We'll see how well this holds up to reality later
on.
</p>
</div>
</div>

<div id="outline-container-org9c8cb3a" class="outline-2">
<h2 id="org9c8cb3a">Running against the web service</h2>
<div class="outline-text-2" id="text-org9c8cb3a">
<p>
Running the program against the actual web service follows the same pattern, but
here I'm dealing with the real world, so it's a little more messy, i.e. <code>IO</code> is
involved. First the running of a single call
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">runCall</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Manager</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ApiCall</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">runCall</span> mgr <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> t<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  ireq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/users"</span>
  <span class="org-haskell-keyword">let</span> req <span class="org-haskell-operator">=</span> ireq <span class="org-rainbow-delimiters-depth-1">{</span> requestBody <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RequestBodyLBS</span> <span class="org-rainbow-delimiters-depth-2">(</span>encode <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">User</span> <span class="org-highlight-numbers-number">0</span> t<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>
  resp <span class="org-haskell-operator">&lt;-</span> httpLbs req mgr
  guard <span class="org-rainbow-delimiters-depth-1">(</span>status201 <span class="org-haskell-operator">==</span> responseStatus resp<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runCall</span> mgr <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> k<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  req <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"DELETE http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show k
  resp <span class="org-haskell-operator">&lt;-</span> httpNoBody req mgr
  guard <span class="org-rainbow-delimiters-depth-1">(</span>status200 <span class="org-haskell-operator">==</span> responseStatus resp<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runCall</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-constructor">EndProgram</span> <span class="org-haskell-operator">=</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
</pre>
</div>

<p>
The running of a program is slightly more involved. Of course I have to set up
the <code>Manager</code> needed for the HTTP calls, but I also need to
</p>

<ol class="org-ol">
<li>ensure that the web service is in a well-known state before starting, and</li>
<li>extract the state of the web service after running the program, so I can
compare it to the model</li>
</ol>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">runProgram</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Model</span>
<span class="org-haskell-definition">runProgram</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Prog</span> cs<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
  resetReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/reset"</span>
  httpNoBody resetReq mgr
  mapM_ <span class="org-rainbow-delimiters-depth-1">(</span>runCall mgr<span class="org-rainbow-delimiters-depth-1">)</span> cs
  model <span class="org-haskell-operator">&lt;-</span> extractModel mgr
  return model
</pre>
</div>

<p>
The call to <code>POST /reset</code> resets the web service. I would have liked to simply
restart the service completely, but I failed in automating it. I think I'll have
to take a closer look at the implementation of <a href="http://hackage.haskell.org/package/scotty">scotty</a> to find a way.
</p>

<p>
Extracting the web service state and packaging it in a <code>Model</code> is a matter of
calling <code>GET /users</code> and then repeatedly calling <code>GET /users/:id</code> with each <code>id</code>
gotten from the first call
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">extractModel</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Manager</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Model</span>
<span class="org-haskell-definition">extractModel</span> mgr <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  req <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"http://localhost:3000/users"</span>
  resp <span class="org-haskell-operator">&lt;-</span> httpLbs req mgr
  <span class="org-haskell-keyword">let</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Just</span> ids<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> decode <span class="org-rainbow-delimiters-depth-1">(</span>responseBody resp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">]</span>
  users <span class="org-haskell-operator">&lt;-</span> forM ids <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span> id <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-keyword">do</span>
    req <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show id
    resp <span class="org-haskell-operator">&lt;-</span> httpLbs req mgr
    <span class="org-haskell-keyword">let</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Just</span> <span class="org-rainbow-delimiters-depth-2">(</span>user<span class="org-haskell-constructor">:</span><span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> decode <span class="org-rainbow-delimiters-depth-1">(</span>responseBody resp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">User</span><span class="org-rainbow-delimiters-depth-1">]</span>
    return user
  return <span class="org-haskell-operator">$</span> foldl <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> map <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">User</span> id name<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">-&gt;</span> M.insert id name map<span class="org-rainbow-delimiters-depth-1">)</span> M.empty users
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf418a26" class="outline-2">
<h2 id="orgf418a26">Generating programs</h2>
<div class="outline-text-2" id="text-orgf418a26">
<p>
My approach to generating a program is based on the idea that given a certain
state there is only a limited number of possible calls that make sense. Given a
model <code>m</code> it makes sense to make one of the following calls:
</p>

<ul class="org-ul">
<li>add a new user</li>
<li>delete an existing user</li>
<li>end the program</li>
</ul>

<p>
Based on this writing <code>genProgram</code> is rather straight forward
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">genProgram</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Gen</span> <span class="org-haskell-type">Program</span>
<span class="org-haskell-definition">genProgram</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Prog</span> <span class="org-haskell-operator">&lt;$&gt;</span> go M.empty
  <span class="org-haskell-keyword">where</span>
    possibleAddUser <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> arbitrary<span class="org-rainbow-delimiters-depth-1">]</span>
    possibleDeleteUser m <span class="org-haskell-operator">=</span> map <span class="org-rainbow-delimiters-depth-1">(</span>return <span class="org-haskell-operator">.</span> <span class="org-haskell-constructor">DeleteUser</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.keys m<span class="org-rainbow-delimiters-depth-1">)</span>
    possibleEndProgram <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>return <span class="org-haskell-constructor">EndProgram</span><span class="org-rainbow-delimiters-depth-1">]</span>

    go m <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      <span class="org-haskell-keyword">let</span> possibles <span class="org-haskell-operator">=</span> possibleDeleteUser m <span class="org-haskell-operator">++</span> possibleAddUser m <span class="org-haskell-operator">++</span> possibleEndProgram m
      s <span class="org-haskell-operator">&lt;-</span> oneof possibles
      <span class="org-haskell-keyword">let</span> m' <span class="org-haskell-operator">=</span> simulateCall m s
      <span class="org-haskell-keyword">case</span> s <span class="org-haskell-keyword">of</span>
        <span class="org-haskell-constructor">EndProgram</span> <span class="org-haskell-operator">-&gt;</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span>
        <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>s<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;$&gt;</span> go m'
</pre>
</div>

<p>
Armed with that the <code>Arbitrary</code> instance for <code>Program</code> can be implemented as<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Arbitrary</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-keyword">where</span>
  arbitrary <span class="org-haskell-operator">=</span> genProgram
  shrink p <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge02a7fa" class="outline-2">
<h2 id="orge02a7fa">The property of an API</h2>
<div class="outline-text-2" id="text-orge02a7fa">
<p>
The steps in the <a href="#orgd2e8eeb">first section</a> can be used as a recipe for writing the property
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">prop_progCorrectness</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Property</span>
<span class="org-haskell-definition">prop_progCorrectness</span> program <span class="org-haskell-operator">=</span> monadicIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  <span class="org-haskell-keyword">let</span> simulatedModel <span class="org-haskell-operator">=</span> simulateProgram program
  runModel <span class="org-haskell-operator">&lt;-</span> run <span class="org-haskell-operator">$</span> runProgram program
  assert <span class="org-haskell-operator">$</span> simulatedModel <span class="org-haskell-operator">==</span> runModel
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd44c20f" class="outline-2">
<h2 id="orgd44c20f">What next?</h2>
<div class="outline-text-2" id="text-orgd44c20f">
<p>
There are some improvements that I'd like to make:
</p>

<ul class="org-ul">
<li>Make the generation of <code>Program</code> better in the sense that the programs become
longer. I think this is important as I start tackling larger APIs.</li>
<li>Write an implementation of <code>shrink</code> for <code>Program</code>. With longer programs it's
of course more important to actually implement <code>shrink</code>.</li>
</ul>

<p>
I'd love to hear if others are using <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> to test REST APIs in some way,
if anyone has suggestions for improvements, and of course ideas for how to
implement <code>shrink</code> in a nice way.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Yes, I completely skip the issue of shrinking programs at this point.
This is OK at this point though, because the generated =Programs=s do end up to
be very short indeed.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-flycheck.html">flycheck</a> </div>
<div class="post-date">15 Jun 2015</div><h1 class="post-title"><a href="https://magnus.therning.org/2015-06-15-000-using-quickcheck-to-test-c-apis.html">Using QuickCheck to test C APIs</a></h1>
<p>
Last year at ICFP I attended the <a href="http://cufp.org/2014/t12-john-hughes-introduction-to-testing-with-quickcheck.html">tutorial on QuickCheck</a> with John Hughes. We got
to use the Erlang implementation of QuickCheck to test a C API. Ever since I've
been planning to do the same thing using Haskell. I've put it off for the better
part of a year now, but then Francesco Mazzoli wrote about <a href="http://hackage.haskell.org/package/inline-c">inline-c</a> (<a href="https://www.fpcomplete.com/blog/2015/05/inline-c">Call C
functions from Haskell without bindings</a> and I found the motivation to actually
start writing some code.
</p>

<div id="outline-container-org755182d" class="outline-2">
<h2 id="org755182d">The general idea</h2>
<div class="outline-text-2" id="text-org755182d">
<p>
Many C APIs are rather stateful beasts so to test it I
</p>

<ol class="org-ol">
<li>generate a sequence of API calls (a program of sorts),</li>
<li>run the sequence against a model,</li>
<li>run the sequence against the real implementation, and</li>
<li>compare the model against the real state each step of the way.</li>
</ol>
</div>
</div>

<div id="outline-container-org5c47d51" class="outline-2">
<h2 id="org5c47d51">The C API</h2>
<div class="outline-text-2" id="text-org5c47d51">
<p>
To begin with I hacked up a simple implementation of a stack in C. The
"specification" is
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-doc">/**</span>
<span class="org-doc"> * Create a stack.</span>
<span class="org-doc"> */</span>
<span class="org-type">void</span> *<span class="org-function-name">create</span><span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-doc">/**</span>
<span class="org-doc"> * Push a value onto an existing stack.</span>
<span class="org-doc"> */</span>
<span class="org-type">void</span> <span class="org-function-name">push</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-doc">/**</span>
<span class="org-doc"> * Pop a value off an existing stack.</span>
<span class="org-doc"> */</span>
<span class="org-type">int</span> <span class="org-function-name">pop</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Using <code>inline-c</code> to create bindings for it is amazingly simple:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="org-haskell-keyword">module</span> <span class="org-haskell-constructor">CApi</span>
    <span class="org-haskell-keyword">where</span>

<span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Language.C.Inline</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">C</span>
<span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Foreign.Ptr</span>

C<span class="org-haskell-definition">.</span>include <span class="org-string">"stack.h"</span>

<span class="org-haskell-definition">create</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Ptr</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">create</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>C.exp<span class="org-haskell-quasi-quote">| void * { create() } |</span><span class="org-rainbow-delimiters-depth-1">]</span>

<span class="org-haskell-definition">push</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Ptr</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">C.CInt</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">push</span> s i <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>C.exp<span class="org-haskell-quasi-quote">| void { push($(void *s), $(int i)) } |</span><span class="org-rainbow-delimiters-depth-1">]</span>

<span class="org-haskell-definition">pop</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Ptr</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">C.CInt</span>
<span class="org-haskell-definition">pop</span> s <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>C.exp<span class="org-haskell-quasi-quote">| int { pop($(void *s)) } |</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
In the code below I import this module qualified.
</p>
</div>
</div>

<div id="outline-container-org7f43b7c" class="outline-2">
<h2 id="org7f43b7c">Representing a program</h2>
<div class="outline-text-2" id="text-org7f43b7c">
<p>
To represent a sequence of calls I first used a custom type, but later realised
that there really was no reason at all to not use a wrapped list:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">Program</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">P</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Foldable</span>, <span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Show</span>, <span class="org-haskell-constructor">Traversable</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Then each of the C API functions can be represented with
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Create</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Push</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Pop</span>
    <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org63a6359" class="outline-2">
<h2 id="org63a6359"><code>Arbitrary</code> for <code>Statement</code></h2>
<div class="outline-text-2" id="text-org63a6359">
<p>
My implementation of <code>Arbitrary</code> for <code>Statement</code> is very simple:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Arbitrary</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-keyword">where</span>
    arbitrary <span class="org-haskell-operator">=</span> oneof <span class="org-rainbow-delimiters-depth-1">[</span>return <span class="org-haskell-constructor">Create</span>, return <span class="org-haskell-constructor">Pop</span>, liftM <span class="org-haskell-constructor">Push</span> arbitrary<span class="org-rainbow-delimiters-depth-1">]</span>
    shrink <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Push</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Push</span> <span class="org-haskell-operator">&lt;$&gt;</span> shrink i
    shrink <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span>
</pre>
</div>

<p>
That is, <code>arbitrary</code> just returns one of the constructors of <code>Statement</code>, and
shrinking only returns anything for the one constructor that takes an argument,
<code>Push</code>.
</p>
</div>
</div>

<div id="outline-container-org2a84010" class="outline-2">
<h2 id="org2a84010">Prerequisites of <code>Arbitrary</code> for <code>Program Statement</code></h2>
<div class="outline-text-2" id="text-org2a84010">
<p>
I want to ensure that all <code>Program Statement</code> are valid, which means I need to
define the model for running the program and functions for checking the
precondition of a statement as well as for updating the model (i.e. for running
the <code>Statement</code>).
</p>

<p>
Based on the <a href="#org5c47d51">C API</a> above it seems necessary to track creation, the contents of
the stack, and even if it isn't explicitly mentioned it's probably a good idea
to track the popped value. Using <a href="http://hackage.haskell.org/package/record"><code>record</code></a> (<code>Record</code> is imported as <code>R</code>, and
<code>Record.Lens</code> as <code>RL</code>) I defined it like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">ModelContext</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>R.r<span class="org-haskell-quasi-quote">| { created :: Bool, pop :: Maybe Int, stack :: [Int] } |</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
Based on the rather informal specification I coded the pre-conditions for the
three statements as
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">preCond</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ModelContext</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Bool</span>
<span class="org-haskell-definition">preCond</span> ctx <span class="org-haskell-constructor">Create</span> <span class="org-haskell-operator">=</span> not <span class="org-haskell-operator">$</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| created |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
<span class="org-haskell-definition">preCond</span> ctx <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Push</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| created |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
<span class="org-haskell-definition">preCond</span> ctx <span class="org-haskell-constructor">Pop</span> <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| created |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
</pre>
</div>

<p>
That is
</p>

<ul class="org-ul">
<li><code>Create</code> requires that the stack hasn't been created already.</li>
<li><code>Push i</code> requires that the stack has been created.</li>
<li><code>Pop</code> also requires that the stack has been created.</li>
</ul>

<p>
Furthermore the "specification" suggests the following definition of a function
for running a statement:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">modelRunStatement</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ModelContext</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ModelContext</span>
<span class="org-haskell-definition">modelRunStatement</span> ctx <span class="org-haskell-constructor">Create</span> <span class="org-haskell-operator">=</span> RL.set <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| created |</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-constructor">True</span> ctx
<span class="org-haskell-definition">modelRunStatement</span> ctx <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Push</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> RL.over <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| stack |</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">(</span>i <span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">)</span> ctx
<span class="org-haskell-definition">modelRunStatement</span> ctx <span class="org-haskell-constructor">Pop</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>R.r<span class="org-haskell-quasi-quote">| { created = c, pop = headMay s, stack = tail s } |</span><span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-haskell-keyword">where</span>
        c <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| created |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
        s <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| stack |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
</pre>
</div>

<p>
(This definition assumes that the model satisfies the pre-conditions, as can be
seen in the use of <code>tail</code>.)
</p>
</div>
</div>

<div id="outline-container-org9eab783" class="outline-2">
<h2 id="org9eab783"><code>Arbitrary</code> for <code>Program Statement</code></h2>
<div class="outline-text-2" id="text-org9eab783">
<p>
With this in place I can define <code>Arbitrary</code> for <code>Program Statement</code> as
follows.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Arbitrary</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Program</span> <span class="org-haskell-type">Statement</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
    arbitrary <span class="org-haskell-operator">=</span> liftM <span class="org-haskell-constructor">P</span> <span class="org-haskell-operator">$</span> ar baseModelCtx
        <span class="org-haskell-keyword">where</span>
            ar m <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
                push <span class="org-haskell-operator">&lt;-</span> liftM <span class="org-haskell-constructor">Push</span> arbitrary
                <span class="org-haskell-keyword">let</span> possible <span class="org-haskell-operator">=</span> filter <span class="org-rainbow-delimiters-depth-1">(</span>preCond m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-constructor">Create</span>, <span class="org-haskell-constructor">Pop</span>, push<span class="org-rainbow-delimiters-depth-1">]</span>
                <span class="org-haskell-keyword">if</span> null possible
                    <span class="org-haskell-keyword">then</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span>
                    <span class="org-haskell-keyword">else</span> <span class="org-haskell-keyword">do</span>
                        s <span class="org-haskell-operator">&lt;-</span> oneof <span class="org-rainbow-delimiters-depth-1">(</span>map return possible<span class="org-rainbow-delimiters-depth-1">)</span>
                        <span class="org-haskell-keyword">let</span> m' <span class="org-haskell-operator">=</span> modelRunStatement m s
                        frequency <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">499</span>, liftM2 <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">(</span>return s<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">(</span>ar m'<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">1</span>, return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-3">[]</span></span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
The idea is to, in each step, choose a valid statement given the provided model
and cons it with the result of a recursive call with an updated model. The
constant 499 is just an arbitrary one I chose after running <code>arbitrary</code> a few
times to see how long the generated programs were.
</p>

<p>
For shrinking I take advantage of the already existing implementation for lists:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">shrink</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">P</span> p<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> filter allowed <span class="org-haskell-operator">$</span> map <span class="org-haskell-constructor">P</span> <span class="org-rainbow-delimiters-depth-1">(</span>shrink p<span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-haskell-keyword">where</span>
        allowed <span class="org-haskell-operator">=</span> and <span class="org-haskell-operator">.</span> snd <span class="org-haskell-operator">.</span> mapAccumL go baseModelCtx
            <span class="org-haskell-keyword">where</span>
                go ctx s <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>modelRunStatement ctx s, preCond ctx s<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org637962f" class="outline-2">
<h2 id="org637962f">Some thoughts so far</h2>
<div class="outline-text-2" id="text-org637962f">
<p>
I would love making an implementation of <code>Arbitrary s</code>, where <code>s</code> is something
that implements a type class that contains <code>preCond</code>, <code>modelRunStatement</code> and
anything else needed. I made an attempt using something like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">S</span> a <span class="org-haskell-keyword">where</span>
    <span class="org-haskell-keyword">type</span> <span class="org-haskell-type">Ctx</span> a <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span>

    baseCtx <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Ctx</span> a
    preCond <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Ctx</span> a <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Bool</span>
    <span class="org-haskell-operator">...</span>
</pre>
</div>

<p>
However, when trying to use <code>baseCtx</code> in an implementation of <code>arbitrary</code> I ran
into the issue of injectivity. I'm still not entirely sure what that means, or
if there is something I can do to work around it. Hopefully someone reading this
can offer a solution.
</p>
</div>
</div>

<div id="outline-container-orga64057c" class="outline-2">
<h2 id="orga64057c">Running the C code</h2>
<div class="outline-text-2" id="text-orga64057c">
<p>
When running the sequence of <code>Statement</code> against the C code I catch the results
in
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">RealContext</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>r<span class="org-haskell-quasi-quote">| { o :: Ptr (), pop :: Maybe Int } |</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
Actually running a statement and capturing the output in a <code>RealContext</code> is
easily done using <code>inline-c</code> and <code>record</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">realRunStatement</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">RealContext</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">RealContext</span>
<span class="org-haskell-definition">realRunStatement</span> ctx <span class="org-haskell-constructor">Create</span> <span class="org-haskell-operator">=</span> CApi.create <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span> ptr <span class="org-haskell-operator">-&gt;</span> return <span class="org-haskell-operator">$</span> RL.set <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| o |</span><span class="org-rainbow-delimiters-depth-1">]</span> ptr ctx
<span class="org-haskell-definition">realRunStatement</span> ctx <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Push</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> CApi.push o <span class="org-rainbow-delimiters-depth-1">(</span>toEnum i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;</span> return ctx
    <span class="org-haskell-keyword">where</span>
        o <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| o |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
<span class="org-haskell-definition">realRunStatement</span> ctx <span class="org-haskell-constructor">Pop</span> <span class="org-haskell-operator">=</span> CApi.pop o <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span> v <span class="org-haskell-operator">-&gt;</span> return <span class="org-haskell-operator">$</span> RL.set <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| pop |</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Just</span> <span class="org-rainbow-delimiters-depth-2">(</span>fromEnum v<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> ctx
    <span class="org-haskell-keyword">where</span>
        o <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| o |</span><span class="org-rainbow-delimiters-depth-1">]</span> ctx
</pre>
</div>
</div>
</div>

<div id="outline-container-org8c5786b" class="outline-2">
<h2 id="org8c5786b">Comparing states</h2>
<div class="outline-text-2" id="text-org8c5786b">
<p>
Comparing a <code>ModelContext</code> and a <code>RealContext</code> is easily done:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">compCtx</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ModelContext</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">RealContext</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Bool</span>
<span class="org-haskell-definition">compCtx</span> mc rc <span class="org-haskell-operator">=</span> mcC <span class="org-haskell-operator">==</span> rcC <span class="org-haskell-operator">&amp;&amp;</span> mcP <span class="org-haskell-operator">==</span> rcP
    <span class="org-haskell-keyword">where</span>
        mcC <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| created |</span><span class="org-rainbow-delimiters-depth-1">]</span> mc
        rcC <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| o |</span><span class="org-rainbow-delimiters-depth-1">]</span> rc <span class="org-haskell-operator">/=</span> nullPtr
        mcP <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| pop|</span><span class="org-rainbow-delimiters-depth-1">]</span> mc
        rcP <span class="org-haskell-operator">=</span> RL.view <span class="org-rainbow-delimiters-depth-1">[</span>R.l<span class="org-haskell-quasi-quote">| pop|</span><span class="org-rainbow-delimiters-depth-1">]</span> rc
</pre>
</div>
</div>
</div>

<div id="outline-container-org12af561" class="outline-2">
<h2 id="org12af561">Verifying a <code>Program Statement</code></h2>
<div class="outline-text-2" id="text-org12af561">
<p>
With all that in place I can finally write a function for checking the validity
of a program:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">validProgram</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">Bool</span>
<span class="org-haskell-definition">validProgram</span> p <span class="org-haskell-operator">=</span> and <span class="org-haskell-operator">&lt;$&gt;</span> snd <span class="org-haskell-operator">&lt;$&gt;</span> mapAccumM go <span class="org-rainbow-delimiters-depth-1">(</span>baseModelCtx, baseRealContext<span class="org-rainbow-delimiters-depth-1">)</span> p
    <span class="org-haskell-keyword">where</span>
        runSingleStatement mc rc s <span class="org-haskell-operator">=</span> realRunStatement rc s <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span> rc' <span class="org-haskell-operator">-&gt;</span> return <span class="org-rainbow-delimiters-depth-1">(</span>modelRunStatement mc s, rc'<span class="org-rainbow-delimiters-depth-1">)</span>

        go <span class="org-rainbow-delimiters-depth-1">(</span>mc, rc<span class="org-rainbow-delimiters-depth-1">)</span> s <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
            ctxs<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span>mc', rc'<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> runSingleStatement mc rc s
            return <span class="org-rainbow-delimiters-depth-1">(</span>ctxs, compCtx mc' rc'<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
(This uses <code>mapAccumM</code> from an <a href="2015-06-09-000-mapaccum-in-monad.html">earlier post of mine</a>.)
</p>
</div>
</div>

<div id="outline-container-org813eb63" class="outline-2">
<h2 id="org813eb63">The property, finally!</h2>
<div class="outline-text-2" id="text-org813eb63">
<p>
To wrap this all up I then define the property
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">prop_program</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Program</span> <span class="org-haskell-type">Statement</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Property</span>
<span class="org-haskell-definition">prop_program</span> p <span class="org-haskell-operator">=</span> monadicIO <span class="org-haskell-operator">$</span> run <span class="org-rainbow-delimiters-depth-1">(</span>validProgram p<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;=</span> assert
</pre>
</div>

<p>
and a main function
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> quickCheck prop_program
</pre>
</div>

<hr>

<p>
<i>Edit 2015-07-17</i>: Adjusted the description of the pre-conditions to match the
code.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-quickcheck.html">quickcheck</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>
<div class="post-date">09 Jun 2015</div><h1 class="post-title"><a href="https://magnus.therning.org/2015-06-09-000-mapaccum-in-monad.html">mapAccum in monad</a></h1>
<p>
I recently had two functions of very similar shape, only difference was that one
was pure and the other need some I/O. The former was easily written using
<code>mapAccumL</code>. I failed to find a function like <code>mapAccumL</code> that runs in a monad,
so I wrote up the following:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mapAccumM</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Monad</span> m, <span class="org-haskell-type">Traversable</span> t<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>a <span class="org-haskell-operator">-&gt;</span> b <span class="org-haskell-operator">-&gt;</span> m <span class="org-rainbow-delimiters-depth-2">(</span>a, c<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> t b <span class="org-haskell-operator">-&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span>a, t c<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">mapAccumM</span> f a l <span class="org-haskell-operator">=</span> swap <span class="org-haskell-operator">&lt;$&gt;</span> runStateT <span class="org-rainbow-delimiters-depth-1">(</span>mapM go l<span class="org-rainbow-delimiters-depth-1">)</span> a
    <span class="org-haskell-keyword">where</span>
        go i <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
            s <span class="org-haskell-operator">&lt;-</span> get
            <span class="org-rainbow-delimiters-depth-1">(</span>s', r<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> lift <span class="org-haskell-operator">$</span> f s i
            put s'
            return r
</pre>
</div>

<p>
Bring on the comments/suggestions/improvements/etc!
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>
<div class="post-date">05 Jun 2007</div><h1 class="post-title"><a href="https://magnus.therning.org/2007-06-05-296-adventures-in-parsing,-part-4.html">Adventures in parsing, part 4</a></h1>
<p>
I received a few comments on <a href="https://magnus.therning.org/2007-06-03-295-adventures-in-parsing,-part-3.html">part 3</a> of this little mini-series and I just wanted
to address them. While doing this I still want the main functions of the parser
<code>parseXxx</code> to read like the <code>maps</code> file itself. That means I want to avoid
"reversing order" like <code>thenChar</code> and <code>thenSpace</code> did in <a href="https://magnus.therning.org/2007-05-29-290-more-adventures-in-parsing.html">part 2</a>. I also don't
want to hide things, e.g. I don't want to introduce a function that turns <code>(a &lt;*
char ' ') &lt;*&gt; b</code> into <code>a &lt;#&gt; b</code>.
</p>

<p>
So, first up is to do something about <code>hexStr2Int &lt;$&gt; many1 hexDigit</code> which
appears all over the place. I made it appear in even more places by moving
around a few parentheses; the following two functions are the same:
</p>

<div class="org-src-container">
<pre class="src src-haskell">foo = a <span class="org-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>b <span class="org-operator">&lt;*</span> c<span class="org-rainbow-delimiters-depth-1">)</span>
bar = <span class="org-rainbow-delimiters-depth-1">(</span>a <span class="org-operator">&lt;$&gt;</span> b<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;*</span> c
</pre>
</div>

<p>
Then I scrapped <code>hexStr2Int</code> completely and instead introduced <code>hexStr</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">hexStr = <span class="org-warning">Prelude</span>.read <span class="org-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0x"</span> <span class="org-operator">++</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;$&gt;</span> many1 hexDigit
</pre>
</div>

<p>
This means that <code>parseAddress</code> can be rewritten to:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = Address <span class="org-operator">&lt;$&gt;</span>
    hexStr <span class="org-operator">&lt;*</span> char <span class="org-string">'-'</span> <span class="org-operator">&lt;*&gt;</span>
    hexStr
</pre>
</div>

<p>
Rather than, as Conal suggested, introduce an infix operation that addresses the
pattern <code>(a &lt;* char ' ') &lt;*&gt; b</code> I decided to do something about <code>a &lt;* char c</code>. I
feel Conal's suggestion, while shortening the code more than my solution, goes
against my wish to not hide things. This is the definition of <code>&lt;##&gt;</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-operator">&lt;##&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> l r = l <span class="org-operator">&lt;*</span> char r
</pre>
</div>

<p>
After this I rewrote <code>parseAddress</code> into:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = Address <span class="org-operator">&lt;$&gt;</span>
    hexStr <span class="org-operator">&lt;##&gt;</span> <span class="org-string">'-'</span> <span class="org-operator">&lt;*&gt;</span>
    hexStr
</pre>
</div>

<p>
The pattern <code>(== c) &lt;$&gt; anyChar</code> appears three times in <code>parsePerms</code> so it got a
name and moved down into the <code>where</code> clause. I also modified <code>cA</code> to use pattern
matching. I haven't spent much time considering error handling in the parser, so
I didn't introduce a pattern matching everything else.
</p>

<div class="org-src-container">
<pre class="src src-haskell">parsePerms = Perms <span class="org-operator">&lt;$&gt;</span>
    pP <span class="org-string">'r'</span> <span class="org-operator">&lt;*&gt;</span>
    pP <span class="org-string">'w'</span> <span class="org-operator">&lt;*&gt;</span>
    pP <span class="org-string">'x'</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>cA <span class="org-operator">&lt;$&gt;</span> anyChar<span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-keyword">where</span>
        pP c = <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-operator">==</span> c<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;$&gt;</span> anyChar
        cA <span class="org-string">'p'</span> = Private
        cA <span class="org-string">'s'</span> = Shared
</pre>
</div>

<p>
The last change I did was remove a bunch of parentheses. I'm always a little
hesitant removing parentheses and relying on precedence rules, I find I'm even
more hesitant doing it when programming Haskell. Probably due to Haskell having
<i>a lot</i> of infix operators that I'm unused to.
</p>

<p>
The rest of the parser now looks like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseDevice = Device <span class="org-operator">&lt;$&gt;</span>
    hexStr <span class="org-operator">&lt;##&gt;</span> <span class="org-string">':'</span> <span class="org-operator">&lt;*&gt;</span>
    hexStr

parseRegion = MemRegion <span class="org-operator">&lt;$&gt;</span>
    parseAddress <span class="org-operator">&lt;##&gt;</span> <span class="org-string">' '</span> <span class="org-operator">&lt;*&gt;</span>
    parsePerms <span class="org-operator">&lt;##&gt;</span> <span class="org-string">' '</span> <span class="org-operator">&lt;*&gt;</span>
    hexStr <span class="org-operator">&lt;##&gt;</span> <span class="org-string">' '</span> <span class="org-operator">&lt;*&gt;</span>
    parseDevice <span class="org-operator">&lt;##&gt;</span> <span class="org-string">' '</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">Prelude</span>.read <span class="org-operator">&lt;$&gt;</span> many1 digit<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;##&gt;</span> <span class="org-string">' '</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>parsePath <span class="org-operator">&lt;|&gt;</span> string <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-keyword">where</span>
        parsePath = <span class="org-rainbow-delimiters-depth-1">(</span>many1 <span class="org-operator">$</span> char <span class="org-string">' '</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">*&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>many1 anyChar<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I think these changes address most of the comments Conal and Twan made on the
previous part. Where they don't I hope I've explained why I decided not to take
their advice.
</p>

<p>
<i>Comment by Jedaï:</i>
</p>

<p>
That's really pretty ! Code you can read, but concise, Haskell is really good at
that, though I need to look at how Applicative works its magic. :)
</p>

<p>
Good work !
</p>

<p>
<i>Comment by Conal Elliot:</i>
</p>

<p>
Magnus wrote
</p>

<blockquote>
<p>
I also don’t want to hide things, e.g. I don’t want to introduce a function that
turns <code>(a &lt;* char ' ') &lt;*&gt; b</code> into <code>a &lt;#&gt; b</code>.
</p>
</blockquote>

<p>
I'm puzzled about this comment. Aren't all of your definitions (as well as much
of Parsec and other Haskell libraries) "hiding things"?
</p>

<p>
What appeals to me about <code>a &lt;#&gt; b = (a &lt;* char ' ') &lt;*&gt; b</code> (and similarly for,
say "<code>a &lt;:&gt; b</code>", is that it captures the combination of a character separator
and <code>&lt;*&gt;</code>-style application. As your example illustrates (and hadn't previously
occurred to me), this combination is very common.
</p>

<p>
<i>Response to Conal:</i>
</p>

<p>
Conal, you are right and I was unclear in what I meant. Basically I like the
idea of reading the <code>parseXxx</code> functions and see the structure of the original
<code>maps</code> file. At the moment I think that
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = Address <span class="org-operator">&lt;$&gt;</span>
    hexStr <span class="org-operator">&lt;##&gt;</span> <span class="org-string">'-'</span> <span class="org-operator">&lt;*&gt;</span>
    hexStr
</pre>
</div>

<p>
better reflects the structure of the <code>maps</code> file than hiding away the separator
inside an operator. I also find it doesn't require me to carry a lot of "mental
baggage" when reading the code (I suspect this is the thing that's been
bothering me with the love of introducing operators that seems so prevalent
among Haskell developers, thanks for helping me put a finger on it). However,
your persistence might be paying off ;-) I'm warming to the idea. I just have to
come up with a scheme for naming operators that allows easy reading of the code.
</p>

<p>
<i>Comment by Conal Elliott:</i>
</p>

<p>
Oh! I'm finally getting what you've meant about "hiding things" vs "reflect[ing]
the structure of the <code>maps</code> file". I think you want the separator characters to
show up in the parser, and between the sub-parsers that they separate.
</p>

<p>
Maybe what's missing in my <code>&lt;#&gt;</code> suggestion is that the choice of the space
character as a separator is far from obvious, and I guess that's what you're
saying about "mental baggage" naming the operators for easy reading.
</p>

<p>
I suppose you could use <code>sepSpace</code> and <code>sepColon</code> as operator names.
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = Address <span class="org-operator">&lt;$&gt;</span> hexStr `sepColon` hexStr

parseRegion = MemRegion <span class="org-operator">&lt;$&gt;</span>
    parseAddress `sepSpace`
    parsePerms `sepSpace`
    ...
</pre>
</div>

<p>
Still, an actual space/colon character would probably be clearer. For colon, you
could use <code>&lt;:&gt;</code>, but what for space?
</p>

<p>
<i>Response to Conal:</i>
</p>

<p>
Conal, that's exactly what I mean, just much more clearly expressed than I could
ever hope to do.
</p>

<p>
I too was thinking of the problem with <code>space</code> in an operator&#x2026;
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-parsec.html">parsec</a> <a href="https://magnus.therning.org/tag-parsing.html">parsing</a> </div>

<div class="post-date">03 Jun 2007</div><h1 class="post-title"><a href="https://magnus.therning.org/2007-06-03-295-adventures-in-parsing,-part-3.html">Adventures in parsing, part 3</a></h1>
<p>
I got a great many comments, at least by my standards, on my earlier <a href="https://magnus.therning.org/2007-05-29-290-more-adventures-in-parsing.html">two</a> <a href="https://magnus.therning.org/2007-05-27-289-adventures-in-parsing.html">posts</a>
on parsing in Haskell. Especially on the latest one. Conal posted a comment on
the first pointing me towards <code>liftM</code> and its siblings, without telling me that
it would only be the first step towards "applicative style". So, here I go
again&#x2026;
</p>

<p>
First off, importing <code>Control.Applicative</code>. Apparently <code>&lt;|&gt;</code> is defined in both
<code>Applicative</code> and in <code>Parsec</code>. I do use <code>&lt;|&gt;</code> from <code>Parsec</code> so preventing
importing it from <code>Applicative</code> seemed like a good idea:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">import</span> Control.Applicative hiding <span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-rainbow-delimiters-depth-2">(</span>&lt;|&gt;<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Second, Cale pointed out that I need to make an instance for
<code>Control.Applicative.Applicative</code> for <code>GenParser</code>. He was nice enough to point
out how to do that, leaving syntax the only thing I had to struggle with:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">instance</span> <span class="org-type">Applicative</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">GenParser</span> c st<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">where</span>
    pure = return
    <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-operator">&lt;*&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> = ap
</pre>
</div>

<p>
I decided to take baby-steps and I started with <code>parseAddress</code>. Here's what it
used to look like:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = <span class="org-keyword">let</span>
        hexStr2Int = <span class="org-warning">Prelude</span>.read <span class="org-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0x"</span> <span class="org-operator">++</span><span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-keyword">in</span> <span class="org-keyword">do</span>
        start &lt;- liftM hexStr2Int <span class="org-operator">$</span> thenChar <span class="org-string">'-'</span> <span class="org-operator">$</span> many1 hexDigit
        end &lt;- liftM hexStr2Int <span class="org-operator">$</span> many1 hexDigit
        return <span class="org-operator">$</span> Address start end
</pre>
</div>

<p>
On Twan's suggestion I rewrote it using <code>where</code> rather than <code>let ... in</code> and
since this was my first function I decided to go via the <code>ap</code> function (at the
same time I broke out <code>hexStr2Int</code> since it's used in so many places):
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = <span class="org-keyword">do</span>
    start &lt;- return hexStr2Int `ap` <span class="org-rainbow-delimiters-depth-1">(</span>thenChar <span class="org-string">'-'</span> <span class="org-operator">$</span> many1 hexDigit<span class="org-rainbow-delimiters-depth-1">)</span>
    end &lt;- return hexStr2Int `ap` <span class="org-rainbow-delimiters-depth-1">(</span>many1 hexDigit<span class="org-rainbow-delimiters-depth-1">)</span>
    return <span class="org-operator">$</span> Address start end
</pre>
</div>

<p>
Then on to applying some functions from <code>Applicative</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = Address start end
    <span class="org-keyword">where</span>
        start = hexStr2Int <span class="org-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>thenChar <span class="org-string">'-'</span> <span class="org-operator">$</span> many1 hexDigit<span class="org-rainbow-delimiters-depth-1">)</span>
        end = hexStr2Int <span class="org-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>many1 hexDigit<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
By now the use of <code>thenChar</code> looks a little silly so I changed that part into
<code>many1 hexDigit &lt;* char '-'</code> instead. Finally I removed the <code>where</code> part
altogether and use <code>&lt;*&gt;</code> to string it all together:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = Address <span class="org-operator">&lt;$&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>hexStr2Int <span class="org-operator">&lt;$&gt;</span> many1 hexDigit <span class="org-operator">&lt;*</span> char <span class="org-string">'-'</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>hexStr2Int <span class="org-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span>many1 hexDigit<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
From here on I skipped the intermediate steps and went straight for the last
form. Here's what I ended up with:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parsePerms = Perms <span class="org-operator">&lt;$&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-operator">==</span> <span class="org-string">'r'</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-operator">&lt;$&gt;</span> anyChar<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-operator">==</span> <span class="org-string">'w'</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-operator">&lt;$&gt;</span> anyChar<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-operator">==</span> <span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-operator">&lt;$&gt;</span> anyChar<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>cA <span class="org-operator">&lt;$&gt;</span> anyChar<span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-keyword">where</span>
        cA a = <span class="org-keyword">case</span> a <span class="org-keyword">of</span>
            <span class="org-string">'p'</span> -&gt; Private
            <span class="org-string">'s'</span> -&gt; Shared

parseDevice = Device <span class="org-operator">&lt;$&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>hexStr2Int <span class="org-operator">&lt;$&gt;</span> many1 hexDigit <span class="org-operator">&lt;*</span> char <span class="org-string">':'</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>hexStr2Int <span class="org-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span>many1 hexDigit<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

parseRegion = MemRegion <span class="org-operator">&lt;$&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>parseAddress <span class="org-operator">&lt;*</span> char <span class="org-string">' '</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>parsePerms <span class="org-operator">&lt;*</span> char <span class="org-string">' '</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>hexStr2Int <span class="org-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span>many1 hexDigit <span class="org-operator">&lt;*</span> char <span class="org-string">' '</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>parseDevice <span class="org-operator">&lt;*</span> char <span class="org-string">' '</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">Prelude</span>.read <span class="org-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span>many1 digit <span class="org-operator">&lt;*</span> char <span class="org-string">' '</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&lt;*&gt;</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>parsePath <span class="org-operator">&lt;|&gt;</span> string <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-keyword">where</span>
        parsePath = <span class="org-rainbow-delimiters-depth-1">(</span>many1 <span class="org-operator">$</span> char <span class="org-string">' '</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">*&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>many1 anyChar<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I have to say I'm fairly pleased with this version of the parser. It reads about
as easy as the first version and there's none of the "reversing" that <code>thenChar</code>
introduced.
</p>

<p>
<i>Comment by Conal Elliott:</i>
</p>

<p>
A thing of beauty!  I'm glad you stuck with it, Magnus.
</p>

<p>
Some much smaller points:
</p>

<ul class="org-ul">
<li>The pattern <code>(== c) &lt;$&gt; anyChar</code> (nicely written, btw) arises three times, so
it might merit a name.</li>
<li>Similarly for <code>hexStr2Int &lt;$&gt; many1 hexDigit</code>, especially when you rewrite <code>f
  &lt;$&gt; (a &lt;* b)</code> to <code>(f &lt;$&gt; a) &lt;* b</code>.</li>
<li>The pattern <code>(a &lt;* char ' ') &lt;*&gt; b</code> comes up a lot. How about naming it also,
with a nice infix op, say <code>a &lt;#&gt; b</code>?</li>
<li>The cA definition could use pattern matching instead (e.g., <code>cA 'p' = Private</code>
and <code>cA 's' = Shared</code>).</li>
<li>Some of your parens are unnecessary (3rd line of <code>parseDevice</code> and last of
<code>parseRegion</code>), since application binds more tightly than infix ops.</li>
</ul>

<p>
<i>Comment by Twan van Laarhoven:</i>
</p>

<p>
First of all, note that you don't need parentheses around <code>parseSomething &lt;*
char ' '</code>.
</p>

<p>
You can also simplify things a bit more by combining <code>hexStr2Int &lt;$&gt; many1
hexDigit</code> into a function, then you could say:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseHex = hexStr2Int <span class="org-operator">&lt;$&gt;</span> many1 hexDigit
parseAddress = Address <span class="org-operator">&lt;$&gt;</span> parseHex <span class="org-operator">&lt;*</span> char <span class="org-string">'-'</span> <span class="org-operator">&lt;*&gt;</span> parseHex
parseDevice  = Device <span class="org-operator">&lt;$&gt;</span> parseHex <span class="org-operator">&lt;&lt;/</span>em<span class="org-operator">&gt;</span> char <span class="org-string">':'</span> <span class="org-operator">&lt;*&gt;</span> parseHex
</pre>
</div>

<p>
Also, in <code>cA</code>, should there be a case for character other than 'p' or 's'?
Otherwise the program could fail with a pattern match error.
</p>

<p>
<i>Response to Conal and Twan:</i>
</p>

<p>
Conal and Twan, thanks for your suggestions. I'll put them into practice and
post the "final" result as soon as I find some time.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-parsec.html">parsec</a> <a href="https://magnus.therning.org/tag-parsing.html">parsing</a> </div>

<div class="post-date">29 May 2007</div><h1 class="post-title"><a href="https://magnus.therning.org/2007-05-29-290-more-adventures-in-parsing.html">More adventures in parsing</a></h1>
<p>
I received an interesting comment from Conal Elliott on my <a href="https://magnus.therning.org/2007-05-27-289-adventures-in-parsing.html">previous post on
parsing</a> I have to admit I wasn't sure I understood him at first, I'm still not
sure I do, but I think I have an idea of what he means :-)
</p>

<p>
Basically my code is very sequential in that I use the <code>do</code> construct everywhere
in the parsing code. Personally I thought that makes the parser very easy to
read since the code very much mimics the structure of the <code>maps</code> file. I do
realise the code isn't very "functional" though so I thought I'd take Conal's
comments to heart and see what the result would be.
</p>

<p>
Let's start with observation that every entity in a line is separated by a
space. However some things are separated by other characters. So the first thing
I did was write a higher-order function that first reads something, then reads a
character and returns the first thing that was read:
</p>

<div class="org-src-container">
<pre class="src src-haskell">thenChar c f = f <span class="org-operator">&gt;&gt;=</span> <span class="org-rainbow-delimiters-depth-1">(</span>\ r -&gt; char c <span class="org-operator">&gt;&gt;</span> return r<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Since space is used as a separator so often I added a short-cut for that:
</p>

<div class="org-src-container">
<pre class="src src-haskell">thenSpace  = thenChar <span class="org-string">' '</span>
</pre>
</div>

<p>
Then I put that to use on <code>parseAddress</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = <span class="org-keyword">let</span>
        hexStr2Int = <span class="org-warning">Prelude</span>.read <span class="org-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0x"</span> <span class="org-operator">++</span><span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-keyword">in</span> <span class="org-keyword">do</span>
        start &lt;- thenChar <span class="org-string">'-'</span> <span class="org-operator">$</span> many1 hexDigit
        end &lt;- many1 hexDigit
        return <span class="org-operator">$</span> Address <span class="org-rainbow-delimiters-depth-1">(</span>hexStr2Int start<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>hexStr2Int end<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Modifying the other parsing functions using =thenChar~ and <code>thenSpace</code> is
straight forward.
</p>

<p>
I'm not entirely sure I understand what Conal meant with the part about <code>liftM</code>
in his comment. I suspect his referring to the fact that I first read characters
and then convert them in the "constructors". By using <code>liftM</code> I can move the
conversion "up in the code". Here's <code>parseAddress</code> after I've moved the calls to
<code>hexStr2Int</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = <span class="org-keyword">let</span>
        hexStr2Int = <span class="org-warning">Prelude</span>.read <span class="org-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0x"</span> <span class="org-operator">++</span><span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-keyword">in</span> <span class="org-keyword">do</span>
        start &lt;- liftM hexStr2Int <span class="org-operator">$</span> thenChar <span class="org-string">'-'</span> <span class="org-operator">$</span> many1 hexDigit
        end &lt;- liftM hexStr2Int <span class="org-operator">$</span> many1 hexDigit
        return <span class="org-operator">$</span> Address start end
</pre>
</div>

<p>
After modifying the other parsing functions in a similar way I ended up with this:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parsePerms = <span class="org-keyword">let</span>
        cA a = <span class="org-keyword">case</span> a <span class="org-keyword">of</span>
            <span class="org-string">'p'</span> -&gt; Private
            <span class="org-string">'s'</span> -&gt; Shared
    <span class="org-keyword">in</span> <span class="org-keyword">do</span>
        r &lt;- liftM <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-operator">==</span> <span class="org-string">'r'</span><span class="org-rainbow-delimiters-depth-1">)</span> anyChar
        w &lt;- liftM <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-operator">==</span> <span class="org-string">'w'</span><span class="org-rainbow-delimiters-depth-1">)</span> anyChar
        x &lt;- liftM <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-operator">==</span> <span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-1">)</span> anyChar
        a &lt;- liftM cA anyChar
        return <span class="org-operator">$</span> Perms r w x a

parseDevice = <span class="org-keyword">let</span>
        hexStr2Int = <span class="org-warning">Prelude</span>.read <span class="org-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0x"</span> <span class="org-operator">++</span><span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-keyword">in</span> <span class="org-keyword">do</span>
        maj &lt;- liftM hexStr2Int <span class="org-operator">$</span> thenChar <span class="org-string">':'</span> <span class="org-operator">$</span> many1 hexDigit
        min &lt;- liftM hexStr2Int <span class="org-operator">$</span> many1 hexDigit
        return <span class="org-operator">$</span> Device maj min

parseRegion = <span class="org-keyword">let</span>
        hexStr2Int = <span class="org-warning">Prelude</span>.read <span class="org-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0x"</span> <span class="org-operator">++</span><span class="org-rainbow-delimiters-depth-1">)</span>
        parsePath = <span class="org-rainbow-delimiters-depth-1">(</span>many1 <span class="org-operator">$</span> char <span class="org-string">' '</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&gt;&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>many1 <span class="org-operator">$</span> anyChar<span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-keyword">in</span> <span class="org-keyword">do</span>
        addr &lt;- thenSpace parseAddress
        perm &lt;- thenSpace parsePerms
        offset &lt;- liftM hexStr2Int <span class="org-operator">$</span> thenSpace <span class="org-operator">$</span> many1 hexDigit
        dev &lt;- thenSpace parseDevice
        inode &lt;- liftM <span class="org-warning">Prelude</span>.read <span class="org-operator">$</span> thenSpace <span class="org-operator">$</span> many1 digit
        path &lt;- parsePath <span class="org-operator">&lt;|&gt;</span> string <span class="org-string">""</span>
        return <span class="org-operator">$</span> MemRegion addr perm offset dev inode path
</pre>
</div>

<p>
Is this code more "functional"? Is it easier to read? You'll have to be the
judge of that&#x2026;
</p>

<p>
Conal, if I got the intention of your comment completely wrong then feel free to
tell me I'm an idiot ;-)
</p>

<p>
<i>Comment by Holger:</i>
</p>

<p>
Your story and Conal's comment inspired me to
play around with liftM and I came up with this version of parseAddress:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = <span class="org-keyword">let</span>
        hexStr2Int = <span class="org-warning">Prelude</span>.read <span class="org-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0x"</span> <span class="org-operator">++</span><span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-keyword">in</span>
        liftM3 <span class="org-rainbow-delimiters-depth-1">(</span>\ x _ y -&gt; Address <span class="org-rainbow-delimiters-depth-2">(</span>hexStr2Int x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>hexStr2Int y<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>many1 hexDigit<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>char <span class="org-string">'-'</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>many1 hexDigit<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
You could probably rewrite all the functions in a similar way, but honestly I find your original code in do-notation much easier to read.
</p>

<p>
<i>Response to Holger:</i>
</p>

<p>
Yeah, the same line of thought made it a little difficult to fall asleep
yesterday (yes, I know, nerdiness taken to new levels). My thoughts was
something like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = <span class="org-keyword">let</span>
        hexStr2Int = ...
    <span class="org-keyword">in</span>
        liftM2 Address
            <span class="org-rainbow-delimiters-depth-1">(</span>liftM hexStr2Int <span class="org-operator">$</span> thenChar <span class="org-string">'-'</span> <span class="org-operator">$</span> many1 hexDigit<span class="org-rainbow-delimiters-depth-1">)</span>
            <span class="org-rainbow-delimiters-depth-1">(</span>liftM hexStr2Int <span class="org-operator">$</span> many1 hexDigit<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I agree with you on readability. I also wonder if laziness could bite back or if
`liftM2` guarantees an order of evaluation.
</p>

<p>
<i>Comment by Holger:</i>
</p>

<p>
I just looked at the source of liftM2/3 and it seems that it basically just
resolves to an expression in do-notation. So it's just a shortcut and therefore
should yield the same program.
</p>

<p>
<i>Comment by Cale Gibbard:</i>
</p>

<p>
<code>liftM2</code> guarantees an ordering on the monadic computation, because it's defined like:
</p>

<div class="org-src-container">
<pre class="src src-haskell">liftM2 f x y = <span class="org-keyword">do</span> <span class="org-rainbow-delimiters-depth-1">{</span> u &lt;- x; v &lt;- y; return <span class="org-rainbow-delimiters-depth-2">(</span>f u v<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Though, that's a little different from guaranteeing an order of evaluation &#x2013;
depending on the monad, the order of evaluation will vary. In any case, it
shouldn't be much different from what you originally had.
</p>

<p>
Another thing you might like to play around with, at least in your head, is the
fact that:
</p>

<div class="org-src-container">
<pre class="src src-haskell">liftM2 f x y = return f `ap` x `ap` y

liftM3 f x y z = return f `ap` x `ap` y `ap` z
</pre>
</div>

<p>
and so on, which leads up to the style embodied by the Control.Applicative
library, though if you really want to play around with that, you'll need to
write a quick instance of Applicative for GenParser, which should just consist
of making <code>pure = return</code> and <code>(&lt;*&gt;) = ap</code>.
</p>

<p>
<i>Comment by Twan van Laarhoven:</i>
</p>

<p>
The best way to make parsing code readable is to use Data.Applicative. Also,
most people prefer where to <code>let..in</code> if possible. This gives something like:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseHexStr = <span class="org-warning">Prelude</span>.read <span class="org-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0x"</span> <span class="org-operator">++</span><span class="org-rainbow-delimiters-depth-1">)</span>  many1 hexDigit
parsePath   = many1 <span class="org-rainbow-delimiters-depth-1">(</span>char <span class="org-string">' '</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">*&gt;</span> many1 anyChar

parseAddress = Address  hexStr <span class="org-operator">*&gt;</span> char <span class="org-string">'-'</span>  hexStr

parseRegion = MemRegion
            parseAddress <span class="org-operator">*&gt;</span> char <span class="org-string">' '</span>
            parsePerms   <span class="org-operator">*&gt;</span> char <span class="org-string">' '</span>
            parseHexStr  <span class="org-operator">*&gt;</span> char <span class="org-string">' '</span>
            parseDevice  <span class="org-operator">*&gt;</span> char <span class="org-string">' '</span>
            <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">Prelude</span>.read  many1 digit<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">*&gt;</span> char <span class="org-string">' '</span>
            <span class="org-rainbow-delimiters-depth-1">(</span>parsePath  return <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Basicly <code>(liftM# f x y z)</code> can be written as <code>f  x &lt;*&gt; y &lt;*&gt; z</code>.
</p>

<p>
<i>Comment by Nick:</i>
</p>

<p>
I find the <code>thenSpace</code> a bit difficult to read.I think something like this is
more natural, as it maintains the left-to-right relationship of the parsed data
and the following space:
</p>

<div class="org-src-container">
<pre class="src src-haskell">aChar c r = char c <span class="org-operator">&gt;&gt;</span> return r
aSpace = aChar <span class="org-string">' '</span>

...
    <span class="org-keyword">do</span>
        start &lt;-  many1 hexDigit <span class="org-operator">&gt;&gt;</span> aChar
....
</pre>
</div>

<p>
note that I haven't tested this and my haskell-fu is not very strong, so I could
be way off here.
</p>

<p>
<i>Comment by Conal Elliot:</i>
</p>

<p>
Yes, that's exactly the direction i had in mind. once you switch from "do" style
to "liftM#" style, it's a simple step to replace the monad operators to
applicative functor operators.
</p>

<p>
<i>Response to Nick:</i>
</p>

<p>
Nick, yes your way of writing it is easier to read. You'll need to change to
using <code>&gt;&gt;=</code> though:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">do</span>
    start &lt;- many1 hexDigit <span class="org-operator">&gt;&gt;=</span> aChar <span class="org-string">'-'</span>
</pre>
</div>

<p>
Then you can mix in `liftM` as well:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">do</span>
    start &lt;- liftM hexStr2Int <span class="org-operator">$</span> many1 hexDigit <span class="org-operator">&gt;&gt;=</span> aChar <span class="org-string">'-'</span>
</pre>
</div>

<p>
to do the conversion. However, I think my initial version is even clearer:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">do</span>
    start &lt;- liftM hexStr2Int <span class="org-operator">$</span> many1 hexDigitc
    char <span class="org-string">'-'</span>
</pre>
</div>

<p>
<i>Response to Conal Elliot:</i>
</p>

<p>
Conal, ok, you're one sneaky little b&#x2026; ;-) I'll have to look at the
applicative operators to see what I think of them.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-parsec.html">parsec</a> <a href="https://magnus.therning.org/tag-parsing.html">parsing</a> </div>

<div class="post-date">27 May 2007</div><h1 class="post-title"><a href="https://magnus.therning.org/2007-05-27-289-adventures-in-parsing.html">Adventures in parsing</a></h1>
<p>
I've long wanted to dip my toes in the <code>Parsec</code> water. I've made some attempts
before, but always stumbled on something that put me in the doldrums for so long
that I managed to repress all memories of ever having tried. A few files
scattered in my <code>~/devo/test/haskell</code> directory tells the story of my failed
attempts. Until now that is :-)
</p>

<p>
I picked a nice and regular task for my first real attempt: parsing
<code>/proc/&lt;pid&gt;/maps</code>. First a look at the man-page offers a good description of
the format of a line:
</p>

<pre class="example" id="org4947f04">
address           perms offset  dev   inode      pathname
08048000-08056000 r-xp 00000000 03:0c 64593      /usr/sbin/gpm
</pre>

<p>
So, I started putting together some datatypes. First off the address range:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">data</span> <span class="org-type">Address</span> = Address <span class="org-rainbow-delimiters-depth-1">{</span> start :: <span class="org-type">Integer</span>, end :: <span class="org-type">Integer</span> <span class="org-rainbow-delimiters-depth-1">}</span>
    <span class="org-keyword">deriving</span> <span class="org-type">Show</span>
</pre>
</div>

<p>
Then I decided that the 's'/'p' in the permissions should be called <code>Access</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">data</span> <span class="org-type">Access</span> = Shared | Private
    <span class="org-keyword">deriving</span> <span class="org-type">Show</span>
</pre>
</div>

<p>
The basic permissions (<code>rwx</code>) are simply represented as booleans:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">data</span> <span class="org-type">Perms</span> = Perms <span class="org-rainbow-delimiters-depth-1">{</span>
        read :: <span class="org-type">Bool</span>,
        write :: <span class="org-type">Bool</span>,
        executable :: <span class="org-type">Bool</span>,
        access :: <span class="org-type">Access</span>
    <span class="org-rainbow-delimiters-depth-1">}</span>
    <span class="org-keyword">deriving</span> <span class="org-type">Show</span>
</pre>
</div>

<p>
The device is straightforward as well:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">data</span> <span class="org-type">Device</span> = Device <span class="org-rainbow-delimiters-depth-1">{</span> major :: <span class="org-type">Integer</span>, minor :: <span class="org-type">Integer</span> <span class="org-rainbow-delimiters-depth-1">}</span>
    <span class="org-keyword">deriving</span> <span class="org-type">Show</span>
</pre>
</div>

<p>
At last I tie it all together in a final datatype that represents a memory region:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">data</span> <span class="org-type">MemRegion</span> = MemRegion <span class="org-rainbow-delimiters-depth-1">{</span>
        address :: <span class="org-type">Address</span>,
        perms :: <span class="org-type">Perms</span>,
        offset :: <span class="org-type">Integer</span>,
        device :: <span class="org-type">Device</span>,
        inode :: <span class="org-type">Integer</span>,
        pathname :: <span class="org-type">String</span>
    <span class="org-rainbow-delimiters-depth-1">}</span>
    <span class="org-keyword">deriving</span> <span class="org-type">Show</span>
</pre>
</div>

<p>
All types derive <code>Show</code> (and receive default implementations of <code>show</code>, at least
when using GHC) so that they are easy to print.
</p>

<p>
Now, on to the actual "parsec-ing". Faced with the option of writing it top-down
or bottom-up I chose the latter. However, since the format of a single line in
the <code>maps</code> file is so simple it's easy to imagine what the final function will
look like. I settled on bottom-up since the datatypes provide me with such an
obvious splitting of the line. First off, parsing the address range:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseAddress = <span class="org-keyword">let</span>
        hexStr2Int = <span class="org-warning">Prelude</span>.read <span class="org-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0x"</span> <span class="org-operator">++</span><span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-keyword">in</span> <span class="org-keyword">do</span>
        start &lt;- many1 hexDigit
        char <span class="org-string">'-'</span>
        end &lt;- many1 hexDigit
        return <span class="org-operator">$</span> Address <span class="org-rainbow-delimiters-depth-1">(</span>hexStr2Int start<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>hexStr2Int end<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Since the addresses themselves are in hexadecimal and always are of at least
length 1 I use <code>many1 hexDigit</code> to read them. I think it would be safe to assume
the addresses always are 8 characters (at least on a 32-bit machine) so it would
be possible to use <code>count 8 hexDigit</code> but I haven't tried it. I've found two
ways of converting a string representation of a hexadecimal number into an
<code>Integer</code>. Above I use the fact that <code>Prelude.read</code> interprets a string
beginning with <code>0x</code> as a hexadecimal number. The other way I've found is the
slightly less readable <code>fst . (!! 0) . readHex</code>. According to the man-page the
addresses are separated by a single dash so I've hardcoded that in there.
</p>

<p>
Testing the function is fairly simple. Using <code>gchi</code>, first load the source file
then use <code>parse</code>:
</p>

<pre class="example" id="org6268880">
*Main&gt; parse parseAddress "" "0-1"
Right (Address {start = 0, end = 1})
*Main&gt; parse parseAddress "hhh" "01234567-89abcdef"
Right (Address {start = 19088743, end = 2309737967})
</pre>

<p>
Seems to work well enough. :-)
</p>

<p>
Next up, parsing the permissions. This is so very straightforward that I don't
think I need to comment on it:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parsePerms = <span class="org-keyword">let</span>
        cA a = <span class="org-keyword">case</span> a <span class="org-keyword">of</span>
            <span class="org-string">'p'</span> -&gt; Private
            <span class="org-string">'s'</span> -&gt; Shared
    <span class="org-keyword">in</span> <span class="org-keyword">do</span>
        r &lt;- anyChar
        w &lt;- anyChar
        x &lt;- anyChar
        a &lt;- anyChar
        return <span class="org-operator">$</span> Perms <span class="org-rainbow-delimiters-depth-1">(</span>r <span class="org-operator">==</span> <span class="org-string">'r'</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>w <span class="org-operator">==</span> <span class="org-string">'w'</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>x <span class="org-operator">==</span> <span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>cA a<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
For parsing the device information I use the same strategy as for the address
range above, this time however the separating charachter is a colon:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseDevice = <span class="org-keyword">let</span>
        hexStr2Int = <span class="org-warning">Prelude</span>.read <span class="org-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0x"</span> <span class="org-operator">++</span><span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-keyword">in</span> <span class="org-keyword">do</span>
        maj &lt;- many1 digit
        char <span class="org-string">':'</span>
        min &lt;- many1 digit
        return <span class="org-operator">$</span> Device <span class="org-rainbow-delimiters-depth-1">(</span>hexStr2Int maj<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>hexStr2Int min<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Next is to tie it all together and create a MemRegion instance:
</p>

<div class="org-src-container">
<pre class="src src-haskell">parseRegion = <span class="org-keyword">let</span>
        hexStr2Int = <span class="org-warning">Prelude</span>.read <span class="org-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0x"</span> <span class="org-operator">++</span><span class="org-rainbow-delimiters-depth-1">)</span>
        parsePath = <span class="org-rainbow-delimiters-depth-1">(</span>many1 <span class="org-operator">$</span> char <span class="org-string">' '</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-operator">&gt;&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>many1 <span class="org-operator">$</span> anyChar<span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-keyword">in</span> <span class="org-keyword">do</span>
        addr &lt;- parseAddress
        char <span class="org-string">' '</span>
        perm &lt;- parsePerms
        char <span class="org-string">' '</span>
        offset &lt;- many1 hexDigit
        char <span class="org-string">' '</span>
        dev &lt;- parseDevice
        char <span class="org-string">' '</span>
        inode &lt;- many1 digit
        char <span class="org-string">' '</span>
        path &lt;- parsePath <span class="org-operator">&lt;|&gt;</span> string <span class="org-string">""</span>
        return <span class="org-operator">$</span> MemRegion addr perm <span class="org-rainbow-delimiters-depth-1">(</span>hexStr2Int offset<span class="org-rainbow-delimiters-depth-1">)</span> dev <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">Prelude</span>.read inode<span class="org-rainbow-delimiters-depth-1">)</span> path
</pre>
</div>

<p>
The only little trick here is that there are lines that lack the pathname.
Here's an example from the man-page:
</p>

<pre class="example" id="org089070b">
address           perms offset  dev   inode      pathname
08058000-0805b000 rwxp 00000000 00:00 0
</pre>

<p>
It should be noted that it seems there is a space after the inode entry so I
keep a <code>char ' '</code> in the main function. Then I try to parse the line for a path,
if there is none that attempt will fail immediately and instead I parse for an
empty string, <code>parsePath &lt;|&gt; string ""</code>. The pathname seems to be prefixed with
a fixed number of spaces, but I'm lazy and just consume one or more. I'm not
sure exactly what characters are allowed in the pathname itself so I'm lazy once
more and just gobble up whatever I find.
</p>

<p>
To exercise what I had so far I decided to write a function that reads the
<code>maps</code> file for a specific process, based on its <code>pid</code>, parses the contents and
collects all the <code>MemRegion</code> instances in a list.
</p>

<div class="org-src-container">
<pre class="src src-haskell">getMemRegions pid = <span class="org-keyword">let</span>
        fp = <span class="org-string">"/proc"</span> <span class="org-operator">&lt;/&gt;</span> show pid <span class="org-operator">&lt;/&gt;</span> <span class="org-string">"maps"</span>
        doParseLine' = parse parseRegion <span class="org-string">"parseRegion"</span>
        doParseLine l = <span class="org-keyword">case</span> <span class="org-rainbow-delimiters-depth-1">(</span>doParseLine' l<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">of</span>
            Left _ -&gt; error <span class="org-string">"Failed to parse line"</span>
            Right x -&gt; x
    <span class="org-keyword">in</span> <span class="org-keyword">do</span>
        mapContent &lt;- liftM lines <span class="org-operator">$</span> readFile fp
        return <span class="org-operator">$</span> map doParseLine mapContent
</pre>
</div>

<p>
The only thing that really is going on here is that the lines are passed from
inside an IO monad into the Parser monad and then back again. After this I can
try it out by:
</p>

<pre class="example" id="orgd35bcdb">
*Main&gt; getMemRegions 1
</pre>

<p>
This produces a lot of output so while playing with it I limited the mapping to
the four first lines by using <code>take</code>. The last line then becomes:
</p>

<div class="org-src-container">
<pre class="src src-haskell">return <span class="org-operator">$</span> map doParseLine <span class="org-rainbow-delimiters-depth-1">(</span>take <span class="org-number">4</span> mapContent<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Now it's easy to add a <code>main</code> that uses the first command line argument as the
<code>pid</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">main = <span class="org-keyword">do</span>
    pid &lt;- liftM <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">Prelude</span>.read <span class="org-operator">.</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-operator">!!</span> <span class="org-number">0</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> getArgs
    regs &lt;- getMemRegions pid
    mapM_ <span class="org-rainbow-delimiters-depth-1">(</span>putStrLn <span class="org-operator">.</span> show<span class="org-rainbow-delimiters-depth-1">)</span> regs
</pre>
</div>

<p>
Well, that concludes my first adventure in parsing :-)
</p>

<p>
<i>Edit (27-05-2007):</i> I received an email asking for it so here are the import
statements I ended up with:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-keyword">import</span> Control.Monad
<span class="org-keyword">import</span> System
<span class="org-keyword">import</span> System.FilePath
<span class="org-keyword">import</span> Text.ParserCombinators.Parsec
</pre>
</div>

<p>
<i>Comment by Conal Elliot:</i>
</p>

<p>
Congrats on your parser!
</p>

<p>
Here's an idea that for getting more functional/applicative formulations.
Replace all of the explicitly sequential (<code>do</code>) parsec code with <code>liftM</code>,
<code>liftM2</code>, &#x2026;. From a quick read-through, I think you can do it. For
<code>parseRegion</code>, you could use an auxiliary function that discards a following
space, e.g. <code>thenSpace (many1 digit)</code>.
</p>

<p>
Also, play with factoring out some of the repeated patterns in <code>parseAddress</code>,
<code>parsePerms</code> and <code>parseDevice</code>.
</p>

<p>
The more I play with refactoring in my code, the more elegant it gets and the
more insight I get. Have fun!
</p>

<p>
<i>Response to Conal:</i>
</p>

<p>
Good suggestion. At least if I understand what you mean :-)
</p>

<p>
Something along the lines of
</p>

<div class="org-src-container">
<pre class="src src-haskell">thenChar c f = f <span class="org-operator">&gt;&gt;=</span> <span class="org-rainbow-delimiters-depth-1">(</span>\ r -&gt; char c <span class="org-operator">&gt;&gt;</span> return r<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
with a specialised one for spaces maybe
</p>

<div class="org-src-container">
<pre class="src src-haskell">thenSpace = thenChar <span class="org-string">' '</span>
</pre>
</div>

<p>
I suppose <code>liftM</code> and friends can be employed to remove the function calling in
the creation of <code>Address</code>, <code>Device</code> and <code>MemRegion</code>. I'll try to venture into
<code>Parsec</code> territory once again soon and report on my findings. :-)
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-parsec.html">parsec</a> <a href="https://magnus.therning.org/tag-parsing.html">parsing</a> </div>
<div id="archive">
<a href="https://magnus.therning.org/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><!-- org-static-blog-page-postamble --></div>
</body>
</html>
