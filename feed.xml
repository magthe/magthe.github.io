<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title><![CDATA[Magnus web site]]></title>
<description><![CDATA[Magnus web site]]></description>
<link>https://magnus.therning.org/</link>
<lastBuildDate>Wed, 08 Dec 2021 07:11:15 +0100</lastBuildDate>
<item>
  <title><![CDATA[Magit/forge and self-hosted GitLab]]></title>
  <description><![CDATA[
<p>
As I found the documentation for adding a self-hosted instance of GitLab to to
magit/forge a bit difficult, I thought I'd write a note for my future self (and
anyone else who might find it useful).
</p>

<p>
First put the following in `~/.gitconfig`
</p>

<div class="org-src-container">
<pre class="src src-gitconfig">[<span class="org-type">gitlab</span> <span class="org-function-name">"gitlab.private.com/api/v4"</span>]
  <span class="org-variable-name">user</span> = my.username
</pre>
</div>

<p>
Then create an access token on GitLab. I ticked <code>api</code> and <code>write_repository</code>,
which seems to work fine so far. Put the token in <code>~/.authinfo.gpg</code>
</p>

<div class="org-src-container">
<pre class="src src-authinfo"><span class="org-variable-name">machine</span> <span class="org-builtin">gitlab.private.com/api/v4</span> <span class="org-comment-delimiter">login</span> <span class="org-keyword">my.user^forge</span> <span class="org-comment-delimiter">password</span> <span class="org-doc">&lt;token&gt;</span>
</pre>
</div>

<p>
(Remember that a newline is needed at the end of the file.)
</p>

<p>
Finally, add the GitLab instance to <code>'forge-alist</code>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">setq</span>
 forge-alist
 '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"gitlab.private.com"</span> <span class="org-string">"gitlab.private.com/api/v4"</span> <span class="org-string">"gitlab.private.com"</span> forge-gitlab-repository<span class="org-rainbow-delimiters-depth-3">)</span>
   <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"github.com"</span> <span class="org-string">"api.github.com"</span> <span class="org-string">"github.com"</span> forge-github-repository<span class="org-rainbow-delimiters-depth-3">)</span>
   <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"gitlab.com"</span> <span class="org-string">"gitlab.com/api/v4"</span> <span class="org-string">"gitlab.com"</span> forge-gitlab-repository<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
 <span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That's it!
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-git.html">git</a> <a href="https://magnus.therning.org/tag-magit.html">magit</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <category><![CDATA[git]]></category>
  <category><![CDATA[magit]]></category>
  <link>https://magnus.therning.org/2021-12-08-magit_forge-and-self-hosted-gitlab.html</link>
  <pubDate>Wed, 08 Dec 2021 06:57:00 +0100</pubDate>
</item>
<item>
  <title><![CDATA[Fallback of actions]]></title>
  <description><![CDATA[
<p>
In a tool I'm writing I want to load a file that may reside on the local disk,
but if it isn't there I want to fetch it from the web. Basically it's very
similar to having a cache and dealing with a miss, except in my case I don't
populate the cache.
</p>

<p>
Let me first define the functions to play with
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">loadFromDisk</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">loadFromDisk</span> k<span class="org-haskell-operator">@</span><span class="org-string">"bad key"</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"local: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
    pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Left</span> <span class="org-haskell-operator">$</span> <span class="org-string">"no such local key: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
<span class="org-haskell-definition">loadFromDisk</span> k <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"local: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
    pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">$</span> length k

<span class="org-haskell-definition">loadFromWeb</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">loadFromWeb</span> k<span class="org-haskell-operator">@</span><span class="org-string">"bad key"</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"web: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
    pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Left</span> <span class="org-haskell-operator">$</span> <span class="org-string">"no such remote key: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
<span class="org-haskell-definition">loadFromWeb</span> k <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    putStrLn <span class="org-haskell-operator">$</span> <span class="org-string">"web: "</span> <span class="org-haskell-operator">&lt;&gt;</span> k
    pure <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">$</span> length k
</pre>
</div>

<div id="outline-container-org79c5c1e" class="outline-2">
<h2 id="org79c5c1e">Discarded solution: using the <code>Alternative</code> of <code>IO</code> directly</h2>
<div class="outline-text-2" id="text-org79c5c1e">
<p>
It's fairly easy to get the desired behaviour but <code>Alternative</code> of <code>IO</code> is based
on exceptions which doesn't strike me as a good idea unless one is using <code>IO</code>
directly. That is fine in a smallish application, but in my case it makes sense
to use tagless style (or <code>ReaderT</code> pattern) so I'll skip exploring this option
completely.
</p>
</div>
</div>

<div id="outline-container-org74c8945" class="outline-2">
<h2 id="org74c8945">First attempt: lifting into the <code>Alternative</code> of <code>Either e</code></h2>
<div class="outline-text-2" id="text-org74c8945">
<p>
There's an instance of <code>Alternative</code> for <code>Either e</code> in version 0.5 of
<a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Error.html#section.orphans">transformers</a>. It's deprecated and it's gone in newer versions of the library as
one really should use <code>Except</code> or <code>ExceptT</code> instead. Even if I don't think it's
where I want to end up, it's not an altogether bad place to start.
</p>

<p>
Now let's define a function using <code>liftA2 (&lt;|&gt;)</code> to make it easy to see what the
behaviour is
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">::</span>
    <span class="org-haskell-type">Applicative</span> m <span class="org-haskell-operator">=&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> res<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">=</span> liftA2 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">&lt;|&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example" id="org1f6b3a0">
λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "good key"
local: bad key
web: good key
Right 8

λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "bad key"
local: bad key
web: bad key
Left "no such remote key: bad key"
</pre>

<p>
The first example shows that it falls back to loading form the web, and the
second one shows that it's only the last failure that survives. The latter part,
that only the last failure survives, isn't ideal but I think I can live with
that. If I were interested in collecting all failures I would reach for
<code>Validation</code> from <a href="https://hackage.haskell.org/package/validation-selective"><code>validation-selective</code></a> (there's one in <a href="https://hackage.haskell.org/package/validation-selective"><code>validation</code></a> that
should work too).
</p>

<p>
So far so good, but the next example shows a behaviour I don't want
</p>

<pre class="example" id="org005ead3">
λ&gt; loadFromDisk "good key" `fallBack` loadFromWeb "good key"
local: good key
web: good key
Right 8
</pre>

<p>
or to make it even more explicit
</p>

<pre class="example" id="orgf34f455">
λ&gt; loadFromDisk "good key" `fallBack` undefined
local: good key
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err
  undefined, called at &lt;interactive&gt;:451:36 in interactive:Ghci4
</pre>

<p>
There's no short-circuiting!<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<p>
The behaviour I want is of course that if the first action is successful, then
the second action shouldn't take place at all.
</p>

<p>
It looks like either <code>&lt;|&gt;</code> is strict in its second argument, or maybe it's
<code>liftA2</code> that forces it. I've not bothered digging into the details, it's enough
to observe it to realise that this approach isn't good enough.
</p>
</div>
</div>

<div id="outline-container-second-attempt" class="outline-2">
<h2 id="second-attempt">Second attempt: cutting it short, manually</h2>
<div class="outline-text-2" id="text-second-attempt">
<p>
Fixing the lack of short-circuiting the evaluation after the first success isn't
too difficult to do manually. Something like this does it
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">::</span>
    <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">String</span> a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">fallBack</span> first other <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    first <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
        r<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Right</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> pure r
        r<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Left</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>r <span class="org-haskell-operator">&lt;|&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;$&gt;</span> other
</pre>
</div>

<p>
It does indeed show the behaviour I want
</p>

<pre class="example" id="org0bc7069">
λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "good key"
local: bad key
web: good key
Right 8

λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "bad key"
local: bad key
web: bad key
Left "no such remote key: bad key"

λ&gt; loadFromDisk "good key" `fallBack` undefined
local: good key
Right 8
</pre>

<p>
Excellent! And to switch over to use <code>Validation</code> one just have to switch
constructors, <code>Right</code> becomes <code>Success</code> and <code>Left</code> becomes <code>Failure</code>. Though
collecting the failures by concatenating strings isn't the best idea of course.
Switching to some other <code>Monoid</code> (that's the constraint on the failure type)
isn't too difficult.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">::</span>
    <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Monad</span> m, <span class="org-haskell-type">Monoid</span> e<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Validation</span> e a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Validation</span> e a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Validation</span> e a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">fallBack</span> first other <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    first <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
        r<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Success</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> pure r
        r<span class="org-haskell-operator">@</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Failure</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>r <span class="org-haskell-operator">&lt;|&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;$&gt;</span> other
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbc3f08f" class="outline-2">
<h2 id="orgbc3f08f">Third attempt: pulling failures out to <code>MonadPlus</code></h2>
<div class="outline-text-2" id="text-orgbc3f08f">
<p>
After writing the <code>fallBack</code> function I still wanted to explore other solutions.
There's almost always something more out there in the Haskell eco system, right?
So I asked in the <i>#haskell-beginners</i> channel on the Functional Programming
Slack. The way I asked the question resulted in answers that iterates over a
list of actions and cutting at the first success.
</p>

<p>
The first suggestion had me a little confused at first, but once I re-organised
the helper function a little it made more sense to me.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mFromRight</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadPlus</span> m <span class="org-haskell-operator">=&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> m res
<span class="org-haskell-definition">mFromRight</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>either <span class="org-rainbow-delimiters-depth-2">(</span>const mzero<span class="org-rainbow-delimiters-depth-2">)</span> return <span class="org-haskell-operator">=&lt;&lt;</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
To use it put the actions in a list, map the helper above, and finally run
<code>asum</code> on it all<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>. I think it makes it a little clearer what happens if
it's rewritten like this.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">firstRightM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadPlus</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>m <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> m res
<span class="org-haskell-definition">firstRightM</span> <span class="org-haskell-operator">=</span> asum <span class="org-haskell-operator">.</span> fmap go
  <span class="org-haskell-keyword">where</span>
    go m <span class="org-haskell-operator">=</span> m <span class="org-haskell-operator">&gt;&gt;=</span> either <span class="org-rainbow-delimiters-depth-1">(</span>const mzero<span class="org-rainbow-delimiters-depth-1">)</span> return
</pre>
</div>

<pre class="example" id="org46be250">
λ&gt; firstRightM [loadFromDisk "bad key", loadFromWeb "good key"]
local: bad key
web: good key
8

λ&gt; firstRightM [loadFromDisk "good key", undefined]
local: good key
8
</pre>

<p>
So far so good, but I left out the case where both fail, because that's sort of
the fly in the ointment here
</p>

<pre class="example" id="orgdda08c7">
λ&gt; firstRightM [loadFromDisk "bad key", loadFromWeb "bad key"]
local: bad key
web: bad key
*** Exception: user error (mzero)
</pre>

<p>
It's not nice to be back to deal with exceptions, but it's possible to recover,
e.g. by appending <code>&lt;|&gt; pure 0</code>.
</p>

<pre class="example" id="org3555519">
λ&gt; firstRightM [loadFromDisk "bad key", loadFromWeb "bad key"] &lt;|&gt; pure 0
local: bad key
web: bad key
0
</pre>

<p>
However that removes the ability to deal with the situation where all actions
fail. Not nice! Add to that the difficulty of coming up with a <i>good</i>
<code>MonadPlus</code> instance for an application monad; one basically have to resort to
the same thing as for <code>IO</code>, i.e. to throw an exception. Also not nice!
</p>
</div>
</div>

<div id="outline-container-fourth-attempt" class="outline-2">
<h2 id="fourth-attempt">Fourth attempt: wrapping in <code>ExceptT</code> to get its <code>Alternative</code> behaviour</h2>
<div class="outline-text-2" id="text-fourth-attempt">
<p>
This was another suggestion from the Slack channel, and it is the one I like the
most. Again it was suggested as a way to stop at the first successful action in
a list of actions.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">firstRightM</span> <span class="org-haskell-operator">::</span>
    <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Foldable</span> t, <span class="org-haskell-type">Functor</span> t, <span class="org-haskell-type">Monad</span> m, <span class="org-haskell-type">Monoid</span> err<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span>
    t <span class="org-rainbow-delimiters-depth-1">(</span>m <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">firstRightM</span> <span class="org-haskell-operator">=</span> runExceptT <span class="org-haskell-operator">.</span> asum <span class="org-haskell-operator">.</span> fmap <span class="org-haskell-constructor">ExceptT</span>
</pre>
</div>

<p>
Which can be used similarly to the previous one. It's also easy to write a
variant of <code>fallBack</code> for it.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">fallBack</span> <span class="org-haskell-operator">::</span>
    <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Monad</span> m, <span class="org-haskell-type">Monoid</span> err<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span>
    m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> err res<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">fallBack</span> first other <span class="org-haskell-operator">=</span> runExceptT <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">ExceptT</span> first <span class="org-haskell-operator">&lt;|&gt;</span> <span class="org-haskell-constructor">ExceptT</span> other
</pre>
</div>

<pre class="example" id="org2366803">
λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "good key"
local: bad key
web: good key
Right 8

λ&gt; loadFromDisk "good key" `fallBack` undefined
local: good key
Right 8

λ&gt; loadFromDisk "bad key" `fallBack` loadFromWeb "bad key"
local: bad key
web: bad key
Left "no such local key: bad keyno such remote key: bad key"
</pre>

<p>
Yay! This solution has the short-circuiting behaviour I want, as well as
collecting all errors on failure.
</p>
</div>
</div>

<div id="outline-container-orgc7c8216" class="outline-2">
<h2 id="orgc7c8216">Conclusion</h2>
<div class="outline-text-2" id="text-orgc7c8216">
<p>
I'm still a little disappointed that <code>liftA2 (&lt;|&gt;)</code> isn't short-circuiting as I
still think it's the easiest of the approaches. However, it's a problem that one
has to rely on a deprecated instance of <code>Alternative</code> for <code>Either String</code>,
but switching to use <code>Validation</code> would be only a minor change.
</p>

<p>
Manually writing the <code>fallBack</code> function, as I did in the <a href="#second-attempt">second attempt</a>,
results in very explicit code which is nice as it often reduces the cognitive
load for the reader. It's a contender, but using the deprecated <code>Alternative</code>
instance is problematic and introducing <code>Validition</code>, an arguably not very
common type, takes away a little of the appeal.
</p>

<p>
In the end I prefer the <a href="#fourth-attempt">fourth attempt</a>. It behaves exactly like I want and even
though <code>ExpectT</code> lives in <i>transformers</i> I feel that it (I pull it in via <i>mtl</i>)
is in such wide use that most Haskell programmers will be familiar with it.
</p>

<p>
One final thing to add is that the <a href="https://hackage.haskell.org/package/validation-selective-0.1.0.1/docs/Validation.html">documentation of <code>Validation</code></a> is an excellent
inspiration when it comes to the behaviour of its instances. I wish that the
documentation of other packages, in particular commonly used ones like <i>base</i>,
<i>transformers</i>, and <i>mtl</i>, would be more like it.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I'm not sure if it's a good term to use in this case as <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">Wikipedia</a> says
it's for Boolean operators. I hope it's not too far a stretch to use it in this
context too.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
In the version of <i>base</i> I'm using there is no <code>asum</code>, so I simply copied
the implementation from a later version:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">asum</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Foldable</span> t, <span class="org-haskell-type">Alternative</span> f<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> t <span class="org-rainbow-delimiters-depth-1">(</span>f a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> f a
<span class="org-haskell-definition">asum</span> <span class="org-haskell-operator">=</span> foldr <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">&lt;|&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> empty
</pre>
</div></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-alternative_typeclass.html">alternative_typeclass</a> <a href="https://magnus.therning.org/tag-caching.html">caching</a> <a href="https://magnus.therning.org/tag-fallback.html">fallback</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>]]></description>
  <category><![CDATA[alternative_typeclass]]></category>
  <category><![CDATA[caching]]></category>
  <category><![CDATA[fallback]]></category>
  <category><![CDATA[haskell]]></category>
  <link>https://magnus.therning.org/2021-11-27-fallback-of-actions.html</link>
  <pubDate>Sat, 27 Nov 2021 11:31:00 +0100</pubDate>
</item>
<item>
  <title><![CDATA[Using lens to set a value based on another]]></title>
  <description><![CDATA[
<p>
I started writing a small tool for work that consumes YAML files and combines
the data into a single YAML file. To be specific it consumes YAML files
containing snippets of service specification for <a href="https://docs.docker.com/compose/">Docker Compose</a> and it produces
a YAML file for use with <code>docker-compose</code>. Besides being useful to me, I thought
it'd also be a good way to get some experience with <a href="https://hackage.haskell.org/package/lens">lens</a>.
</p>

<p>
The first transformation I wanted to write was one that puts in the correct
image name. So, only slightly simplified, it is transforming
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span class="org-variable-name">panda</span>:
    <span class="org-variable-name">x-image</span>: panda
<span class="org-variable-name">goat</span>:
    <span class="org-variable-name">x-image</span>: goat
<span class="org-variable-name">tapir</span>:
    <span class="org-variable-name">image</span>: incorrent
    <span class="org-variable-name">x-image</span>: tapir
</pre>
</div>

<p>
into
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span class="org-variable-name">panda</span>:
    <span class="org-variable-name">image</span>: panda:latest
    <span class="org-variable-name">x-image</span>: panda
<span class="org-variable-name">goat</span>:
    <span class="org-variable-name">image</span>: goat:latest
    <span class="org-variable-name">x-image</span>: goat
<span class="org-variable-name">tapir</span>:
    <span class="org-variable-name">image</span>: tapir:latest
    <span class="org-variable-name">x-image</span>: tapir
</pre>
</div>

<p>
That is, it creates a new key/value pair in each object based on the value of
<code>x-image</code> in the same object.
</p>

<div id="outline-container-org3bb936a" class="outline-2">
<h2 id="org3bb936a">First approach</h2>
<div class="outline-text-2" id="text-org3bb936a">
<p>
The first approach I came up with was to traverse the sub-objects and apply a
function that adds the <code>image</code> key.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">setImage</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">setImage</span> y <span class="org-haskell-operator">=</span> y <span class="org-haskell-operator">&amp;</span> members <span class="org-haskell-operator">%~</span> setImg
  <span class="org-haskell-keyword">where</span>
    setImg o <span class="org-haskell-operator">=</span>
        o
            <span class="org-haskell-operator">&amp;</span> _Object <span class="org-haskell-operator">.</span> at <span class="org-string">"image"</span>
            <span class="org-haskell-operator">?~</span> <span class="org-haskell-constructor">String</span> <span class="org-rainbow-delimiters-depth-1">(</span>o <span class="org-haskell-operator">^.</span> key <span class="org-string">"x-image"</span> <span class="org-haskell-operator">.</span> _String <span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">":latest"</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
It did make me wonder if this kind of problem, setting a value based on another
value, isn't so common that there's a nicer solution to it. Perhaps coded up in
a combinator that isn't mentioned in <a href="https://leanpub.com/optics-by-example">Optics By Example</a> (or mabye I've forgot it
was mentioned). That lead me to ask around a bit, which leads to approach two.
</p>
</div>
</div>

<div id="outline-container-orgf55f462" class="outline-2">
<h2 id="orgf55f462">Second approach</h2>
<div class="outline-text-2" id="text-orgf55f462">
<p>
Arguably there isn't much difference, it's still traversing the sub-objects and
applying a function. The function makes use of <code>view</code> being run in a monad and
<code>ASetter</code> being defined with <code>Identity</code> (a monad).
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">setImage'</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">setImage'</span> y <span class="org-haskell-operator">=</span>
    y
        <span class="org-haskell-operator">&amp;</span> members <span class="org-haskell-operator">.</span> _Object
        <span class="org-haskell-operator">%~</span> <span class="org-rainbow-delimiters-depth-1">(</span>set <span class="org-rainbow-delimiters-depth-2">(</span>at <span class="org-string">"image"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">.</span> <span class="org-rainbow-delimiters-depth-2">(</span>_Just <span class="org-haskell-operator">.</span> _String <span class="org-haskell-operator">%~</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">":latest"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&lt;&lt;</span> view <span class="org-rainbow-delimiters-depth-2">(</span>at <span class="org-string">"x-image"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I haven't made up my mind on whether I like this better than the first. It's
disappointingly similar to the first one.
</p>
</div>
</div>

<div id="outline-container-orge880fe2" class="outline-2">
<h2 id="orge880fe2">Third approach</h2>
<div class="outline-text-2" id="text-orge880fe2">
<p>
Then I it might be nice to split the fetching of <code>x-image</code> values from the
addition of <code>image</code> key/value pairs. By extracting with an index it's possible
to keep track of what sub-object each <code>x-image</code> value comes from. Then two steps
can be combined using <code>foldl</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">setImage''</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">setImage''</span> y <span class="org-haskell-operator">=</span> foldl setOne y vals
  <span class="org-haskell-keyword">where</span>
    vals <span class="org-haskell-operator">=</span> y <span class="org-haskell-operator">^@..</span> members <span class="org-haskell-operator">&lt;.</span> key <span class="org-string">"x-image"</span> <span class="org-haskell-operator">.</span> _String
    setOne y' <span class="org-rainbow-delimiters-depth-1">(</span>objKey, value<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span>
        y'
            <span class="org-haskell-operator">&amp;</span> key objKey <span class="org-haskell-operator">.</span> _Object <span class="org-haskell-operator">.</span> at <span class="org-string">"image"</span>
            <span class="org-haskell-operator">?~</span> <span class="org-haskell-constructor">String</span> <span class="org-rainbow-delimiters-depth-1">(</span>value <span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">":latest"</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I'm not convinced though. I guess I'm still holding out for a brilliant
combinator that fits my problem perfectly.
</p>

<p>
Please point me to "the perfect solution" if you have one, or if you just have
some general tips on optics that would make my code clearer, or shorter, or more
elegant, or maybe just more lens-y.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-lens.html">lens</a> <a href="https://magnus.therning.org/tag-optics.html">optics</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[lens]]></category>
  <category><![CDATA[optics]]></category>
  <link>https://magnus.therning.org/2021-09-28-using-lens-to-set-a-value-based-on-another.html</link>
  <pubDate>Tue, 28 Sep 2021 13:21:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[Keeping todo items in org-roam v2]]></title>
  <description><![CDATA[
<p>
Org-roam v2 has been <a href="https://blog.jethro.dev/posts/org_roam_v2/">released</a> and yes, it broke my config a bit. Unfortunately
the v1-to-v2 upgrade wizard didn't work for me. I realized later that it might
have been due to the roam-related functions I'd hooked into `'before-save-hook`.
I didn't think about it until I'd already manually touched up almost all my
files (there aren't that many) so I can't say anything for sure. However, I
think it might be a good idea to keep hooks in mind if one runs into issues with
upgrading.
</p>

<p>
The majority of the time I didn't spend on my notes though, but on the setup
I've written about in an earlier post, <a href="https://magnus.therning.org/2021-03-14-keeping-todo-items-in-org-roam.html">Keeping todo items in org-roam</a>. Due to
some of the changes in v2, changes that I think make org-roam slightly more
"org-y", that setup needed a bit of love.
</p>

<p>
The basis is still the same 4 functions I described in that post, only the
details had to be changed.
</p>

<p>
I hope the following is useful, and as always I'm always happy to receive
commends and suggestions for improvements.
</p>

<div id="outline-container-org2ca70ee" class="outline-2">
<h2 id="org2ca70ee">Some tag helpers</h2>
<div class="outline-text-2" id="text-org2ca70ee">
<p>
The very handy functions for extracting tags as lists seem to be gone, in their
place I found <code>org-roam-{get,set}-keyword</code>. Using these I wrote three wrappers
that allow slightly nicer handling of tags.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:get-filetags</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>split-string <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">or</span> <span class="org-rainbow-delimiters-depth-4">(</span>org-roam-get-keyword <span class="org-string">"filetags"</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:add-filetag</span> <span class="org-rainbow-delimiters-depth-2">(</span>tag<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let*</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>new-tags <span class="org-rainbow-delimiters-depth-5">(</span>cons tag <span class="org-rainbow-delimiters-depth-6">(</span>roam-extra:get-filetags<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>new-tags-str <span class="org-rainbow-delimiters-depth-5">(</span>combine-and-quote-strings new-tags<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>org-roam-set-keyword <span class="org-string">"filetags"</span> new-tags-str<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:del-filetag</span> <span class="org-rainbow-delimiters-depth-2">(</span>tag<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let*</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>new-tags <span class="org-rainbow-delimiters-depth-5">(</span>seq-difference <span class="org-rainbow-delimiters-depth-6">(</span>roam-extra:get-filetags<span class="org-rainbow-delimiters-depth-6">)</span> `<span class="org-rainbow-delimiters-depth-6">(</span>,tag<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>new-tags-str <span class="org-rainbow-delimiters-depth-5">(</span>combine-and-quote-strings new-tags<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>org-roam-set-keyword <span class="org-string">"filetags"</span> new-tags-str<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc4e90df" class="outline-2">
<h2 id="orgc4e90df">The layer</h2>
<div class="outline-text-2" id="text-orgc4e90df">
<p>
<code>roam-extra:todo-p</code> needed no changes at all. I'm including it here only for
easy reference.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:todo-p</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Return non-nil if current buffer has any </span><span class="org-doc"><span class="custom">TODO</span></span><span class="org-doc"> entry.</span>

<span class="org-doc"><span class="custom">TODO</span></span><span class="org-doc"> entries marked as done are ignored, meaning the this</span>
<span class="org-doc">function returns nil if current buffer contains only completed</span>
<span class="org-doc">tasks."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>org-element-map
      <span class="org-rainbow-delimiters-depth-3">(</span>org-element-parse-buffer 'headline<span class="org-rainbow-delimiters-depth-3">)</span>
      'headline
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>h<span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">(</span>eq <span class="org-rainbow-delimiters-depth-5">(</span>org-element-property <span class="org-builtin">:todo-type</span> h<span class="org-rainbow-delimiters-depth-5">)</span>
          'todo<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    nil 'first-match<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
As pretty much all functions I used in the old version of
<code>roam-extra:update-todo-tag</code> are gone I took the opportunity to rework it
completely. I think it ended up being slightly simpler. I suspect the the use of
<code>org-with-point-at 1 ...</code> is unnecessary, but I haven't tested it yet so I'm
leaving it in for now.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:update-todo-tag</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Update </span><span class="org-doc"><span class="custom">TODO</span></span><span class="org-doc"> tag in the current buffer."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">and</span> <span class="org-rainbow-delimiters-depth-4">(</span>not <span class="org-rainbow-delimiters-depth-5">(</span>active-minibuffer-window<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
             <span class="org-rainbow-delimiters-depth-4">(</span>org-roam-file-p<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">org-with-point-at</span> <span class="org-highlight-numbers-number">1</span>
      <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">let*</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-rainbow-delimiters-depth-6">(</span>tags <span class="org-rainbow-delimiters-depth-7">(</span>roam-extra:get-filetags<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
             <span class="org-rainbow-delimiters-depth-6">(</span>is-todo <span class="org-rainbow-delimiters-depth-7">(</span>roam-extra:todo-p<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">cond</span> <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-rainbow-delimiters-depth-7">(</span><span class="org-keyword">and</span> is-todo <span class="org-rainbow-delimiters-depth-8">(</span>not <span class="org-rainbow-delimiters-depth-9">(</span>seq-contains-p tags <span class="org-string">"</span><span class="org-string"><span class="custom">todo</span></span><span class="org-string">"</span><span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span>
               <span class="org-rainbow-delimiters-depth-7">(</span>roam-extra:add-filetag <span class="org-string">"</span><span class="org-string"><span class="custom">todo</span></span><span class="org-string">"</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
              <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-rainbow-delimiters-depth-7">(</span><span class="org-keyword">and</span> <span class="org-rainbow-delimiters-depth-8">(</span>not is-todo<span class="org-rainbow-delimiters-depth-8">)</span> <span class="org-rainbow-delimiters-depth-8">(</span>seq-contains-p tags <span class="org-string">"</span><span class="org-string"><span class="custom">todo</span></span><span class="org-string">"</span><span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span>
               <span class="org-rainbow-delimiters-depth-7">(</span>roam-extra:del-filetag <span class="org-string">"</span><span class="org-string"><span class="custom">todo</span></span><span class="org-string">"</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
In the previous version <code>roam-extra:todo-files</code> was built using an SQL query.
That felt a little brittle to me, so despite that my <a href="https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html">original inspiration</a>
contains an updated SQL query I decided to go the route of using the org-roam
API instead. The function <code>org-roam-node-list</code> makes it easy to get all nodes
and then finding the files is just a matter of using <code>seq-filter</code> and <code>seq-map</code>.
Now that headings may be nodes, and that heading-based nodes seem to inherit the
top-level tags, a file may appear more than once, hence the call to <code>seq-unique</code>
at the end.
</p>

<p>
Based on what I've seen V2 appears less eager to sync the DB, so to make sure
all nodes are up-to-date it's best to start off with forcing a sync.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:todo-files</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Return a list of roam files containing </span><span class="org-doc"><span class="custom">todo</span></span><span class="org-doc"> tag."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>org-roam-db-sync<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>todo-nodes <span class="org-rainbow-delimiters-depth-5">(</span>seq-filter <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-7">(</span>n<span class="org-rainbow-delimiters-depth-7">)</span>
                                  <span class="org-rainbow-delimiters-depth-7">(</span>seq-contains-p <span class="org-rainbow-delimiters-depth-8">(</span>org-roam-node-tags n<span class="org-rainbow-delimiters-depth-8">)</span> <span class="org-string">"</span><span class="org-string"><span class="custom">todo</span></span><span class="org-string">"</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
                                 <span class="org-rainbow-delimiters-depth-6">(</span>org-roam-node-list<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>seq-uniq <span class="org-rainbow-delimiters-depth-4">(</span>seq-map #'org-roam-node-file todo-nodes<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
With that in place it turns out that also <code>roam-extra:update-todo-files</code> worked
without any changes. I'm including it here for easy reference as well.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:update-todo-files</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">&amp;rest</span> _<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Update the value of `</span><span class="org-doc"><span class="org-constant">org-agenda-files</span></span><span class="org-doc">'."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq</span> org-agenda-files <span class="org-rainbow-delimiters-depth-3">(</span>roam-extra:todo-files<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org317e364" class="outline-2">
<h2 id="org317e364">Hooking it up</h2>
<div class="outline-text-2" id="text-org317e364">
<p>
The variable <code>org-roam-file-setup-hook</code> is gone, so the the more general
<code>find-file-hook</code> will have to be used instead.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>add-hook 'find-file-hook #'roam-extra:update-todo-tag<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span>add-hook 'before-save-hook #'roam-extra:update-todo-tag<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span>advice-add 'org-agenda <span class="org-builtin">:before</span> #'roam-extra:update-todo-files<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-org-mode.html">org-mode</a> <a href="https://magnus.therning.org/tag-org-roam.html">org-roam</a> <a href="https://magnus.therning.org/tag-spacemacs.html">spacemacs</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <category><![CDATA[org-mode]]></category>
  <category><![CDATA[org-roam]]></category>
  <category><![CDATA[spacemacs]]></category>
  <link>https://magnus.therning.org/2021-07-23-keeping-todo-items-in-org-roam-v2.html</link>
  <pubDate>Fri, 23 Jul 2021 15:07:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[The timeout manager exception]]></title>
  <description><![CDATA[
<p>
The other day I bumped the dependencies of a Haskell project at work and noticed
a new exception being thrown:
</p>

<blockquote>
<p>
Thread killed by timeout manager
</p>
</blockquote>

<p>
After a couple of false starts (it wasn't the <a href="https://hackage.haskell.org/package/resource-pool">connection pool</a>, nor was it
<a href="https://hackage.haskell.org/package/servant">servant</a>) I realised that a better approach would be to look at the list of
packages that were updated as part of the dependency bumping.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> Most of them
I thought would be <span class="underline">very</span> unlikely sources of it, but two in the list stood out:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Package</th>
<th scope="col" class="org-right">Pre</th>
<th scope="col" class="org-right">Post</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="https://hackage.haskell.org/package/unliftio">unliftio</a></td>
<td class="org-right">0.2.14</td>
<td class="org-right">0.2.18</td>
</tr>

<tr>
<td class="org-left"><a href="https://hackage.haskell.org/package/warp">warp</a></td>
<td class="org-right">3.3.15</td>
<td class="org-right">3.3.16</td>
</tr>
</tbody>
</table>

<p>
<code>warp</code> since the exception seemed to be thrown shortly after handling an HTTP
request, and <code>unliftio</code> since the exception was caught by the handler for
uncaught exceptions and its description contains "thread". Also, when looking at
the code changes in <code>warp</code> on GitHub<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> I found that some of the changes
introduced was increased use of <code>unliftio</code> for async stuff. The changes contain
mentions of <code>TimeoutThread</code> and <code>System.TimeManager</code>. That sounded promising,
and it lead me to the <a href="https://hackage.haskell.org/package/time-manager-0.0.0/docs/System-TimeManager.html#t:TimeoutThread">TimeoutThread</a> exception in <a href="https://hackage.haskell.org/package/time-manager">time-manager</a>.
</p>

<p>
With that knowledge I could quickly adjust the handler for uncaught exceptions
to not log <code>TimeoutThread</code> as fatal:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">lastExceptionHandler</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">SomeException</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">lastExceptionHandler</span> logger e
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-constructor">TimeoutThread</span> <span class="org-haskell-operator">&lt;-</span> fromException e <span class="org-haskell-operator">=</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
  <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      logFatalIoS logger <span class="org-haskell-operator">$</span> pack <span class="org-haskell-operator">$</span> <span class="org-string">"uncaught exception: "</span> <span class="org-haskell-operator">&lt;&gt;</span> displayException e
      flushLogStr logger
</pre>
</div>

<p>
I have to say it was a bit more work to arrive at this than I'd have liked. I
reckon there are easier ways to track down the information I needed. So I'd love
to hear what tricks and tips others have.
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
As a bonus it gave me a good reason to reach for <a href="https://man7.org/linux/man-pages/man1/comm.1.html"><code>comm</code></a>, a command that I
rarely use but for some reason always enjoy.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
GitHub's compare feature isn't very easy to discover, but a URL like this
<a href="https://github.com/yesodweb/wai/compare/warp-3.3.15...warp-3.3.16">https://github.com/yesodweb/wai/compare/warp-3.3.15&#x2026;warp-3.3.16</a> (note the 3
dots!) does the trick.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-warp.html">warp</a> <a href="https://magnus.therning.org/tag-servant.html">servant</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[warp]]></category>
  <category><![CDATA[servant]]></category>
  <link>https://magnus.therning.org/2021-07-03-the-timeout-manager-exception.html</link>
  <pubDate>Sat, 03 Jul 2021 13:52:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[A first look at HMock]]></title>
  <description><![CDATA[
<p>
The other day I found Chris Smith's <a href="https://itnext.io/hmock-first-rate-mocks-in-haskell-e59d7c3b066c">HMock: First Rate Mocks in Haskell</a> (<a href="https://hackage.haskell.org/package/HMock">link to
hackage</a>) and thought it could be nice see if it can clear up some of the tests I
have in a few of the Haskell projects at work. All the projects follow the
pattern of defining custom monads for effects (something like final tagless)
with instances implemented on a stack of monads from MTL. It's a pretty standard
thing in Haskell I'd say, especially since the monad stack very often ends up
being <code>ReaderT MyConfig IO</code>.
</p>

<p>
I decided to try it first on a single such custom monad, one for making HTTP
requests:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadHttpClient</span> m <span class="org-haskell-keyword">where</span>
  mHttpGet <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Status</span>, <span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span>
  mHttpPost <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Typeable</span> a, <span class="org-haskell-type">Postable</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Status</span>, <span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Yes, the underlying implementation uses <a href="https://hackage.haskell.org/package/wreq">wreq</a>, but I'm not too bothered by that
shining through. Also, initially I didn't have that <code>Typeable a</code> constraint on
<code>mHttpPost</code>, it got added after a short <a href="https://github.com/cdsmith/HMock/issues/1">exchange about <code>KnownSymbol</code></a> with Chris.
</p>

<p>
To dip a toe in the water I thought I'd simply write tests for the two effects
themselves. First of all there's an impressive list of extensions needed, and
then the monad needs to be made mockable:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE DataKinds #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE GADTs #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE ImportQualifiedPost #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE RankNTypes #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeApplications #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeFamilies #-}</span>

<span class="org-haskell-definition">makeMockable</span> ''<span class="org-haskell-constructor">MonadHttpClient</span>
</pre>
</div>

<p>
After that, writing a test with HMock for <code>mHttpGet</code> was fairly straight
forward, I could simply follow the examples in the package's documentation. I'm
using <a href="https://hackage.haskell.org/package/tasty">tasty</a> for organising the tests though:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">httpGetTest</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">TestTree</span>
<span class="org-haskell-definition">httpGetTest</span> <span class="org-haskell-operator">=</span> testCase <span class="org-string">"Get"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  <span class="org-rainbow-delimiters-depth-1">(</span>s, b<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> runMockT <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    expect <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MHttpGet</span> <span class="org-string">"url"</span> <span class="org-haskell-operator">|-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>status200, <span class="org-string">"result"</span><span class="org-rainbow-delimiters-depth-1">)</span>
    mHttpGet <span class="org-string">"url"</span>
  status200 <span class="org-haskell-operator">@=?</span> s
  <span class="org-string">"result"</span> <span class="org-haskell-operator">@=?</span> b
</pre>
</div>

<p>
The effect for sending a <code>POST</code> request was slightly trickier, as can be seen in
the issue linked above, but with some help I came up with the following:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">httpPostTest</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">TestTree</span>
<span class="org-haskell-definition">httpPostTest</span> <span class="org-haskell-operator">=</span> testCase <span class="org-string">"Post"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  <span class="org-rainbow-delimiters-depth-1">(</span>s, b<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> runMockT <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    expect <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MHttpPost_</span> <span class="org-rainbow-delimiters-depth-1">(</span>eq <span class="org-string">"url"</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>typed <span class="org-haskell-operator">@</span><span class="org-haskell-constructor">ByteString</span> anything<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">|-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>status201, <span class="org-string">"result"</span><span class="org-rainbow-delimiters-depth-1">)</span>
    mHttpPost <span class="org-string">"url"</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span>
  status201 <span class="org-haskell-operator">@=?</span> s
  <span class="org-string">"result"</span> <span class="org-haskell-operator">@=?</span> b
</pre>
</div>

<div id="outline-container-org07a2709" class="outline-2">
<h2 id="org07a2709">Next step</h2>
<div class="outline-text-2" id="text-org07a2709">
<p>
My hope is that using HMock will remove the need for creating a bunch of test
implementations for the various custom monads for effects<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> in the projects,
thereby reducing the amount of test code overall. I also suspect that it will
make the tests clearer and easier to read, as the behaviour of the mocks are
closer to the tests using the mocks.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Basically they could be looked at as hand-written mocks.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> <a href="https://magnus.therning.org/tag-mocks.html">mocks</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[testing]]></category>
  <category><![CDATA[mocks]]></category>
  <link>https://magnus.therning.org/2021-06-27-a-first-look-at-hmock.html</link>
  <pubDate>Sun, 27 Jun 2021 23:14:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[ZSH, Nix, and completions]]></title>
  <description><![CDATA[
<p>
TIL that <a href="https://www.zsh.org/">ZSH</a> completions that come with Nix packages end up in
<code>~/.nix-profile/share/zsh/vendor-completions/</code> and that folder <i>is not</i> added to
<code>$FPATH</code> by the init script that comes with Nix.
</p>

<p>
After modifying the bit in <code>~/.zshenv</code> it now looks like this
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">[</span> -f ~/.nix-profile/etc/profile.d/nix.sh <span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>; <span class="org-keyword">then</span>
    <span class="org-builtin">source</span> ~/.nix-profile/etc/profile.d/nix.sh
    <span class="org-builtin">export</span> <span class="org-variable-name">fpath</span>=<span class="org-rainbow-delimiters-depth-1">(</span>~/.nix-profile/share/zsh/vendor-completions $<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-variable-name">fpath</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-keyword">fi</span>
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-nix.html">nix</a> <a href="https://magnus.therning.org/tag-zsh.html">zsh</a> </div>]]></description>
  <category><![CDATA[nix]]></category>
  <category><![CDATA[zsh]]></category>
  <link>https://magnus.therning.org/2021-06-06-zsh,-nix,-and-completions.html</link>
  <pubDate>Sun, 06 Jun 2021 11:36:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[Working with Hedis]]></title>
  <description><![CDATA[
<p>
I'm now writing the second Haskell service using <a href="https://redis.io/commands/incrby">Redis</a> to store data. There are
a few packages on <a href="https://hackage.haskell.org/">Hackage</a> related to Redis but I only found 2 client libraries,
<a href="https://hackage.haskell.org/package/redis-io">redis-io</a> and <a href="https://hackage.haskell.org/package/hedis">hedis</a>. I must say I like the API of redis-io better, but it breaks
a rule I hold very dear:
</p>

<blockquote>
<p>
Libraries should never log, that's the responsibility of the application.
</p>
</blockquote>

<p>
So, hedis it is. I tried using the API as is, but found it really cumbersome so
looked around and after some inspiration from <a href="https://hackage.haskell.org/package/hedis-simple">hedis-simple</a> I came up with the
following functions.
</p>

<p>
First a wrapper around a Redis function that put everything into <code>ExceptionT</code>
with a function that transforms a <code>reply</code> into an <code>Exception</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">lpush</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Exception</span> e <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Reply</span> <span class="org-haskell-operator">-&gt;</span> e<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ExceptionT</span> <span class="org-haskell-type">Redis</span> <span class="org-haskell-type">Integer</span>
<span class="org-haskell-definition">lpush</span> mapper key element <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ExceptionT</span> <span class="org-haskell-operator">$</span> replyToExc <span class="org-haskell-operator">&lt;$&gt;</span> R.lpush key element
  <span class="org-haskell-keyword">where</span>
    replyToExc <span class="org-haskell-operator">=</span> first <span class="org-rainbow-delimiters-depth-1">(</span>toException <span class="org-haskell-operator">.</span> mapper<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I found wrapping up functions like this is simple, but repetitive.
</p>

<p>
Finally I need a way to run the whole thing and unwrap it all back to <code>IO</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">runRedis</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Connection</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ExceptionT</span> <span class="org-haskell-type">Redis</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">SomeException</span> a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">runRedis</span> conn <span class="org-haskell-operator">=</span> R.runRedis conn <span class="org-haskell-operator">.</span> runExceptionT
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-redis.html">redis</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[redis]]></category>
  <link>https://magnus.therning.org/2021-05-07-working-with-hedis.html</link>
  <pubDate>Fri, 07 May 2021 20:54:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[First contribution to nixpkgs.haskellPackages]]></title>
  <description><![CDATA[
<p>
Nothing much to be proud of, but yesterday I found out that <a href="https://hackage.haskell.org/package/servant-docs">servant-docs</a> was
marked broken in <span class="underline">nixpkgs</span> even though it builds just fine and this morning I
decided to do something about it.
</p>

<p>
So, with the help of a <a href="https://discourse.nixos.org/t/call-to-action-for-updating-haskell-packages-after-bump-to-lts-15/6071">post on the NixOS discourse</a> I put together my first <a href="https://github.com/NixOS/nixpkgs/pull/120026">PR</a>.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-nix.html">nix</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>]]></description>
  <category><![CDATA[nix]]></category>
  <category><![CDATA[haskell]]></category>
  <link>https://magnus.therning.org/2021-04-21-first-contribution-to-nixpkgs.haskellpackages.html</link>
  <pubDate>Wed, 21 Apr 2021 22:46:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[Nix shell, direnv and XDG_DATA_DIRS]]></title>
  <description><![CDATA[
<p>
A few weeks ago I noticed that I no longer could use
<code>haskell-hoogle-lookup-from-website</code> in Emacs. After a bit of experimentation I
found that the reason was that I couldn't use <code>xdg-open</code> in a Nix shell.
Yesterday I finally got around to look into further.
</p>

<p>
It's caused by <code>direnv</code> overwriting <code>XDG_DATA_DIRS</code> rather than appending to it.
Of course someone already reported <a href="https://github.com/direnv/direnv/issues/785">a bug</a> already.
</p>

<p>
The workaround is to use
</p>

<div class="org-src-container">
<pre class="src src-shell">use nix --keep XDG_DATA_DIRS
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-nix.html">nix</a> <a href="https://magnus.therning.org/tag-direnv.html">direnv</a> </div>]]></description>
  <category><![CDATA[nix]]></category>
  <category><![CDATA[direnv]]></category>
  <link>https://magnus.therning.org/2021-04-13-nix-shell,-direnv-and-xdg_data_dirs.html</link>
  <pubDate>Tue, 13 Apr 2021 08:04:00 +0200</pubDate>
</item>
</channel>
</rss>
