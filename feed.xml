<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title><![CDATA[Magnus web site]]></title>
<description><![CDATA[Magnus web site]]></description>
<link>https://magnus.therning.org/</link>
<lastBuildDate>Tue, 28 Sep 2021 14:50:11 +0200</lastBuildDate>
<item>
  <title><![CDATA[Using lens to set a value based on another]]></title>
  <description><![CDATA[
<p>
I started writing a small tool for work that consumes YAML files and combines
the data into a single YAML file. To be specific it consumes YAML files
containing snippets of service specification for <a href="https://docs.docker.com/compose/">Docker Compose</a> and it produces
a YAML file for use with <code>docker-compose</code>. Besides being useful to me, I thought
it'd also be a good way to get some experience with <a href="https://hackage.haskell.org/package/lens">lens</a>.
</p>

<p>
The first transformation I wanted to write was one that puts in the correct
image name. So, only slightly simplified, it is transforming
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span class="org-variable-name">panda</span>:
    <span class="org-variable-name">x-image</span>: panda
<span class="org-variable-name">goat</span>:
    <span class="org-variable-name">x-image</span>: goat
<span class="org-variable-name">tapir</span>:
    <span class="org-variable-name">image</span>: incorrent
    <span class="org-variable-name">x-image</span>: tapir
</pre>
</div>

<p>
into
</p>

<div class="org-src-container">
<pre class="src src-yaml"><span class="org-variable-name">panda</span>:
    <span class="org-variable-name">image</span>: panda:latest
    <span class="org-variable-name">x-image</span>: panda
<span class="org-variable-name">goat</span>:
    <span class="org-variable-name">image</span>: goat:latest
    <span class="org-variable-name">x-image</span>: goat
<span class="org-variable-name">tapir</span>:
    <span class="org-variable-name">image</span>: tapir:latest
    <span class="org-variable-name">x-image</span>: tapir
</pre>
</div>

<p>
That is, it creates a new key/value pair in each object based on the value of
<code>x-image</code> in the same object.
</p>

<div id="outline-container-org3bb936a" class="outline-2">
<h2 id="org3bb936a">First approach</h2>
<div class="outline-text-2" id="text-org3bb936a">
<p>
The first approach I came up with was to traverse the sub-objects and apply a
function that adds the <code>image</code> key.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">setImage</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">setImage</span> y <span class="org-haskell-operator">=</span> y <span class="org-haskell-operator">&amp;</span> members <span class="org-haskell-operator">%~</span> setImg
  <span class="org-haskell-keyword">where</span>
    setImg o <span class="org-haskell-operator">=</span>
        o
            <span class="org-haskell-operator">&amp;</span> _Object <span class="org-haskell-operator">.</span> at <span class="org-string">"image"</span>
            <span class="org-haskell-operator">?~</span> <span class="org-haskell-constructor">String</span> <span class="org-rainbow-delimiters-depth-1">(</span>o <span class="org-haskell-operator">^.</span> key <span class="org-string">"x-image"</span> <span class="org-haskell-operator">.</span> _String <span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">":latest"</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
It did make me wonder if this kind of problem, setting a value based on another
value, isn't so common that there's a nicer solution to it. Perhaps coded up in
a combinator that isn't mentioned in <a href="https://leanpub.com/optics-by-example">Optics By Example</a> (or mabye I've forgot it
was mentioned). That lead me to ask around a bit, which leads to approach two.
</p>
</div>
</div>

<div id="outline-container-orgf55f462" class="outline-2">
<h2 id="orgf55f462">Second approach</h2>
<div class="outline-text-2" id="text-orgf55f462">
<p>
Arguably there isn't much difference, it's still traversing the sub-objects and
applying a function. The function makes use of <code>view</code> being run in a monad and
<code>ASetter</code> being defined with <code>Identity</code> (a monad).
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">setImage'</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">setImage'</span> y <span class="org-haskell-operator">=</span>
    y
        <span class="org-haskell-operator">&amp;</span> members <span class="org-haskell-operator">.</span> _Object
        <span class="org-haskell-operator">%~</span> <span class="org-rainbow-delimiters-depth-1">(</span>set <span class="org-rainbow-delimiters-depth-2">(</span>at <span class="org-string">"image"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">.</span> <span class="org-rainbow-delimiters-depth-2">(</span>_Just <span class="org-haskell-operator">.</span> _String <span class="org-haskell-operator">%~</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">":latest"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&lt;&lt;</span> view <span class="org-rainbow-delimiters-depth-2">(</span>at <span class="org-string">"x-image"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I haven't made up my mind on whether I like this better than the first. It's
disappointingly similar to the first one.
</p>
</div>
</div>

<div id="outline-container-orge880fe2" class="outline-2">
<h2 id="orge880fe2">Third approach</h2>
<div class="outline-text-2" id="text-orge880fe2">
<p>
Then I it might be nice to split the fetching of <code>x-image</code> values from the
addition of <code>image</code> key/value pairs. By extracting with an index it's possible
to keep track of what sub-object each <code>x-image</code> value comes from. Then two steps
can be combined using <code>foldl</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">setImage''</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Value</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Value</span>
<span class="org-haskell-definition">setImage''</span> y <span class="org-haskell-operator">=</span> foldl setOne y vals
  <span class="org-haskell-keyword">where</span>
    vals <span class="org-haskell-operator">=</span> y <span class="org-haskell-operator">^@..</span> members <span class="org-haskell-operator">&lt;.</span> key <span class="org-string">"x-image"</span> <span class="org-haskell-operator">.</span> _String
    setOne y' <span class="org-rainbow-delimiters-depth-1">(</span>objKey, value<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span>
        y'
            <span class="org-haskell-operator">&amp;</span> key objKey <span class="org-haskell-operator">.</span> _Object <span class="org-haskell-operator">.</span> at <span class="org-string">"image"</span>
            <span class="org-haskell-operator">?~</span> <span class="org-haskell-constructor">String</span> <span class="org-rainbow-delimiters-depth-1">(</span>value <span class="org-haskell-operator">&lt;&gt;</span> <span class="org-string">":latest"</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I'm not convinced though. I guess I'm still holding out for a brilliant
combinator that fits my problem perfectly.
</p>

<p>
Please point me to "the perfect solution" if you have one, or if you just have
some general tips on optics that would make my code clearer, or shorter, or more
elegant, or maybe just more lens-y.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-lens.html">lens</a> <a href="https://magnus.therning.org/tag-optics.html">optics</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[lens]]></category>
  <category><![CDATA[optics]]></category>
  <link>https://magnus.therning.org/2021-09-28-using-lens-to-set-a-value-based-on-another.html</link>
  <pubDate>Tue, 28 Sep 2021 13:21:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[Keeping todo items in org-roam v2]]></title>
  <description><![CDATA[
<p>
Org-roam v2 has been <a href="https://blog.jethro.dev/posts/org_roam_v2/">released</a> and yes, it broke my config a bit. Unfortunately
the v1-to-v2 upgrade wizard didn't work for me. I realized later that it might
have been due to the roam-related functions I'd hooked into `'before-save-hook`.
I didn't think about it until I'd already manually touched up almost all my
files (there aren't that many) so I can't say anything for sure. However, I
think it might be a good idea to keep hooks in mind if one runs into issues with
upgrading.
</p>

<p>
The majority of the time I didn't spend on my notes though, but on the setup
I've written about in an earlier post, <a href="https://magnus.therning.org/2021-03-14-keeping-todo-items-in-org-roam.html">Keeping todo items in org-roam</a>. Due to
some of the changes in v2, changes that I think make org-roam slightly more
"org-y", that setup needed a bit of love.
</p>

<p>
The basis is still the same 4 functions I described in that post, only the
details had to be changed.
</p>

<p>
I hope the following is useful, and as always I'm always happy to receive
commends and suggestions for improvements.
</p>

<div id="outline-container-org2ca70ee" class="outline-2">
<h2 id="org2ca70ee">Some tag helpers</h2>
<div class="outline-text-2" id="text-org2ca70ee">
<p>
The very handy functions for extracting tags as lists seem to be gone, in their
place I found <code>org-roam-{get,set}-keyword</code>. Using these I wrote three wrappers
that allow slightly nicer handling of tags.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:get-filetags</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>split-string <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">or</span> <span class="org-rainbow-delimiters-depth-4">(</span>org-roam-get-keyword <span class="org-string">"filetags"</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:add-filetag</span> <span class="org-rainbow-delimiters-depth-2">(</span>tag<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let*</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>new-tags <span class="org-rainbow-delimiters-depth-5">(</span>cons tag <span class="org-rainbow-delimiters-depth-6">(</span>roam-extra:get-filetags<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>new-tags-str <span class="org-rainbow-delimiters-depth-5">(</span>combine-and-quote-strings new-tags<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>org-roam-set-keyword <span class="org-string">"filetags"</span> new-tags-str<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:del-filetag</span> <span class="org-rainbow-delimiters-depth-2">(</span>tag<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let*</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>new-tags <span class="org-rainbow-delimiters-depth-5">(</span>seq-difference <span class="org-rainbow-delimiters-depth-6">(</span>roam-extra:get-filetags<span class="org-rainbow-delimiters-depth-6">)</span> `<span class="org-rainbow-delimiters-depth-6">(</span>,tag<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>new-tags-str <span class="org-rainbow-delimiters-depth-5">(</span>combine-and-quote-strings new-tags<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>org-roam-set-keyword <span class="org-string">"filetags"</span> new-tags-str<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc4e90df" class="outline-2">
<h2 id="orgc4e90df">The layer</h2>
<div class="outline-text-2" id="text-orgc4e90df">
<p>
<code>roam-extra:todo-p</code> needed no changes at all. I'm including it here only for
easy reference.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:todo-p</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Return non-nil if current buffer has any </span><span class="org-doc"><span class="custom">TODO</span></span><span class="org-doc"> entry.</span>

<span class="org-doc"><span class="custom">TODO</span></span><span class="org-doc"> entries marked as done are ignored, meaning the this</span>
<span class="org-doc">function returns nil if current buffer contains only completed</span>
<span class="org-doc">tasks."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>org-element-map
      <span class="org-rainbow-delimiters-depth-3">(</span>org-element-parse-buffer 'headline<span class="org-rainbow-delimiters-depth-3">)</span>
      'headline
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>h<span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">(</span>eq <span class="org-rainbow-delimiters-depth-5">(</span>org-element-property <span class="org-builtin">:todo-type</span> h<span class="org-rainbow-delimiters-depth-5">)</span>
          'todo<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    nil 'first-match<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
As pretty much all functions I used in the old version of
<code>roam-extra:update-todo-tag</code> are gone I took the opportunity to rework it
completely. I think it ended up being slightly simpler. I suspect the the use of
<code>org-with-point-at 1 ...</code> is unnecessary, but I haven't tested it yet so I'm
leaving it in for now.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:update-todo-tag</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Update </span><span class="org-doc"><span class="custom">TODO</span></span><span class="org-doc"> tag in the current buffer."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">and</span> <span class="org-rainbow-delimiters-depth-4">(</span>not <span class="org-rainbow-delimiters-depth-5">(</span>active-minibuffer-window<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
             <span class="org-rainbow-delimiters-depth-4">(</span>org-roam-file-p<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">org-with-point-at</span> <span class="org-highlight-numbers-number">1</span>
      <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">let*</span> <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-rainbow-delimiters-depth-6">(</span>tags <span class="org-rainbow-delimiters-depth-7">(</span>roam-extra:get-filetags<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
             <span class="org-rainbow-delimiters-depth-6">(</span>is-todo <span class="org-rainbow-delimiters-depth-7">(</span>roam-extra:todo-p<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">cond</span> <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-rainbow-delimiters-depth-7">(</span><span class="org-keyword">and</span> is-todo <span class="org-rainbow-delimiters-depth-8">(</span>not <span class="org-rainbow-delimiters-depth-9">(</span>seq-contains-p tags <span class="org-string">"</span><span class="org-string"><span class="custom">todo</span></span><span class="org-string">"</span><span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span>
               <span class="org-rainbow-delimiters-depth-7">(</span>roam-extra:add-filetag <span class="org-string">"</span><span class="org-string"><span class="custom">todo</span></span><span class="org-string">"</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
              <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-rainbow-delimiters-depth-7">(</span><span class="org-keyword">and</span> <span class="org-rainbow-delimiters-depth-8">(</span>not is-todo<span class="org-rainbow-delimiters-depth-8">)</span> <span class="org-rainbow-delimiters-depth-8">(</span>seq-contains-p tags <span class="org-string">"</span><span class="org-string"><span class="custom">todo</span></span><span class="org-string">"</span><span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span>
               <span class="org-rainbow-delimiters-depth-7">(</span>roam-extra:del-filetag <span class="org-string">"</span><span class="org-string"><span class="custom">todo</span></span><span class="org-string">"</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
In the previous version <code>roam-extra:todo-files</code> was built using an SQL query.
That felt a little brittle to me, so despite that my <a href="https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html">original inspiration</a>
contains an updated SQL query I decided to go the route of using the org-roam
API instead. The function <code>org-roam-node-list</code> makes it easy to get all nodes
and then finding the files is just a matter of using <code>seq-filter</code> and <code>seq-map</code>.
Now that headings may be nodes, and that heading-based nodes seem to inherit the
top-level tags, a file may appear more than once, hence the call to <code>seq-unique</code>
at the end.
</p>

<p>
Based on what I've seen V2 appears less eager to sync the DB, so to make sure
all nodes are up-to-date it's best to start off with forcing a sync.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:todo-files</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Return a list of roam files containing </span><span class="org-doc"><span class="custom">todo</span></span><span class="org-doc"> tag."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>org-roam-db-sync<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>todo-nodes <span class="org-rainbow-delimiters-depth-5">(</span>seq-filter <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-7">(</span>n<span class="org-rainbow-delimiters-depth-7">)</span>
                                  <span class="org-rainbow-delimiters-depth-7">(</span>seq-contains-p <span class="org-rainbow-delimiters-depth-8">(</span>org-roam-node-tags n<span class="org-rainbow-delimiters-depth-8">)</span> <span class="org-string">"</span><span class="org-string"><span class="custom">todo</span></span><span class="org-string">"</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
                                 <span class="org-rainbow-delimiters-depth-6">(</span>org-roam-node-list<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>seq-uniq <span class="org-rainbow-delimiters-depth-4">(</span>seq-map #'org-roam-node-file todo-nodes<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
With that in place it turns out that also <code>roam-extra:update-todo-files</code> worked
without any changes. I'm including it here for easy reference as well.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:update-todo-files</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">&amp;rest</span> _<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Update the value of `</span><span class="org-doc"><span class="org-constant">org-agenda-files</span></span><span class="org-doc">'."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq</span> org-agenda-files <span class="org-rainbow-delimiters-depth-3">(</span>roam-extra:todo-files<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org317e364" class="outline-2">
<h2 id="org317e364">Hooking it up</h2>
<div class="outline-text-2" id="text-org317e364">
<p>
The variable <code>org-roam-file-setup-hook</code> is gone, so the the more general
<code>find-file-hook</code> will have to be used instead.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>add-hook 'find-file-hook #'roam-extra:update-todo-tag<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span>add-hook 'before-save-hook #'roam-extra:update-todo-tag<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span>advice-add 'org-agenda <span class="org-builtin">:before</span> #'roam-extra:update-todo-files<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-org-mode.html">org-mode</a> <a href="https://magnus.therning.org/tag-org-roam.html">org-roam</a> <a href="https://magnus.therning.org/tag-spacemacs.html">spacemacs</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <category><![CDATA[org-mode]]></category>
  <category><![CDATA[org-roam]]></category>
  <category><![CDATA[spacemacs]]></category>
  <link>https://magnus.therning.org/2021-07-23-keeping-todo-items-in-org-roam-v2.html</link>
  <pubDate>Fri, 23 Jul 2021 15:07:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[The timeout manager exception]]></title>
  <description><![CDATA[
<p>
The other day I bumped the dependencies of a Haskell project at work and noticed
a new exception being thrown:
</p>

<blockquote>
<p>
Thread killed by timeout manager
</p>
</blockquote>

<p>
After a couple of false starts (it wasn't the <a href="https://hackage.haskell.org/package/resource-pool">connection pool</a>, nor was it
<a href="https://hackage.haskell.org/package/servant">servant</a>) I realised that a better approach would be to look at the list of
packages that were updated as part of the dependency bumping.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> Most of them
I thought would be <span class="underline">very</span> unlikely sources of it, but two in the list stood out:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Package</th>
<th scope="col" class="org-right">Pre</th>
<th scope="col" class="org-right">Post</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="https://hackage.haskell.org/package/unliftio">unliftio</a></td>
<td class="org-right">0.2.14</td>
<td class="org-right">0.2.18</td>
</tr>

<tr>
<td class="org-left"><a href="https://hackage.haskell.org/package/warp">warp</a></td>
<td class="org-right">3.3.15</td>
<td class="org-right">3.3.16</td>
</tr>
</tbody>
</table>

<p>
<code>warp</code> since the exception seemed to be thrown shortly after handling an HTTP
request, and <code>unliftio</code> since the exception was caught by the handler for
uncaught exceptions and its description contains "thread". Also, when looking at
the code changes in <code>warp</code> on GitHub<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> I found that some of the changes
introduced was increased use of <code>unliftio</code> for async stuff. The changes contain
mentions of <code>TimeoutThread</code> and <code>System.TimeManager</code>. That sounded promising,
and it lead me to the <a href="https://hackage.haskell.org/package/time-manager-0.0.0/docs/System-TimeManager.html#t:TimeoutThread">TimeoutThread</a> exception in <a href="https://hackage.haskell.org/package/time-manager">time-manager</a>.
</p>

<p>
With that knowledge I could quickly adjust the handler for uncaught exceptions
to not log <code>TimeoutThread</code> as fatal:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">lastExceptionHandler</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">SomeException</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">lastExceptionHandler</span> logger e
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-constructor">TimeoutThread</span> <span class="org-haskell-operator">&lt;-</span> fromException e <span class="org-haskell-operator">=</span> return <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
  <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      logFatalIoS logger <span class="org-haskell-operator">$</span> pack <span class="org-haskell-operator">$</span> <span class="org-string">"uncaught exception: "</span> <span class="org-haskell-operator">&lt;&gt;</span> displayException e
      flushLogStr logger
</pre>
</div>

<p>
I have to say it was a bit more work to arrive at this than I'd have liked. I
reckon there are easier ways to track down the information I needed. So I'd love
to hear what tricks and tips others have.
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
As a bonus it gave me a good reason to reach for <a href="https://man7.org/linux/man-pages/man1/comm.1.html"><code>comm</code></a>, a command that I
rarely use but for some reason always enjoy.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
GitHub's compare feature isn't very easy to discover, but a URL like this
<a href="https://github.com/yesodweb/wai/compare/warp-3.3.15...warp-3.3.16">https://github.com/yesodweb/wai/compare/warp-3.3.15&#x2026;warp-3.3.16</a> (note the 3
dots!) does the trick.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-warp.html">warp</a> <a href="https://magnus.therning.org/tag-servant.html">servant</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[warp]]></category>
  <category><![CDATA[servant]]></category>
  <link>https://magnus.therning.org/2021-07-03-the-timeout-manager-exception.html</link>
  <pubDate>Sat, 03 Jul 2021 13:52:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[A first look at HMock]]></title>
  <description><![CDATA[
<p>
The other day I found Chris Smith's <a href="https://itnext.io/hmock-first-rate-mocks-in-haskell-e59d7c3b066c">HMock: First Rate Mocks in Haskell</a> (<a href="https://hackage.haskell.org/package/HMock">link to
hackage</a>) and thought it could be nice see if it can clear up some of the tests I
have in a few of the Haskell projects at work. All the projects follow the
pattern of defining custom monads for effects (something like final tagless)
with instances implemented on a stack of monads from MTL. It's a pretty standard
thing in Haskell I'd say, especially since the monad stack very often ends up
being <code>ReaderT MyConfig IO</code>.
</p>

<p>
I decided to try it first on a single such custom monad, one for making HTTP
requests:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadHttpClient</span> m <span class="org-haskell-keyword">where</span>
  mHttpGet <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Status</span>, <span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span>
  mHttpPost <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Typeable</span> a, <span class="org-haskell-type">Postable</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">String</span> <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> m <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Status</span>, <span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Yes, the underlying implementation uses <a href="https://hackage.haskell.org/package/wreq">wreq</a>, but I'm not too bothered by that
shining through. Also, initially I didn't have that <code>Typeable a</code> constraint on
<code>mHttpPost</code>, it got added after a short <a href="https://github.com/cdsmith/HMock/issues/1">exchange about <code>KnownSymbol</code></a> with Chris.
</p>

<p>
To dip a toe in the water I thought I'd simply write tests for the two effects
themselves. First of all there's an impressive list of extensions needed, and
then the monad needs to be made mockable:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE DataKinds #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE GADTs #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE ImportQualifiedPost #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE RankNTypes #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeApplications #-}</span>
<span class="org-haskell-pragma">{-# LANGUAGE TypeFamilies #-}</span>

<span class="org-haskell-definition">makeMockable</span> ''<span class="org-haskell-constructor">MonadHttpClient</span>
</pre>
</div>

<p>
After that, writing a test with HMock for <code>mHttpGet</code> was fairly straight
forward, I could simply follow the examples in the package's documentation. I'm
using <a href="https://hackage.haskell.org/package/tasty">tasty</a> for organising the tests though:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">httpGetTest</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">TestTree</span>
<span class="org-haskell-definition">httpGetTest</span> <span class="org-haskell-operator">=</span> testCase <span class="org-string">"Get"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  <span class="org-rainbow-delimiters-depth-1">(</span>s, b<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> runMockT <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    expect <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MHttpGet</span> <span class="org-string">"url"</span> <span class="org-haskell-operator">|-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>status200, <span class="org-string">"result"</span><span class="org-rainbow-delimiters-depth-1">)</span>
    mHttpGet <span class="org-string">"url"</span>
  status200 <span class="org-haskell-operator">@=?</span> s
  <span class="org-string">"result"</span> <span class="org-haskell-operator">@=?</span> b
</pre>
</div>

<p>
The effect for sending a <code>POST</code> request was slightly trickier, as can be seen in
the issue linked above, but with some help I came up with the following:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">httpPostTest</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">TestTree</span>
<span class="org-haskell-definition">httpPostTest</span> <span class="org-haskell-operator">=</span> testCase <span class="org-string">"Post"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  <span class="org-rainbow-delimiters-depth-1">(</span>s, b<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> runMockT <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    expect <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">MHttpPost_</span> <span class="org-rainbow-delimiters-depth-1">(</span>eq <span class="org-string">"url"</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>typed <span class="org-haskell-operator">@</span><span class="org-haskell-constructor">ByteString</span> anything<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">|-&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>status201, <span class="org-string">"result"</span><span class="org-rainbow-delimiters-depth-1">)</span>
    mHttpPost <span class="org-string">"url"</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">)</span>
  status201 <span class="org-haskell-operator">@=?</span> s
  <span class="org-string">"result"</span> <span class="org-haskell-operator">@=?</span> b
</pre>
</div>

<div id="outline-container-org07a2709" class="outline-2">
<h2 id="org07a2709">Next step</h2>
<div class="outline-text-2" id="text-org07a2709">
<p>
My hope is that using HMock will remove the need for creating a bunch of test
implementations for the various custom monads for effects<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> in the projects,
thereby reducing the amount of test code overall. I also suspect that it will
make the tests clearer and easier to read, as the behaviour of the mocks are
closer to the tests using the mocks.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Basically they could be looked at as hand-written mocks.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> <a href="https://magnus.therning.org/tag-mocks.html">mocks</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[testing]]></category>
  <category><![CDATA[mocks]]></category>
  <link>https://magnus.therning.org/2021-06-27-a-first-look-at-hmock.html</link>
  <pubDate>Sun, 27 Jun 2021 23:14:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[ZSH, Nix, and completions]]></title>
  <description><![CDATA[
<p>
TIL that <a href="https://www.zsh.org/">ZSH</a> completions that come with Nix packages end up in
<code>~/.nix-profile/share/zsh/vendor-completions/</code> and that folder <i>is not</i> added to
<code>$FPATH</code> by the init script that comes with Nix.
</p>

<p>
After modifying the bit in <code>~/.zshenv</code> it now looks like this
</p>

<div class="org-src-container">
<pre class="src src-shell"><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">[</span> -f ~/.nix-profile/etc/profile.d/nix.sh <span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>; <span class="org-keyword">then</span>
    <span class="org-builtin">source</span> ~/.nix-profile/etc/profile.d/nix.sh
    <span class="org-builtin">export</span> <span class="org-variable-name">fpath</span>=<span class="org-rainbow-delimiters-depth-1">(</span>~/.nix-profile/share/zsh/vendor-completions $<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-variable-name">fpath</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-keyword">fi</span>
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-nix.html">nix</a> <a href="https://magnus.therning.org/tag-zsh.html">zsh</a> </div>]]></description>
  <category><![CDATA[nix]]></category>
  <category><![CDATA[zsh]]></category>
  <link>https://magnus.therning.org/2021-06-06-zsh,-nix,-and-completions.html</link>
  <pubDate>Sun, 06 Jun 2021 11:36:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[Working with Hedis]]></title>
  <description><![CDATA[
<p>
I'm now writing the second Haskell service using <a href="https://redis.io/commands/incrby">Redis</a> to store data. There are
a few packages on <a href="https://hackage.haskell.org/">Hackage</a> related to Redis but I only found 2 client libraries,
<a href="https://hackage.haskell.org/package/redis-io">redis-io</a> and <a href="https://hackage.haskell.org/package/hedis">hedis</a>. I must say I like the API of redis-io better, but it breaks
a rule I hold very dear:
</p>

<blockquote>
<p>
Libraries should never log, that's the responsibility of the application.
</p>
</blockquote>

<p>
So, hedis it is. I tried using the API as is, but found it really cumbersome so
looked around and after some inspiration from <a href="https://hackage.haskell.org/package/hedis-simple">hedis-simple</a> I came up with the
following functions.
</p>

<p>
First a wrapper around a Redis function that put everything into <code>ExceptionT</code>
with a function that transforms a <code>reply</code> into an <code>Exception</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">lpush</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Exception</span> e <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Reply</span> <span class="org-haskell-operator">-&gt;</span> e<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">ByteString</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ExceptionT</span> <span class="org-haskell-type">Redis</span> <span class="org-haskell-type">Integer</span>
<span class="org-haskell-definition">lpush</span> mapper key element <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ExceptionT</span> <span class="org-haskell-operator">$</span> replyToExc <span class="org-haskell-operator">&lt;$&gt;</span> R.lpush key element
  <span class="org-haskell-keyword">where</span>
    replyToExc <span class="org-haskell-operator">=</span> first <span class="org-rainbow-delimiters-depth-1">(</span>toException <span class="org-haskell-operator">.</span> mapper<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I found wrapping up functions like this is simple, but repetitive.
</p>

<p>
Finally I need a way to run the whole thing and unwrap it all back to <code>IO</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">runRedis</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Connection</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ExceptionT</span> <span class="org-haskell-type">Redis</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">SomeException</span> a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">runRedis</span> conn <span class="org-haskell-operator">=</span> R.runRedis conn <span class="org-haskell-operator">.</span> runExceptionT
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-redis.html">redis</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[redis]]></category>
  <link>https://magnus.therning.org/2021-05-07-working-with-hedis.html</link>
  <pubDate>Fri, 07 May 2021 20:54:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[First contribution to nixpkgs.haskellPackages]]></title>
  <description><![CDATA[
<p>
Nothing much to be proud of, but yesterday I found out that <a href="https://hackage.haskell.org/package/servant-docs">servant-docs</a> was
marked broken in <span class="underline">nixpkgs</span> even though it builds just fine and this morning I
decided to do something about it.
</p>

<p>
So, with the help of a <a href="https://discourse.nixos.org/t/call-to-action-for-updating-haskell-packages-after-bump-to-lts-15/6071">post on the NixOS discourse</a> I put together my first <a href="https://github.com/NixOS/nixpkgs/pull/120026">PR</a>.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-nix.html">nix</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>]]></description>
  <category><![CDATA[nix]]></category>
  <category><![CDATA[haskell]]></category>
  <link>https://magnus.therning.org/2021-04-21-first-contribution-to-nixpkgs.haskellpackages.html</link>
  <pubDate>Wed, 21 Apr 2021 22:46:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[Nix shell, direnv and XDG_DATA_DIRS]]></title>
  <description><![CDATA[
<p>
A few weeks ago I noticed that I no longer could use
<code>haskell-hoogle-lookup-from-website</code> in Emacs. After a bit of experimentation I
found that the reason was that I couldn't use <code>xdg-open</code> in a Nix shell.
Yesterday I finally got around to look into further.
</p>

<p>
It's caused by <code>direnv</code> overwriting <code>XDG_DATA_DIRS</code> rather than appending to it.
Of course someone already reported <a href="https://github.com/direnv/direnv/issues/785">a bug</a> already.
</p>

<p>
The workaround is to use
</p>

<div class="org-src-container">
<pre class="src src-shell">use nix --keep XDG_DATA_DIRS
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-nix.html">nix</a> <a href="https://magnus.therning.org/tag-direnv.html">direnv</a> </div>]]></description>
  <category><![CDATA[nix]]></category>
  <category><![CDATA[direnv]]></category>
  <link>https://magnus.therning.org/2021-04-13-nix-shell,-direnv-and-xdg_data_dirs.html</link>
  <pubDate>Tue, 13 Apr 2021 08:04:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[Todo items in org-roam, an update]]></title>
  <description><![CDATA[
<p>
I got an email from Mr Z with a nice modification to the code in my post on
<a href="2021-03-14-keeping-todo-items-in-org-roam.html">keeping todo items in org-roam</a>.
</p>

<p>
He already had a bunch of agenda files that he wanted to keep using (I had so
few of them that I'd simply converted them to roam files). Here's the solution
he shared with me:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defvar</span> <span class="org-variable-name">roam-extra-original-org-agenda-files</span> nil
  <span class="org-doc">"Original value of  `</span><span class="org-doc"><span class="org-constant">org-agenda-files</span></span><span class="org-doc">'."</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:update-todo-files</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">&amp;rest</span> _<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Update the value of `</span><span class="org-doc"><span class="org-constant">org-agenda-files</span></span><span class="org-doc">'."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">unless</span> roam-extra-original-org-agenda-files
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">setq</span> roam-extra-original-org-agenda-files org-agenda-files<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq</span> org-agenda-files
        <span class="org-rainbow-delimiters-depth-3">(</span>append roam-extra-original-org-agenda-files
                <span class="org-rainbow-delimiters-depth-4">(</span>roam-extra:todo-files<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
It's a rather nice modification I think. Thanks to Mr Z for agreeing to let me
share it here.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-org-mode.html">org-mode</a> <a href="https://magnus.therning.org/tag-org-roam.html">org-roam</a> </div>]]></description>
  <category><![CDATA[emacs]]></category>
  <category><![CDATA[org-mode]]></category>
  <category><![CDATA[org-roam]]></category>
  <link>https://magnus.therning.org/2021-03-21-todo-items-in-org-roam,-an-update.html</link>
  <pubDate>Sun, 21 Mar 2021 08:52:00 +0100</pubDate>
</item>
<item>
  <title><![CDATA[Barbie and <strike>Ken</strike>JSON]]></title>
  <description><![CDATA[
<p>
After higher-kinded data (HKD) and <a href="https://hackage.haskell.org/package/barbies">barbies</a> were mentioned in <a href="https://haskellweekly.news/episode/35.html">episode 35 of
Haskell Weekly</a> I've been wondering if it could be used in combination with <a href="https://hackage.haskell.org/package/aeson">aeson</a>
to do validation when implementing web services.
</p>

<p>
TLDR; I think it'd work, but I have a feeling I'd have to spend some more time
on it to get an API with nice ergonomics.
</p>

<div id="outline-container-orga9a9fc9" class="outline-2">
<h2 id="orga9a9fc9">Defining a type to play with</h2>
<div class="outline-text-2" id="text-orga9a9fc9">
<p>
I opted to use <a href="https://hackage.haskell.org/package/barbies-th">barbies-th</a> to save on the typing a bit. Defining a simple type
holding a name and an age can then look like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">declareBareB</span>
  <span class="org-rainbow-delimiters-depth-1">[</span>d<span class="org-haskell-operator">|</span>
   <span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Person</span> <span class="org-rainbow-delimiters-depth-2">{</span>name <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span>, age <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-haskell-operator">|</span><span class="org-rainbow-delimiters-depth-1">]</span>

<span class="org-haskell-keyword">deriving</span> <span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Show</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">deriving</span> <span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Show</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">deriving</span> <span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Show</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The two functions from the <code>Barbies</code> module documentation, <code>addDefaults</code> and
<code>check</code>, can then be written like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">addDefaults</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span>
<span class="org-haskell-definition">addDefaults</span> <span class="org-haskell-operator">=</span> bzipWith trans
  <span class="org-haskell-keyword">where</span>
    trans m d <span class="org-haskell-operator">=</span> maybe d pure m

<span class="org-haskell-definition">check</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Either</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">check</span> pe <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> btraverse <span class="org-rainbow-delimiters-depth-1">(</span>either <span class="org-rainbow-delimiters-depth-2">(</span>const <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">.</span> <span class="org-haskell-constructor">Identity</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> pe <span class="org-haskell-keyword">of</span>
  <span class="org-haskell-constructor">Just</span> pin <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Right</span> pin
  <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Left</span> <span class="org-haskell-operator">$</span> bfoldMap <span class="org-rainbow-delimiters-depth-1">(</span>either <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-3">[]</span></span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>const <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-3">[]</span></span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> pe
</pre>
</div>

<p>
I found it straight forward to define some instances and play with those
functions a bit.
</p>
</div>
</div>

<div id="outline-container-orgc68301e" class="outline-2">
<h2 id="orgc68301e">Adding in JSON</h2>
<div class="outline-text-2" id="text-orgc68301e">
<p>
The bit that wasn't immediately obvious to me was how to use aeson to parse into
a type like <code>Person Covered (Either Text)</code>.
</p>

<p>
First off I needed some data to test things out with.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">bs0, bs1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span>
<span class="org-haskell-definition">bs0</span> <span class="org-haskell-operator">=</span> <span class="org-string">"{\"name\": \"the name\", \"age\": 17}"</span>
<span class="org-haskell-definition">bs1</span> <span class="org-haskell-operator">=</span> <span class="org-string">"{\"name\": \"the name\", \"age\": true}"</span>
</pre>
</div>

<p>
To keep things simple I took baby steps, first I tried parsing into <code>Person
Covered Identity</code>. It turns out that the <code>FromJSON</code> instance from that doesn't
need much thought at all. (It's a bit of a pain to have to specify types in GHCi
all the time, so I'm throwing in a specialised decoding function for each type
too.)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">FromJSON</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  parseJSON <span class="org-haskell-operator">=</span> withObject <span class="org-string">"Person"</span> <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">\</span>o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Person</span> <span class="org-haskell-operator">&lt;$&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"name"</span>
      <span class="org-haskell-operator">&lt;*&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"age"</span>

<span class="org-haskell-definition">decodePI</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">decodePI</span> <span class="org-haskell-operator">=</span> decode
</pre>
</div>

<p>
Trying it out on the test data gives the expected results
</p>

<pre class="example" id="orgbe631ca">
&gt; let i0 = decodePI bs0
&gt; i0
Just (Person {name = Identity "the name", age = Identity 17})
&gt; let i1 = decodePI bs1
&gt; i1
Nothing
</pre>

<p>
So far so good! Moving onto <code>Person Covered Maybe</code>. I spent some time trying to
use the combinators in <code>Data.Aeson</code> for dealing with parser failures, but in the
end I had to resort to using <code>&lt;|&gt;</code> from <code>Alternative</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">FromJSON</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  parseJSON <span class="org-haskell-operator">=</span> withObject <span class="org-string">"Person"</span> <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">\</span>o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Person</span> <span class="org-haskell-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>o <span class="org-haskell-operator">.:</span> <span class="org-string">"name"</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-operator">&lt;*&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>o <span class="org-haskell-operator">.:</span> <span class="org-string">"age"</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">decodePM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">decodePM</span> <span class="org-haskell-operator">=</span> decode
</pre>
</div>

<p>
Trying that out I saw exactly the behaviour I expected, i.e. that parsing won't
fail. (Well, at least not as long as it's a valid JSON object to being with.)
</p>

<pre class="example" id="orgec185e3">
&gt; let m0 = decodePM bs0
&gt; m0
Just (Person {name = Just "the name", age = Just 17})
&gt; let m1 = decodePM bs1
&gt; m1
Just (Person {name = Just "the name", age = Nothing})
</pre>

<p>
With that done I found that the instance for <code>Person Covered (Either Text)</code>
followed quite naturally. I had to spend a little time on getting the types
right to parse the fields properly. Somewhat disappointingly I didn't get type
errors when the behaviour of the code turned out to be wrong. I'm gussing
aeson's <code>Parser</code> was a little too willing to give me parser failures. Anyway, I
ended up with this instance
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">FromJSON</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  parseJSON <span class="org-haskell-operator">=</span> withObject <span class="org-string">"Person"</span> <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">\</span>o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Person</span> <span class="org-haskell-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">&lt;$&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"name"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Left</span> <span class="org-string">"A name is most needed"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-operator">&lt;*&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">&lt;$&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"age"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Left</span> <span class="org-string">"An integer age is needed"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">decodePE</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">decodePE</span> <span class="org-haskell-operator">=</span> decode
</pre>
</div>

<p>
That does exhibit the behaviour I want
</p>

<pre class="example" id="orgb5a080b">
&gt; let e0 = decodePE bs0
&gt; e0
Just (Person {name = Right "the name", age = Right 17})
&gt; let e1 = decodePE bs1
&gt; e1
Just (Person {name = Right "the name", age = Left "An integer age is needed"})
</pre>
</div>
</div>

<div id="outline-container-orgcfdacc1" class="outline-2">
<h2 id="orgcfdacc1">In closing</h2>
<div class="outline-text-2" id="text-orgcfdacc1">
<p>
I think everyone will agree that the <code>FromJSON</code> instances are increasingly
messy. I think that can be fixed by putting some thought into what a more
pleasing API should look like.
</p>

<p>
I'd also like to mix in validation beyond what aeson offers out-of-the-box,
which really only is "is the field present?" and "does the value have the
correct type?". For instance, Once we know there is a field called <code>age</code>, and
that it's an <code>Int</code>, then we might want to make sure it's non-negitive, or that
the person is at least 18. I'm guessing that wouldn't be too difficult.
</p>

<p>
Finally, I'd love to see examples of using HKDs for parsing/validation in the
wild. It's probably easiest to reach me at <a href="https://mastodon.technology/@magthe">@magthe@mastodon.technology</a>.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hkd.html">hkd</a> <a href="https://magnus.therning.org/tag-json.html">json</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[hkd]]></category>
  <category><![CDATA[json]]></category>
  <link>https://magnus.therning.org/2021-03-20-barbie-and-json.html</link>
  <pubDate>Sat, 20 Mar 2021 16:22:00 +0100</pubDate>
</item>
</channel>
</rss>
