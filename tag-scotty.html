<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://magnus.therning.org/feed.xml"
      title="RSS feed for https://magnus.therning.org/">
<title>Magnus web site</title>
<meta name="author" content="Magnus Therning"><meta name="referrer" content="no-referrer"><link href= "static/style.css" rel="stylesheet" type="text/css" /><link href= "static/htmlize.css" rel="stylesheet" type="text/css" /><link href= "static/extra_style.css" rel="stylesheet" type="text/css" /></head>
<body>
<div id="preamble" class="status"><div class="nav-bar"><a class="nav-link" href="./index.html">Top</a><a class="nav-link" href="./archive.html">Archive</a><a class="nav-link align-right" href="./feed.xml"><img src="static/rss-feed-icon.png" style="height: 24px;" /></a></div></div>
<div id="content">
<h1 class="title">Posts tagged "scotty":</h1>
<div class="post-date">10 Aug 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-08-10-000-architecture-of-a-service.html">Architecture of a service</a></h1>
<p>
Early this summer it was finally time to put this one service I've been working
on into our sandbox environment. It's been running without hickups so last week
I turned it on for production as well. In this post I thought I'd document the
how and why of the service in the hope that someone will find it useful.
</p>

<p>
The service functions as an interface to external SMS-sending services, offering
a single place to change if we find that we are unhappy with the service we're
using.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> This service replaces an older one, written in Ruby and no one really
dares touch it. Hopefully the Haskell version will prove to be a joy to work
with over time.
</p>

<div id="outline-container-org214f34f" class="outline-2">
<h2 id="org214f34f">Overview of the architecture</h2>
<div class="outline-text-2" id="text-org214f34f">
<p>
The service is split into two parts, one web server using <a href="https://hackage.haskell.org/package/scotty">scotty</a>, and streaming
data processing using <a href="https://hackage.haskell.org/package/conduit">conduit</a>. Persistent storage is provided by a <a href="https://www.postgresql.org/">PostgreSQL</a>
database. The general idea is that events are picked up from the database, acted
upon, which in turn results in other events which written to the database. Those
are then picked up and round and round we go. The web service accepts requests,
turns them into events and writes the to the database.
</p>

<p>
Hopefully this crude diagram clarifies it somewhat.
</p>


<figure id="org02f059e">
<img src="static/2019-08-10-architecture.png" alt="2019-08-10-architecture.png">

<figcaption><span class="figure-number">Figure 1: </span>Diagram of the service architecture</figcaption>
</figure>

<p>
There are a few things that might need some explanation
</p>

<ul class="org-ul">
<li><p>
In the past we've wanted to have the option to use multiple external SMS
services at the same time. One is randomly chosen as the request comes in.
There's also a possibility to configure the frequency for each external
service.
</p>

<p>
<i>Picker</i> implements the random picking and I've written about that earlier in
<a href="2019-02-17-000-choosing-a-conduit-randomly.html">Choosing a conduit randomly</a>.
</p>

<p>
<i>Success</i> and <i>fail</i> are dummy senders. They don't actually send anything, and
the former succeeds at it while the latter fails. I found them useful for
manual testing.
</p></li>

<li><p>
Successfully sending off a request to an external SMS service, getting status
200 back, doesn't actually mean that the SMS has been sent, or even that it
ever will be. Due to the nature of SMS messaging there are no guarantees of
timeliness at all. Since we are interested in finding out whether an SMS
actually is sent a delayed action is scheduled, which will fetch the status of
a sent SMS after a certain time (currently 2 minutes). If an SMS hasn't been
sent after that time it might as well never be &#x2013; it's too slow for our
end-users.
</p>

<p>
This is what <i>report-fetcher</i> and <i>fetcher-func</i> do.
</p></li>

<li>The <i>queue sink</i> and <i>queue src</i> are actually <a href="https://hackage.haskell.org/package/stm-conduit-4.0.1/docs/Data-Conduit-TQueue.html#v:sourceTQueue"><code>sourceTQueue</code></a> and <a href="https://hackage.haskell.org/package/stm-conduit-4.0.1/docs/Data-Conduit-TQueue.html#v:sinkTQueue"><code>sinkTQueue</code></a>.
Splitting the stream like that makes it trivial to push in events by using
<a href="https://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM-TQueue.html#v:writeTQueue"><code>writeTQueue</code></a>.</li>

<li>I use <a href="https://hackage.haskell.org/package/conduit-1.3.1.1/docs/Data-Conduit.html#v:sequenceConduits"><code>sequenceConduits</code></a> in order to send a single event to multiple
=Conduit=s and then combine all their results back into a single stream. The
ease with which this can be done in <a href="https://hackage.haskell.org/package/conduit">conduit</a> is one of the main reasons why I
choose to use it.<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup></li>
</ul>
</div>
</div>

<div id="outline-container-org29b0e87" class="outline-2">
<h2 id="org29b0e87">Effects and tests</h2>
<div class="outline-text-2" id="text-org29b0e87">
<p>
I started out writing everything based on a type like <code>ReaderT &lt;my cfg type&gt; IO</code>
and using <code>liftIO</code> for effects that needed lifting. This worked nicely while I
was setting up the basic structure of the service, but as soon as I hooked in
the database I really wanted to do some testing also of the effectful code.
</p>

<p>
After reading <a href="https://serokell.io/blog/2018/12/07/tagless-final">Introduction to Tagless Final</a> and
<a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">The ReaderT Design Patter</a>, playing a bit with both approaches, and writing
<a href="2019-01-20-000-tagless-final-and-scotty.html">Tagless final and Scotty</a> and
<a href="2019-02-02-000-the-readert-design-pattern-or-tagless-final-.html">The ReaderT design pattern or tagless final?</a>, I finally chose to go down the route
of <i>tagless final</i>. There's no strong reason for that decision, maybe it was
just because I read about it first and found it very easy to move in that
direction in small steps.
</p>

<p>
There's a split between property tests and unit tests:
</p>

<ul class="org-ul">
<li>Data types, their monad instances (like JSON (de-)serialisation), pure
functions and a few effects are tested using properties. I'm using <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>
for that. I've since looked a little closer at <a href="https://hackage.haskell.org/package/hedgehog">hedgehog</a> and if I were to do a
major overhaul of the property tests I might be tempted to rewrite them using
that library instead.</li>

<li>Most of the =Conduit=s are tested using <a href="https://hackage.haskell.org/package/HUnit">HUnit</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-org98fd41b" class="outline-2">
<h2 id="org98fd41b">Configuration</h2>
<div class="outline-text-2" id="text-org98fd41b">
<p>
The service will be run in a container and we try to follow the <a href="https://12factor.net/">12-factor app
rules</a>, where the third one says that configuration should be stored in the
environment. All previous Haskell projects I've worked on have been command line
tools were configuration is done (mostly) using command line argument. For that
I usually use <a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a>, but it's not applicable in this setting.
</p>

<p>
After a bit of searching on <a href="https://hackage.haskell.org/">hackage</a> I settled on <a href="https://hackage.haskell.org/package/etc">etc</a>. It turned out to be nice
an easy to work with. The configuration is written in JSON and only specifies
environment variables. It's then embedded in the executable using <a href="https://hackage.haskell.org/package/file-embed">file-embed</a>.
The only thing I miss is a <a href="https://hackage.haskell.org/package/aeson/docs/Data-Aeson.html#t:ToJSON"><code>ToJSON</code></a> instance for <a href="https://hackage.haskell.org/package/etc-0.4.1.0/docs/System-Etc.html#t:Config"><code>Config</code></a> &#x2013; we've found it
quite useful to log the active configuration when starting a service and that
log entry would become a bit nicer if the message was JSON rather than the
(somewhat difficult to read) string that <code>Config</code>'s <code>Show</code> instance produces.
</p>
</div>
</div>

<div id="outline-container-org8788723" class="outline-2">
<h2 id="org8788723">Logging</h2>
<div class="outline-text-2" id="text-org8788723">
<p>
There are two requirements we have when it comes to logging
</p>

<ol class="org-ol">
<li>All log entries tied to a request should have a <a href="https://hilton.org.uk/blog/microservices-correlation-id">correlation ID</a>.</li>
<li>Log requests and responses</li>
</ol>

<p>
I've written about correlation ID before, <a href="2018-10-01-000-using-a-configuration-in-scotty.html">Using a configuration in Scotty</a>.
</p>

<p>
Logging requests and responses is an area where I'm not very happy with <a href="https://hackage.haskell.org/package/scotty">scotty</a>.
It feels natural to solve it using middleware (i.e. using <a href="https://hackage.haskell.org/package/scotty/docs/Web-Scotty.html#v:middleware"><code>middleware</code></a>) but the
representation, especially of responses, is a bit complicated so for the time
being I've skipped logging the body of both. I'd be most interested to hear of
libraries that could make that easier.
</p>
</div>
</div>

<div id="outline-container-org2b55605" class="outline-2">
<h2 id="org2b55605">Data storage and picking up new events</h2>
<div class="outline-text-2" id="text-org2b55605">
<p>
The data stream processing depends heavily on being able to pick up when new
events are written to the database. Especially when there are more than one
instance running (we usually have at least two instance running in the
production environment). To get that working I've used <a href="https://hackage.haskell.org/package/postgresql-simple">postgresql-simple</a>'s
support for <a href="https://www.postgresql.org/docs/current/sql-listen.html"><code>LISTEN</code></a> and <a href="https://www.postgresql.org/docs/current/sql-notify.html"><code>NOTIFY</code></a> via the function <a href="https://hackage.haskell.org/package/postgresql-simple-0.6.2/docs/Database-PostgreSQL-Simple-Notification.html#v:getNotification"><code>getNotification</code></a>.
</p>

<p>
When I wrote about this earlier, <a href="2019-03-03-000-conduit-and-postgresql.html">Conduit and PostgreSQL</a> I got some really good
feedback that made my solution more robust.
</p>
</div>
</div>

<div id="outline-container-org2cf7562" class="outline-2">
<h2 id="org2cf7562">Delayed actions</h2>
<div class="outline-text-2" id="text-org2cf7562">
<p>
Some things in Haskell feel almost like cheating. The light-weight threading
makes me confident that a <a href="https://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:forkIO"><code>forkIO</code></a> followed by a <a href="https://hackage.haskell.org/package/base/docs/Control-Concurrent.html#v:threadDelay"><code>threadDelay</code></a> (or in my case,
the ones from <a href="https://hackage.haskell.org/package/unliftio">unliftio</a>) will suffice.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
It has happened in the past that we've changed SMS service after finding
that they weren't living up to our expectations.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
A while ago I was experimenting with other streaming libraries, but I
gave up on getting re-combination to work &#x2013; <a href="2018-10-16-000-zipping-streams.html">Zipping streams</a>
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-conduit.html">conduit</a> <a href="https://magnus.therning.org/tag-scotty.html">scotty</a> <a href="https://magnus.therning.org/tag-postgresql.html">postgresql</a> <a href="https://magnus.therning.org/tag-tagless.html">tagless</a> <a href="https://magnus.therning.org/tag-final.html">final</a> </div>
<div class="post-date">20 Jan 2019</div><h1 class="post-title"><a href="https://magnus.therning.org/2019-01-20-000-tagless-final-and-scotty.html">Tagless final and Scotty</a></h1>
<p>
For a little while I've been playing around with event sourcing in Haskell using
<a href="https://hackage.haskell.org/package/conduit"><code>Conduit</code></a> and <a href="https://hackage.haskell.org/package/scotty"><code>Scotty</code></a>. I've come far enough that the basic functionality I'm
after is there together with all those little bits that make it a piece of
software that's fit for deployment in production (configuration, logging, etc.).
There's just one thing that's been nagging me, testability.
</p>

<p>
The app is built of two main parts, a web server (<code>Scotty</code>) and a pipeline of
stream processing components (<code>Conduit</code>). The part using <code>Scotty</code> is utilising a
simple monad stack, <code>ReaderT Config IO</code>, and the <code>Conduit</code> part is using
<code>Conduit In Out IO</code>. This means that in both parts the outer edge, the part
dealing with the outside world, is running in <code>IO</code> directly. Something that
isn't really aiding in testing.
</p>

<p>
I started out thinking that I'd rewrite what I have using a free monad with a
bunch of interpreters. Then I remembered that I have "check out tagless final".
This post is a record of the small experiments I did to see how to use it with
<code>Scotty</code> to achieve (and actually improve) on the code I have in my
production-ready code.
</p>

<div id="outline-container-org70bf102" class="outline-2">
<h2 id="org70bf102">1 - Use tagless final with <code>Scotty</code></h2>
<div class="outline-text-2" id="text-org70bf102">
<p>
As a first simple little experiment I wrote a tiny little web server that would
print a string to <code>stdout</code> when receiving the request to <code>GET /route0</code>.
</p>

<p>
The printing to <code>stdout</code> is the operation I want to make abstract.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadPrinter</span> m <span class="org-haskell-keyword">where</span>
  mPutStrLn <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
</pre>
</div>

<p>
I then created an application type that is an instance of that class.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span> unAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> a <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadPrinter</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mPutStrLn t <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> putStrLn <span class="org-rainbow-delimiters-depth-1">(</span>unpack t<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Then I added a bit of <code>Scotty</code> boilerplate. It's not strictly necessary, but
does make the code a bit nicer to read.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">FooM</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ScottyT</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-type">AppM</span>
<span class="org-haskell-keyword">type</span> <span class="org-haskell-type">FooActionM</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ActionT</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-type">AppM</span>

<span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Port</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ScottyT</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">foo</span> port <span class="org-haskell-operator">=</span> scottyT port unAppM
</pre>
</div>

<p>
With that in place the web server itself is just a matter of tying it all
together.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  foo <span class="org-highlight-numbers-number">3000</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    get <span class="org-string">"/route0"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      lift <span class="org-haskell-operator">$</span> mPutStrLn <span class="org-string">"getting /route0"</span>
      json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"route0"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"ok"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    notFound <span class="org-haskell-operator">$</span> json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"error"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"not found"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
That was simple enough.
</p>
</div>
</div>

<div id="outline-container-org032b911" class="outline-2">
<h2 id="org032b911">2 - Add configuration</h2>
<div class="outline-text-2" id="text-org032b911">
<p>
In order to try out how to deal with configuration I added a class for doing
some simple logging
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Monad</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">MonadLogger</span> m <span class="org-haskell-keyword">where</span>
  mLog <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
</pre>
</div>

<p>
The straight forward way to deal with configuration is to create a monad stack
with <code>ReaderT</code> and since it's logging I want to do the configuration consists of
a single <code>LoggerSet</code> (from <a href="https://hackage.haskell.org/package/fast-logger"><code>fast-logger</code></a>).
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span> unAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ReaderT</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-type">IO</span> a <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span>, <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">LoggerSet</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That means the class instance can be implemented like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadLogger</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mLog msg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    ls <span class="org-haskell-operator">&lt;-</span> ask
    liftIO <span class="org-haskell-operator">$</span> pushLogStrLn ls <span class="org-haskell-operator">$</span> toLogStr msg
</pre>
</div>

<p>
Of course <code>foo</code> has to be changed too, and it becomes a little easier with a
wrapper for <code>runReaderT</code> and <code>unAppM</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">foo</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Port</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ScottyT</span> <span class="org-haskell-type">Text</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">foo</span> ls port <span class="org-haskell-operator">=</span> scottyT port <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">`runAppM`</span> ls<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">LoggerSet</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> a
<span class="org-haskell-definition">runAppM</span> app ls <span class="org-haskell-operator">=</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span> ls
</pre>
</div>

<p>
With that in place the printing to <code>stdout</code> can be replaced by a writing to the
log.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  ls <span class="org-haskell-operator">&lt;-</span> newStdoutLoggerSet defaultBufSize
  foo ls <span class="org-highlight-numbers-number">3000</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    get <span class="org-string">"/route0"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      lift <span class="org-haskell-operator">$</span> mLog <span class="org-string">"log: getting /route0"</span>
      json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"route0"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"ok"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    notFound <span class="org-haskell-operator">$</span> json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"error"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"not found"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
Not really a big change, I'd say. Extending the configuration is clearly
straight forward too.
</p>
</div>
</div>

<div id="outline-container-org9bf256e" class="outline-2">
<h2 id="org9bf256e">3 - Per-request configuration</h2>
<div class="outline-text-2" id="text-org9bf256e">
<p>
At work we use correlation IDs<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> and I think that the most convenient way to
deal with it is to put the correlation ID into the configuration after
extracting it. That is, I want to modify the configuration on each request.
Luckily it turns out to be possible to do that, despite using <code>ReaderT</code> for
holding the configuration.
</p>

<p>
I can't be bothered with a full implementation of correlation ID for this little
experiment, but as long as I can get a new <code>AppM</code> by running a function on the
configuration it's just a matter of extracting the correct header from the
request. For this experiment it'll do to just modify an integer in the
configuration.
</p>

<p>
I start with defining a type for the configuration and changing <code>AppM</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">LoggerSet</span>, <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span> unAppM <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ReaderT</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-type">IO</span> a <span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Functor</span>, <span class="org-haskell-constructor">Applicative</span>, <span class="org-haskell-constructor">Monad</span>, <span class="org-haskell-constructor">MonadIO</span>, <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Config</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The logger instance has to be changed accordingly of course.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadLogger</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  mLog msg <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    <span class="org-rainbow-delimiters-depth-1">(</span>ls, i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> ask
    liftIO <span class="org-haskell-operator">$</span> pushLogStrLn ls <span class="org-haskell-operator">$</span> toLogStr msg <span class="org-haskell-operator">&lt;&gt;</span> toLogStr <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">":"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;&gt;</span> toLogStr <span class="org-rainbow-delimiters-depth-1">(</span>show i<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The <code>get</code> function that comes with <code>scotty</code> isn't going to cut it, since it has
no way of modifying the configuration, so I'll need a new one.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">mGet</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ScottyError</span> e <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">RoutePattern</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ActionT</span> e <span class="org-haskell-type">AppM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ScottyT</span> e <span class="org-haskell-type">AppM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">mGet</span> p a <span class="org-haskell-operator">=</span> get p <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  withCfg <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> <span class="org-rainbow-delimiters-depth-2">(</span>ls, i<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span>ls, succ i<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> a
</pre>
</div>

<p>
The tricky bit is in the <code>withCfg</code> function. It's indeed not very easy to read,
I think
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">withCfg</span> <span class="org-haskell-operator">=</span> mapActionT <span class="org-haskell-operator">.</span> withAppM
  <span class="org-haskell-keyword">where</span>
    mapActionT f <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">ActionT</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ActionT</span> <span class="org-haskell-operator">$</span> <span class="org-rainbow-delimiters-depth-1">(</span>mapExceptT <span class="org-haskell-operator">.</span> mapReaderT <span class="org-haskell-operator">.</span> mapStateT<span class="org-rainbow-delimiters-depth-1">)</span> f a
    withAppM f a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-haskell-operator">$</span> withReaderT f <span class="org-rainbow-delimiters-depth-1">(</span>unAppM a<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Basically it reaches into the guts of <code>scotty</code>'s <code>ActionT</code> type (the details are
exposed in <code>Web.Scotty.Internal.Types</code>, thanks for not hiding it completely),
and modifies the <code>ReaderT Config</code> I've supplied.
</p>

<p>
The new server has two routes, the original one and a new one at <code>GET /route1</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  putStrLn <span class="org-string">"Starting"</span>
  ls <span class="org-haskell-operator">&lt;-</span> newStdoutLoggerSet defaultBufSize
  foo <span class="org-rainbow-delimiters-depth-1">(</span>ls, <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-highlight-numbers-number">3000</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    get <span class="org-string">"/route0"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      lift <span class="org-haskell-operator">$</span> mLog <span class="org-string">"log: getting /route0"</span>
      json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"route0"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"ok"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    mGet <span class="org-string">"/route1"</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      lift <span class="org-haskell-operator">$</span> mLog <span class="org-string">"log: getting /route1"</span>
      json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"route1"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"bar"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    notFound <span class="org-haskell-operator">$</span> json <span class="org-haskell-operator">$</span> object <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"error"</span> <span class="org-haskell-operator">.=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"not found"</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
It's now easy to verify that the original route, <code>GET /route0</code>, logs a string
containing the integer '0', while the new route, <code>GET /route1</code>, logs a string
containing the integer '1'.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
If you don't know what it is you'll find multiple sources by searching
for "http correlation-id". <a href="https://theburningmonk.com/2015/05/a-consistent-approach-to-track-correlation-ids-through-microservices/">A consistent approach to track correlation IDs
through microservices</a> is as good a place to start as any.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-scotty.html">scotty</a> <a href="https://magnus.therning.org/tag-tagless_final.html">tagless_final</a> </div>
<div class="post-date">01 Oct 2018</div><h1 class="post-title"><a href="https://magnus.therning.org/2018-10-01-000-using-a-configuration-in-scotty.html">Using a configuration in Scotty</a></h1>
<p>
At work we're only now getting around to put <a href="https://hilton.org.uk/blog/microservices-correlation-id">correlation IDs</a> into use. We write
most our code in Clojure but since I'd really like to use more Haskell at work I
thought I'd dive into <a href="https://hackage.haskell.org/package/scotty">Scotty</a> and see how to deal with logging and then
especially how to get correlation IDs into the logs.
</p>

<div id="outline-container-org908bdc9" class="outline-2">
<h2 id="org908bdc9">The types</h2>
<div class="outline-text-2" id="text-org908bdc9">
<p>
For configuration it decided to use the reader monad inside <code>ActionT</code> from
Scotty. Enter Chell:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">ChellM</span> c <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ScottyT</span> <span class="org-haskell-type">Text</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">ReaderT</span> c <span class="org-haskell-type">IO</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">type</span> <span class="org-haskell-type">ChellActionM</span> c <span class="org-haskell-operator">=</span> <span class="org-haskell-type">ActionT</span> <span class="org-haskell-type">Text</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">ReaderT</span> c <span class="org-haskell-type">IO</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
In order to run it I wrote a function corresponding to <code>scotty</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">chell</span> <span class="org-haskell-operator">::</span> c <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Port</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellM</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">chell</span> cfg port a <span class="org-haskell-operator">=</span> scottyOptsT opts <span class="org-rainbow-delimiters-depth-1">(</span>flip runReaderT cfg<span class="org-rainbow-delimiters-depth-1">)</span> a
  <span class="org-haskell-keyword">where</span>
    opts <span class="org-haskell-operator">=</span> def <span class="org-rainbow-delimiters-depth-1">{</span> verbose <span class="org-haskell-operator">=</span> <span class="org-highlight-numbers-number">0</span>
               , settings <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-2">(</span>settings def<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> settingsPort <span class="org-haskell-operator">=</span> port <span class="org-rainbow-delimiters-depth-2">}</span>
               <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6fb6127" class="outline-2">
<h2 id="org6fb6127">Correlation ID</h2>
<div class="outline-text-2" id="text-org6fb6127">
<p>
To deal with the correlation ID each incoming request should be checked for the
HTTP header <code>X-Correlation-Id</code> and if present it should be used during logging.
If no such header is present then a new correlation ID should be created. Since
it's per request it feels natural to create a WAI middleware for this.
</p>

<p>
The easiest way I could come up with was to push the correlation ID into the
request's headers before it's passed on:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">requestHeaderCorrelationId</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Request</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">ByteString</span>
<span class="org-haskell-definition">requestHeaderCorrelationId</span> <span class="org-haskell-operator">=</span> lookup <span class="org-string">"X-Correlation-Id"</span> <span class="org-haskell-operator">.</span> requestHeaders

<span class="org-haskell-definition">correlationId</span> <span class="org-haskell-operator">::</span>  <span class="org-haskell-type">Middleware</span>
<span class="org-haskell-definition">correlationId</span> app req sendResponse <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  u <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-1">(</span>randomIO <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">UUID</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">let</span> corrId <span class="org-haskell-operator">=</span> maybe <span class="org-rainbow-delimiters-depth-1">(</span>toASCIIBytes u<span class="org-rainbow-delimiters-depth-1">)</span> id <span class="org-rainbow-delimiters-depth-1">(</span>requestHeaderCorrelationId req<span class="org-rainbow-delimiters-depth-1">)</span>
      newHeaders <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"X-Correlation-Id"</span>, corrId<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">:</span> <span class="org-rainbow-delimiters-depth-1">(</span>requestHeaders req<span class="org-rainbow-delimiters-depth-1">)</span>
  app <span class="org-rainbow-delimiters-depth-1">(</span>req <span class="org-rainbow-delimiters-depth-2">{</span> requestHeaders <span class="org-haskell-operator">=</span> newHeaders <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-operator">\</span> res <span class="org-haskell-operator">-&gt;</span> sendResponse res
</pre>
</div>

<p>
It also turns out to be useful to have both a default correlation ID and a
function for pulling it out of the headers:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">defaultCorrelationString</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">ByteString</span>
<span class="org-haskell-definition">defaultCorrelationString</span> <span class="org-haskell-operator">=</span> <span class="org-string">"no-correlation-id"</span>

<span class="org-haskell-definition">getCorrelationId</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Request</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ByteString</span>
<span class="org-haskell-definition">getCorrelationId</span> r <span class="org-haskell-operator">=</span> maybe defaultCorrelationString id <span class="org-rainbow-delimiters-depth-1">(</span>requestHeaderCorrelationId r<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org210c543" class="outline-2">
<h2 id="org210c543">Getting the correlation ID into the configuration</h2>
<div class="outline-text-2" id="text-org210c543">
<p>
Since the correlation ID should be picked out of the request on handling of
every request it's useful to have it the configuration when running the
<code>ChellActionM</code> actions. However, since the correlation ID isn't available when
running the reader (the call to <code>runReaderT</code> in <code>chell</code>) something else is
called for. When looking around I found <code>local</code> (and later I was pointed to the
more general <code>withReaderT</code>) but it doesn't have a suitable type. After some <a href="https://twitter.com/EyalL/status/1046696148218580993">help
on Twitter</a> I arrived at <code>withConfig</code> which allows me to run an action in a
modified configuration:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">withConfig</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span>c <span class="org-haskell-operator">-&gt;</span> c'<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellActionM</span> c' <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellActionM</span> c <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">withConfig</span> <span class="org-haskell-operator">=</span> mapActionT <span class="org-haskell-operator">.</span> withReaderT
  <span class="org-haskell-keyword">where</span>
    mapActionT f <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">ActionT</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">ActionT</span> <span class="org-haskell-operator">$</span> <span class="org-rainbow-delimiters-depth-1">(</span>mapExceptT <span class="org-haskell-operator">.</span> mapReaderT <span class="org-haskell-operator">.</span> mapStateT<span class="org-rainbow-delimiters-depth-1">)</span> f a
</pre>
</div>
</div>
</div>

<div id="outline-container-org5962f2c" class="outline-2">
<h2 id="org5962f2c">Making it handy to use</h2>
<div class="outline-text-2" id="text-org5962f2c">
<p>
Armed with this I can put together some functions to replace Scotty's <code>get</code>,
<code>post</code>, etc. With a configuration type like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Cfg</span> <span class="org-haskell-constructor">LoggerSet</span> <span class="org-haskell-constructor">ByteString</span>
</pre>
</div>

<p>
The modified <code>get</code> looks like this (Scotty's original is <code>S.get</code>)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">get</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">RoutePattern</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellActionM</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">ChellM</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">get</span> p a <span class="org-haskell-operator">=</span> S.get p <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  r <span class="org-haskell-operator">&lt;-</span> request
  <span class="org-haskell-keyword">let</span> corrId <span class="org-haskell-operator">=</span> getCorrelationId r
  withConfig <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Cfg</span> l <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Cfg</span> l corrId<span class="org-rainbow-delimiters-depth-1">)</span> a
</pre>
</div>

<p>
With this in place I can use the simpler <code>ReaderT Config IO</code> for inner functions
that need to log.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-scotty.html">scotty</a> <a href="https://magnus.therning.org/tag-monad.html">monad</a> </div><div id="archive">
<a href="https://magnus.therning.org/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><!-- org-static-blog-page-postamble --></div>
</body>
</html>
