<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title><![CDATA[Magnus web site - hedgehog]]></title>
<description><![CDATA[Magnus web site - hedgehog]]></description>
<link>https://magnus.therning.org//tag-hedgehog.html</link>
<lastBuildDate>Sun, 14 Mar 2021 07:55:27 +0100</lastBuildDate>
<item>
  <title><![CDATA[Hedgehog on a REST API, part 3]]></title>
  <description><![CDATA[
<p>
In my previous post on using Hedgehog on a REST API, <a href="2019-06-23-000-hedgehog-on-a-rest-api--part-2.html">Hedgehog on a REST API,
part 2</a> I ran the test a few times and adjusted the model to deal with the
incorrect assumptions I had initially made. In particular, I had to adjust how I
modelled the <i>User ID</i>. Because of the simplicity of the API that wasn't too
difficult. However, that kind of completely predictable ID isn't found in all
APIs. In fact, it's not uncommon to have completely random IDs in API (often
they are <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>s).
</p>

<p>
So, I set out to try to deal with that. I'm still using the simple API from the
previous posts, but this time I'm pretending that I can't build the ID into the
model myself, or, put another way, I'm capturing the ID from the responses.
</p>

<div id="outline-container-orgca4a77b" class="outline-2">
<h2 id="orgca4a77b">The model state</h2>
<div class="outline-text-2" id="text-orgca4a77b">
<p>
When capturing the ID it's no longer possible to use a simple <code>Map Int Text</code> for
the state, because I don't actually have the ID until I have an HTTP response.
However, the ID is playing an important role in the constructing of a sequence
of actions. The trick is to use <code>Var Int v</code> instead of an ordinary <code>Int</code>. As I
understand it, and I believe that's a good enough understanding to make use of
Hedgehog possible, is that this way the ID is an opaque blob in the construction
phase, and it's turned into a concrete value during execution. When in the
opaque state it implements enough type classes to be useful for my purposes.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Var</span> <span class="org-haskell-constructor">Int</span> v<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge3fe138" class="outline-2">
<h2 id="orge3fe138">The API calls: add user</h2>
<div class="outline-text-2" id="text-orge3fe138">
<p>
When taking a closer look at the <a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#t:Callback"><code>Callback</code></a> type not all the callbacks will get
the state in the same form, opaque or concrete, and one of them, <code>Update</code>
actually receives the state in both states depending on the phase of execution.
This has the most impact on the add user action. To deal with it there's a need
to rearrange the code a bit, to be specific, <code>commandExecute</code> can no longer
return a tuple of both the ID and the status of the HTTP response because the
update function can't reach into the tuple, which it needs to update the state.
</p>

<p>
That means the <code>commandExecute</code> function will have to do tests too. It <i>is</i> nice
to keep all tests in the callbacks, but by sticking a <code>MonadTest m</code> constraint
on the <code>commandExecute</code> it turns into a nice solution anyway.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m, <span class="org-haskell-type">MonadTest</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                           <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.text <span class="org-rainbow-delimiters-depth-1">(</span>Range.linear <span class="org-highlight-numbers-number">0</span> <span class="org-highlight-numbers-number">42</span><span class="org-rainbow-delimiters-depth-1">)</span> Gen.alpha

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      <span class="org-rainbow-delimiters-depth-1">(</span>s, ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&lt;-</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
        mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
        addReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/users"</span>
        <span class="org-haskell-keyword">let</span> addReq' <span class="org-haskell-operator">=</span> addReq <span class="org-rainbow-delimiters-depth-1">{</span> requestBody <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RequestBodyLBS</span> <span class="org-rainbow-delimiters-depth-2">(</span>encode <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">User</span> <span class="org-highlight-numbers-number">0</span> n<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>
        addResp <span class="org-haskell-operator">&lt;-</span> httpLbs addReq' mgr
        <span class="org-haskell-keyword">let</span> user <span class="org-haskell-operator">=</span> decode <span class="org-rainbow-delimiters-depth-1">(</span>responseBody addResp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">User</span>
        return <span class="org-rainbow-delimiters-depth-1">(</span>responseStatus addResp, user<span class="org-rainbow-delimiters-depth-1">)</span>
      status201 <span class="org-haskell-operator">===</span> s
      assert <span class="org-haskell-operator">$</span> isJust ui
      <span class="org-rainbow-delimiters-depth-1">(</span>userName <span class="org-haskell-operator">&lt;$&gt;</span> ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">Just</span> n
      return <span class="org-haskell-operator">$</span> userId <span class="org-haskell-operator">$</span> fromJust ui

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.insert o n m<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I found that once I'd come around to folding the <code>Ensure</code> callback into the
<code>commandExecute</code> function the rest fell out from the types.
</p>
</div>
</div>

<div id="outline-container-orgf9cfdae" class="outline-2">
<h2 id="orgf9cfdae">The API calls: delete user</h2>
<div class="outline-text-2" id="text-orgf9cfdae">
<p>
The other actions, deleting a user and getting a user, required only minor
changes and the changes were rather similar in both cases.
</p>

<p>
Not the type for the action needs to take a <code>Var Int v</code> instead of just a plain
<code>Int</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Var</span> <span class="org-haskell-constructor">Int</span> v<span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Which in turn affect the implementation of <code>HTraversable</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-haskell-keyword">where</span>
  htraverse f <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> vi<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> htraverse f vi
</pre>
</div>

<p>
Then the changes to the <code>Command</code> mostly comprise use of <a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#v:concrete"><code>concrete</code></a> in places
where the real ID is needed.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                              , <span class="org-haskell-constructor">Require</span> r
                              , <span class="org-haskell-constructor">Ensure</span> e
                              <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
      ks <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.element ks

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> vi<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      delReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"DELETE http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show <span class="org-rainbow-delimiters-depth-1">(</span>concrete vi<span class="org-rainbow-delimiters-depth-1">)</span>
      delResp <span class="org-haskell-operator">&lt;-</span> httpNoBody delReq mgr
      return <span class="org-haskell-operator">$</span> responseStatus delResp

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.delete i m

    r <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> i <span class="org-haskell-operator">`elem`</span> M.keys m

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> r <span class="org-haskell-operator">=</span> r <span class="org-haskell-operator">===</span> status200
</pre>
</div>
</div>
</div>

<div id="outline-container-org24f01b8" class="outline-2">
<h2 id="org24f01b8">Conclusion</h2>
<div class="outline-text-2" id="text-org24f01b8">
<p>
This post concludes my playing around with state machines in Hedgehog for this
time. I certainly hope I find the time to put it to use on some larger API soon.
In particular I'd love to put it to use at work; I think it'd be an excellent
addition to the integration tests we currently have.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hedgehog.html">hedgehog</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[hedgehog]]></category>
  <category><![CDATA[testing]]></category>
  <link>https://magnus.therning.org/2019-08-19-000-hedgehog-on-a-rest-api--part-3.html</link>
  <pubDate>Mon, 19 Aug 2019 12:34:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[Hedgehog on a REST API, part 2]]></title>
  <description><![CDATA[
<p>
This is a short follow-up to <a href="2019-05-30-000-hedgehog-on-a-rest-api.html">Hedgehog on a REST API</a> where I actually run the
tests in that post.
</p>

<div id="outline-container-org27855a2" class="outline-2">
<h2 id="org27855a2">Fixing an issue with the model</h2>
<div class="outline-text-2" id="text-org27855a2">
<p>
The first issue I run into is
</p>

<pre class="example" id="orgdd312b9">
━━━ Main ━━━
  ✗ sequential failed after 18 tests and 1 shrink.

        ┏━━ tst/test-01.hs ━━━
     89 ┃ getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     90 ┃ getUser = Command gen exec [ Require r
     91 ┃                            , Ensure e
     92 ┃                            ]
     93 ┃   where
     94 ┃     gen (State m) = case M.keys m of
     95 ┃       [] -&gt; Nothing
     96 ┃       ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     97 ┃
     98 ┃     exec (GetUser i) = liftIO $ do
     99 ┃       mgr &lt;- newManager defaultManagerSettings
    100 ┃       getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
    101 ┃       getResp &lt;- httpLbs getReq mgr
    102 ┃       let us = decode $ responseBody getResp :: Maybe [User]
    103 ┃       return (status200 == responseStatus getResp, us)
    104 ┃
    105 ┃     r (State m) (GetUser i) = i `elem` M.keys m
    106 ┃
    107 ┃     e _ _ (GetUser _) (r, us) = do
    108 ┃       r === True
    109 ┃       assert $ isJust us
    110 ┃       (length &lt;$&gt; us) === Just 1
        ┃       ^^^^^^^^^^^^^^^^^^^^^^^^^^
        ┃       │ Failed (- lhs =/= + rhs)
        ┃       │ - Just 0
        ┃       │ + Just 1

        ┏━━ tst/test-01.hs ━━━
    118 ┃ prop_seq :: Property
    119 ┃ prop_seq = property $ do
    120 ┃   actions &lt;- forAll $ Gen.sequential (Range.linear 1 10) initialState [addUser, deleteUser, getUser]
        ┃   │ Var 0 = AddUser ""
        ┃   │ Var 1 = GetUser 1
    121 ┃   resetWS
    122 ┃   executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 17) (Seed 2158538972777046104 (-1442908127347265675)) sequential

  ✗ 1 failed.
</pre>

<p>
It's easy to verify this using <a href="https://httpie.org/">httpie</a>:
</p>

<div class="org-src-container">
<pre class="src src-shell">$ http -p b POST :3000/users userId:=<span class="org-highlight-numbers-number">0</span> <span class="org-string">"userName="</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-string">"userId"</span>: <span class="org-highlight-numbers-number">0,</span>
    <span class="org-string">"userName"</span>: <span class="org-string">""</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
$ http -p b GET :3000/users/1
<span class="org-rainbow-delimiters-depth-1">[]</span>
</pre>
</div>

<p>
It's clear that my assumption that <i>User ID</i> starts at 1 is wrong. Luckily
fixing that isn't too difficult. Instead of defining the update function for
<code>addUser</code> as
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">u</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> _o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.insert k n m
  <span class="org-haskell-keyword">where</span>
    k <span class="org-haskell-operator">=</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.keys m<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I define it as
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">u</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> _o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.insert k n m
  <span class="org-haskell-keyword">where</span>
    k <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-highlight-numbers-number">0</span>
      ks <span class="org-haskell-operator">-&gt;</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> ks
</pre>
</div>

<p>
The complete code at this point can be found <a href="https://gist.github.com/8cbbfdb130a173bb51c317df0c00aa15">here</a>.
</p>
</div>
</div>

<div id="outline-container-org9c34f53" class="outline-2">
<h2 id="org9c34f53">Fixing another issue with the model</h2>
<div class="outline-text-2" id="text-org9c34f53">
<p>
With that fix in place another issue with the model shows up
</p>

<pre class="example" id="orga71bb89">
━━━ Main ━━━
  ✗ sequential failed after 74 tests and 2 shrinks.

        ┏━━ tst/test-01.hs ━━━
     91 ┃ getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     92 ┃ getUser = Command gen exec [ Require r
     93 ┃                            , Ensure e
     94 ┃                            ]
     95 ┃   where
     96 ┃     gen (State m) = case M.keys m of
     97 ┃       [] -&gt; Nothing
     98 ┃       ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     99 ┃
    100 ┃     exec (GetUser i) = liftIO $ do
    101 ┃       mgr &lt;- newManager defaultManagerSettings
    102 ┃       getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
    103 ┃       getResp &lt;- httpLbs getReq mgr
    104 ┃       let us = decode $ responseBody getResp :: Maybe [User]
    105 ┃       return (status200 == responseStatus getResp, us)
    106 ┃
    107 ┃     r (State m) (GetUser i) = i `elem` M.keys m
    108 ┃
    109 ┃     e _ _ (GetUser _) (r, us) = do
    110 ┃       r === True
    111 ┃       assert $ isJust us
    112 ┃       (length &lt;$&gt; us) === Just 1
        ┃       ^^^^^^^^^^^^^^^^^^^^^^^^^^
        ┃       │ Failed (- lhs =/= + rhs)
        ┃       │ - Just 0
        ┃       │ + Just 1

        ┏━━ tst/test-01.hs ━━━
    120 ┃ prop_seq :: Property
    121 ┃ prop_seq = property $ do
    122 ┃   actions &lt;- forAll $ Gen.sequential (Range.linear 1 10) initialState [addUser, deleteUser, getUser]
        ┃   │ Var 0 = AddUser ""
        ┃   │ Var 1 = DeleteUser 0
        ┃   │ Var 2 = AddUser ""
        ┃   │ Var 3 = GetUser 0
    123 ┃   resetWS
    124 ┃   executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 73) (Seed 3813043122711576923 (-444438259649958339)) sequential

  ✗ 1 failed.
</pre>

<p>
Again, verifying this using <a href="https://httpie.org/">httpie</a> shows what the issue is
</p>

<div class="org-src-container">
<pre class="src src-shell">$ http -p b POST :3000/users userId:=<span class="org-highlight-numbers-number">0</span> <span class="org-string">"userName="</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-string">"userId"</span>: <span class="org-highlight-numbers-number">0,</span>
    <span class="org-string">"userName"</span>: <span class="org-string">""</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
$ http -p b DELETE :3000/users/0
$ http -p b POST :3000/users userId:=<span class="org-highlight-numbers-number">0</span> <span class="org-string">"userName="</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-string">"userId"</span>: <span class="org-highlight-numbers-number">1,</span>
    <span class="org-string">"userName"</span>: <span class="org-string">""</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
$ http -p b GET :3000/users/0
<span class="org-rainbow-delimiters-depth-1">[]</span>
</pre>
</div>

<p>
In other words, the model assumes that the 0 <i>User ID</i> get's re-used.
</p>

<p>
To fix this I need a bigger change. The central bit is that the state is changed
to keep track of the index more explicitly. That is, it changes from
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
to
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-constructor">Int</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That change does, quite obviously, require a bunch of other changes in the other
functions dealing with the state. The complete file can be viewed <a href="https://gist.github.com/e3c3f4a3c35ab8a529045f90f9f4ba71">here</a>.
</p>
</div>
</div>

<div id="outline-container-org5f32fc1" class="outline-2">
<h2 id="org5f32fc1">All is well, or is it?</h2>
<div class="outline-text-2" id="text-org5f32fc1">
<p>
After this the tests pass, so all is good in the world, right?
</p>

<p>
In the test I defined the <a href="2019-05-30-000-hedgehog-on-a-rest-api.html#MissingReference">property</a> over rather short sequences of commands. What
happens if I increase the (maximum) length of the sequences a bit? Instead using
<code>Range.linear 1 10</code> I'll use <code>Range.linear 1 1000</code>. Well, besides taking
slightly longer to run I get another sequence of commands that triggers an
issue:
</p>

<pre class="example" id="org112d5bd">
━━━ Main ━━━
  ✗ sequential failed after 13 tests and 29 shrinks.

        ┏━━ tst/test-01.hs ━━━
     87 ┃ getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     88 ┃ getUser = Command gen exec [ Require r
     89 ┃                            , Ensure e
     90 ┃                            ]
     91 ┃   where
     92 ┃     gen (State _ m) = case M.keys m of
     93 ┃       [] -&gt; Nothing
     94 ┃       ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     95 ┃
     96 ┃     exec (GetUser i) = liftIO $ do
     97 ┃       mgr &lt;- newManager defaultManagerSettings
     98 ┃       getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
     99 ┃       getResp &lt;- httpLbs getReq mgr
    100 ┃       let us = decode $ responseBody getResp :: Maybe [User]
    101 ┃       return (status200 == responseStatus getResp, us)
    102 ┃
    103 ┃     r (State _ m) (GetUser i) = i `elem` M.keys m
    104 ┃
    105 ┃     e _ _ (GetUser _) (r, us) = do
    106 ┃       r === True
    107 ┃       assert $ isJust us
    108 ┃       (length &lt;$&gt; us) === Just 1
        ┃       ^^^^^^^^^^^^^^^^^^^^^^^^^^
        ┃       │ Failed (- lhs =/= + rhs)
        ┃       │ - Just 0
        ┃       │ + Just 1

        ┏━━ tst/test-01.hs ━━━
    116 ┃ prop_seq :: Property
    117 ┃ prop_seq = property $ do
    118 ┃   actions &lt;- forAll $ Gen.sequential (Range.linear 1 1000) initialState [addUser, deleteUser, getUser]
        ┃   │ Var 0 = AddUser ""
        ┃   │ Var 2 = AddUser ""
        ┃   │ Var 5 = AddUser ""
        ┃   │ Var 7 = AddUser ""
        ┃   │ Var 9 = AddUser ""
        ┃   │ Var 11 = AddUser ""
        ┃   │ Var 20 = AddUser ""
        ┃   │ Var 28 = AddUser ""
        ┃   │ Var 30 = AddUser ""
        ┃   │ Var 32 = AddUser ""
        ┃   │ Var 33 = AddUser ""
        ┃   │ Var 34 = AddUser ""
        ┃   │ Var 37 = AddUser ""
        ┃   │ Var 38 = AddUser ""
        ┃   │ Var 41 = AddUser ""
        ┃   │ Var 45 = AddUser ""
        ┃   │ Var 47 = GetUser 15
    119 ┃   resetWS
    120 ┃   executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 12) (Seed 2976784816810995551 (-47094630645854485)) sequential

  ✗ 1 failed.
</pre>

<p>
That is, after inserting 16 users, we don't see any user when trying to get that
16th user (<i>User ID</i> 15). That's a proper bug in the server.
</p>

<p>
As a matter of fact, this is the bug I put into the server and was hoping to
find. In particular, I wanted <i>hedgehog</i> to find the minimal sequence leading to
this bug.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> Which it clearly has!
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
If you recall from the <a href="2019-05-30-000-hedgehog-on-a-rest-api.html">previous post</a>, I was interested in the integrated
shrinking offered by <i>hedgehog</i>.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hedgehog.html">hedgehog</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[hedgehog]]></category>
  <category><![CDATA[testing]]></category>
  <link>https://magnus.therning.org/2019-06-23-000-hedgehog-on-a-rest-api--part-2.html</link>
  <pubDate>Sun, 23 Jun 2019 12:34:00 +0200</pubDate>
</item>
<item>
  <title><![CDATA[Hedgehog on a REST API]]></title>
  <description><![CDATA[
<p>
Last year I wrote a little bit about my attempt to use <a href="2018-07-14-000-quickcheck-on-a-rest-api.html"><i>QuickCheck</i> to test a
REST API</a>. Back then I got as far as generating test programs, running them, and
validating an in-test model against the observed behaviour of the web service
under test. One thing that I didn't implement was shrinking. I had some ideas,
and got some better ideas in a comment on that post, but I've not taken the time
to actually sit down and work it out. Then, during this spring, a couple of blog
posts from Oskar Wickström (<a href="https://wickstrom.tech/programming/2019/03/02/property-based-testing-in-a-screencast-editor-introduction.html">intro</a>, <a href="https://wickstrom.tech/programming/2019/03/24/property-based-testing-in-a-screencast-editor-case-study-1.html">part 1</a>, <a href="https://wickstrom.tech/programming/2019/04/17/property-based-testing-in-a-screencast-editor-case-study-2.html">part 2</a>) made me aware of another
library for doing property-based testing, <a href="https://hackage.haskell.org/package/hedgehog"><i>hedgehog</i></a>. It differs quite a bit
from <a href="https://hackage.haskell.org/package/QuickCheck"><i>QuickCheck</i></a>, most notably the way it uses to generate random data, and,
this is the bit that made me sit up and pay attention, it has integrated
shrinking.
</p>

<p>
My first plan was to use the same approach as I used with <i>QuickCheck</i>, but
after finding out that there's explicit support for <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#g:5">state machine tests</a>
everything turned out to be a bit easier than I had expected.
</p>

<p>
Well, it still wasn't exactly easy to work out the details, but the <a href="https://github.com/hedgehogqa/haskell-hedgehog/blob/master/hedgehog-example/src/Test/Example/Registry.hs">registry
example</a> in the <i>hedgehog</i> source repo together with a (slightly dated) <a href="https://teh.id.au/posts/2017/07/15/state-machine-testing/index.html">example</a> I
managed to work it out (I think).
</p>

<div id="outline-container-org2176560" class="outline-2">
<h2 id="org2176560">The REST API</h2>
<div class="outline-text-2" id="text-org2176560">
<p>
The API is the same as in the <a href="http://magnus.therning.org/posts/2018-07-14-000-quickcheck-on-a-rest-api.html">post on using <i>QuickCheck</i></a>, with one little
difference, I've been lazy when implementing <code>GET /users/:id</code> and return a list
of users (that makes it easy to represent a missing <code>:id</code>).
</p>


<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Method</th>
<th scope="col" class="org-left">Route</th>
<th scope="col" class="org-left">Example in</th>
<th scope="col" class="org-left">Example out</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>POST</code></td>
<td class="org-left"><code>/users</code></td>
<td class="org-left"><code>{"userId": 0, "userName": "Yogi Berra"}</code></td>
<td class="org-left"><code>{"userId": 42, "userName": "Yogi Berra"}</code></td>
</tr>

<tr>
<td class="org-left"><code>DELETE</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>[0,3,7]</code></td>
</tr>

<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>[{"userId": 42, "userName": "Yogi Berra"}]</code></td>
</tr>

<tr>
<td class="org-left"><code>GET</code></td>
<td class="org-left"><code>/users/:id</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>[]</code> (when there's no user with <code>:id</code>)</td>
</tr>

<tr>
<td class="org-left"><code>POST</code></td>
<td class="org-left"><code>/reset</code></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org1474dbe" class="outline-2">
<h2 id="org1474dbe">The model state</h2>
<div class="outline-text-2" id="text-org1474dbe">
<p>
Just like last time I'm using as simple a model as I think I can get away with,
based on the API above:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">State</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">M.Map</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-constructor">Text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">initialState</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">State</span> v
<span class="org-haskell-definition">initialState</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> M.empty
</pre>
</div>

<p>
That extra <code>v</code> is something that <i>hedgehog</i> requires. Why? I don't really know,
and luckily I don't have to care to make it all work. One thing though, the
language pragma <code>KindSignatures</code> is necessary to use that kind of syntax.
</p>
</div>
</div>

<div id="outline-container-org31f59b7" class="outline-2">
<h2 id="org31f59b7">Representing API calls</h2>
<div class="outline-text-2" id="text-org31f59b7">
<p>
Representing an API call requires three things
</p>

<ol class="org-ol">
<li>a type</li>
<li>an implementation of <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:HTraversable"><code>HTraversable</code></a> for the type</li>
<li>a function producing a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Command"><code>Command</code></a> for the type</li>
</ol>

<p>
I represent the three API calls with these three types
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AddUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-constructor">Text</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-constructor">Int</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">GetUser</span> <span class="org-rainbow-delimiters-depth-1">(</span>v <span class="org-haskell-operator">::</span> <span class="org-haskell-operator">*</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-operator">*</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">GetUser</span> <span class="org-haskell-constructor">Int</span>
  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span>, <span class="org-haskell-constructor">Show</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Again that <code>v</code> pops up, but as with the model state, there's no need to pay any
attention to it.
</p>

<p>
For the implementation of <code>HTraversable</code> I was greatly helped by the <a href="https://github.com/hedgehogqa/haskell-hedgehog/blob/master/hedgehog-example/src/Test/Example/Registry.hs">registry
example</a>. Their implementations are fairly straight forward, which is a good
thing since the need for them is internal to <i>hedgehog</i>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">AddUser</span> <span class="org-haskell-keyword">where</span>
  htraverse <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> pure n

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">DeleteUser</span> <span class="org-haskell-keyword">where</span>
  htraverse <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> pure i

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">HTraversable</span> <span class="org-haskell-type">GetUser</span> <span class="org-haskell-keyword">where</span>
  htraverse <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">GetUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">GetUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> pure i
</pre>
</div>

<p>
Once these two things are out of the way we get to the meat of the
implementation of the API calls, a function creating a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Command"><code>Command</code></a> instance for
each type of API call. The exact type for all three functions will be
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">MonadGen</span> n, <span class="org-haskell-constructor">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-constructor">Command</span> n m <span class="org-haskell-constructor">State</span>
</pre>
</div>

<p>
which doesn't say a whole lot, I think. After reading the documentation I found
it a little clearer, but the two examples, <a href="https://teh.id.au/posts/2017/07/15/state-machine-testing/index.html">state machine testing</a> and <a href="https://github.com/hedgehogqa/haskell-hedgehog/blob/master/hedgehog-example/src/Test/Example/Registry.hs">registry</a>,
was what cleared things up for me.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> In an attempt at being overly explicit I
wrote these functions in the same style. This is what it ended up looking like
for the <code>AddUser</code> type:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">addUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                           , <span class="org-haskell-constructor">Ensure</span> e
                           <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">AddUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.text <span class="org-rainbow-delimiters-depth-1">(</span>Range.linear <span class="org-highlight-numbers-number">0</span> <span class="org-highlight-numbers-number">42</span><span class="org-rainbow-delimiters-depth-1">)</span> Gen.alpha

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      addReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/users"</span>
      <span class="org-haskell-keyword">let</span> addReq' <span class="org-haskell-operator">=</span> addReq <span class="org-rainbow-delimiters-depth-1">{</span> requestBody <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">RequestBodyLBS</span> <span class="org-rainbow-delimiters-depth-2">(</span>encode <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">User</span> <span class="org-highlight-numbers-number">0</span> n<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>
      addResp <span class="org-haskell-operator">&lt;-</span> httpLbs addReq' mgr
      <span class="org-haskell-keyword">let</span> user <span class="org-haskell-operator">=</span> decode <span class="org-rainbow-delimiters-depth-1">(</span>responseBody addResp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-type">User</span>
      return <span class="org-rainbow-delimiters-depth-1">(</span>responseStatus addResp, user<span class="org-rainbow-delimiters-depth-1">)</span>

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> _o <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.insert k n m
      <span class="org-haskell-keyword">where</span>
        k <span class="org-haskell-operator">=</span> succ <span class="org-haskell-operator">$</span> foldl max <span class="org-highlight-numbers-number">0</span> <span class="org-rainbow-delimiters-depth-1">(</span>M.keys m<span class="org-rainbow-delimiters-depth-1">)</span>

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">AddUser</span> n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>r, ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      r <span class="org-haskell-operator">===</span> status201
      assert <span class="org-haskell-operator">$</span> isJust ui
      <span class="org-rainbow-delimiters-depth-1">(</span>userName <span class="org-haskell-operator">&lt;$&gt;</span> ui<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">Just</span> n
</pre>
</div>

<p>
Piece by piece:
</p>

<ol class="org-ol">
<li><code>gen</code> is the generator of data. It takes one argument, the current state, but
for <code>AddUser</code> I have no use for it. The user name is generated using a
generator for <code>Text</code>, and rather arbitrarily I limit the names to 42
characters.</li>
<li><code>exec</code> is the action that calls the web service. Here I'm using <a href="https://hackage.haskell.org/package/http-client">http-client</a>
to make the call and <a href="https://hackage.haskell.org/package/aeson">aeson</a> to parse the response into a <code>User</code>. It produces
<i>output</i>.</li>
<li><code>u</code> is a function for updating the model state. It's given the current state,
the command and the <i>output</i>. All I need to to do for <code>AddUser</code> is to pick a
<code>userId</code> and associate it with the generated name.</li>
<li><code>e</code> is a function for checking post-conditions, in other words checking
properties that must hold after <code>exec</code> has run and the state has been
updated. It's given four arguments, the previous state, the updated state,
the command and the <i>output</i>. The tests here are on the HTTP response code
and the returned user name. I think that will do for the time being.</li>
</ol>

<p>
The function for <code>DeleteUser</code> follows the same pattern
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">deleteUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Update</span> u
                              , <span class="org-haskell-constructor">Require</span> r
                              , <span class="org-haskell-constructor">Ensure</span> e
                              <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
      ks <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.element ks

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      delReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"DELETE http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show i
      delResp <span class="org-haskell-operator">&lt;-</span> httpNoBody delReq mgr
      return <span class="org-haskell-operator">$</span> responseStatus delResp

    u <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">State</span> <span class="org-haskell-operator">$</span> M.delete i m

    r <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> i <span class="org-haskell-operator">`elem`</span> M.keys m

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">DeleteUser</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> r <span class="org-haskell-operator">=</span> r <span class="org-haskell-operator">===</span> status200
</pre>
</div>

<p>
I think only two pieces need further explanation:
</p>

<ol class="org-ol">
<li><code>gen</code> only returns a <code>DeleteUser</code> with an index actually present in the model
state. If there are no users in the model then <code>Nothing</code> is returned. As far
as I understand that means that generated programs will only make calls to
delete existing users.<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup></li>
<li><code>r</code> is a pre-condition that programs only delete users that exist. At first I
had skipped this pre-condition, thinking that it'd be enough to have <code>gen</code>
only create delete calls for existing users. However, after reading the
documentation of <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Command"><code>Command</code></a> and <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Callback"><code>Callback</code></a> a bit more closely I realised that
I might need a pre-condition to make sure that this holds true also while
shrinking.</li>
</ol>

<p>
The final function, for <code>GetUser</code> requires no further explanation so I only
present it here
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">getUser</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">MonadGen</span> n, <span class="org-haskell-type">MonadIO</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Command</span> n m <span class="org-haskell-type">State</span>
<span class="org-haskell-definition">getUser</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Command</span> gen exec <span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-haskell-constructor">Require</span> r
                           , <span class="org-haskell-constructor">Ensure</span> e
                           <span class="org-rainbow-delimiters-depth-1">]</span>
  <span class="org-haskell-keyword">where</span>
    gen <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> M.keys m <span class="org-haskell-keyword">of</span>
      <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Nothing</span>
      ks <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">GetUser</span> <span class="org-haskell-operator">&lt;$&gt;</span> Gen.element ks

    exec <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">GetUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
      mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
      getReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-haskell-operator">$</span> <span class="org-string">"GET http://localhost:3000/users/"</span> <span class="org-haskell-operator">++</span> show i
      getResp <span class="org-haskell-operator">&lt;-</span> httpLbs getReq mgr
      <span class="org-haskell-keyword">let</span> us <span class="org-haskell-operator">=</span> decode <span class="org-haskell-operator">$</span> responseBody getResp <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">User</span><span class="org-rainbow-delimiters-depth-1">]</span>
      return <span class="org-rainbow-delimiters-depth-1">(</span>status200 <span class="org-haskell-operator">==</span> responseStatus getResp, us<span class="org-rainbow-delimiters-depth-1">)</span>

    r <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">State</span> m<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">GetUser</span> i<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> i <span class="org-haskell-operator">`elem`</span> M.keys m

    e <span class="org-haskell-keyword">_</span> <span class="org-haskell-keyword">_</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">GetUser</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>r, us<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
      r <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">True</span>
      assert <span class="org-haskell-operator">$</span> isJust us
      <span class="org-rainbow-delimiters-depth-1">(</span>length <span class="org-haskell-operator">&lt;$&gt;</span> us<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">===</span> <span class="org-haskell-constructor">Just</span> <span class="org-highlight-numbers-number">1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org17f0c42" class="outline-2">
<h2 id="org17f0c42">The property and test</h2>
<div class="outline-text-2" id="text-org17f0c42">
<p>
It looks like there are two obvious top-level properties
</p>

<ol class="org-ol">
<li>the web service works as expected when all calls are made one at a time
(sequential), and</li>
<li>the web service works as expected when all calls are made in parallel.</li>
</ol>

<p>
<i>Hedgehog</i> provides two pairs of functions for this
</p>

<ol class="org-ol">
<li>a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog-Gen.html#v:sequential"><code>sequential</code> generator</a> with <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#v:executeSequential"><code>executeSequential</code></a>, and</li>
<li>a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog-Gen.html#v:parallel"><code>parallel</code> generator</a> with <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#v:executeParallel"><code>executeParallel</code></a>.</li>
</ol>

<p>
I started with the former only
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">prop_seq</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Property</span>
<span class="org-haskell-definition">prop_seq</span> <span class="org-haskell-operator">=</span> property <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  actions <span class="org-haskell-operator">&lt;-</span> forAll <span class="org-haskell-operator">$</span> Gen.sequential <span class="org-rainbow-delimiters-depth-1">(</span>Range.linear <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">10</span><span class="org-rainbow-delimiters-depth-1">)</span> initialState <span class="org-rainbow-delimiters-depth-1">[</span>addUser, deleteUser, getUser<span class="org-rainbow-delimiters-depth-1">]</span>
  resetWS
  executeSequential initialState actions
</pre>
</div>

<p>
This first creates a generator of programs of at most length 10<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>, then
turning that into a <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:Sequential"><code>Sequential</code></a> which can be passed to <a href="https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#v:executeSequential"><code>executeSequential</code></a> to
turn into a <a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#t:Property"><code>Property</code></a>.
</p>

<p>
The function <code>resetWS</code> clears out the web service to make sure that the tests
start with a clean slate each time. Its definition is
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">resetWS</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">resetWS</span> <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
  mgr <span class="org-haskell-operator">&lt;-</span> newManager defaultManagerSettings
  resetReq <span class="org-haskell-operator">&lt;-</span> parseRequest <span class="org-string">"POST http://localhost:3000/reset"</span>
  void <span class="org-haskell-operator">$</span> httpNoBody resetReq mgr
</pre>
</div>

<p>
The final bit is the <code>main</code> function, which I wrote like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  res <span class="org-haskell-operator">&lt;-</span> checkSequential <span class="org-haskell-operator">$</span> <span class="org-haskell-constructor">Group</span> <span class="org-string">"Main"</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"sequential"</span>, prop_seq<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
  unless res exitFailure
</pre>
</div>

<p>
That is, first run the property sequentially (<a href="https://hackage.haskell.org/package/hedgehog-0.5.3/docs/Hedgehog.html#v:checkSequential"><code>checkSequential</code></a>) and if that
fails exit with failure.
</p>
</div>
</div>

<div id="outline-container-orgde41804" class="outline-2">
<h2 id="orgde41804">Running the test</h2>
<div class="outline-text-2" id="text-orgde41804">
<p>
When running the test fails and gives me a program that breaks the property, and
exactly what fails:
</p>

<pre class="example" id="orgcb6c8d9">
━━━ Main ━━━
  ✗ sequential failed after 13 tests and 1 shrink.

        ┏━━ tst/test-01.hs ━━━
     89 ┃ getUser :: (MonadGen n, MonadIO m) =&gt; Command n m State
     90 ┃ getUser = Command gen exec [ Require r
     91 ┃                            , Ensure e
     92 ┃                            ]
     93 ┃   where
     94 ┃     gen (State m) = case M.keys m of
     95 ┃       [] -&gt; Nothing
     96 ┃       ks -&gt; Just $ GetUser &lt;$&gt; Gen.element ks
     97 ┃
     98 ┃     exec (GetUser i) = liftIO $ do
     99 ┃       mgr &lt;- newManager defaultManagerSettings
    100 ┃       getReq &lt;- parseRequest $ "GET http://localhost:3000/users/" ++ show i
    101 ┃       getResp &lt;- httpLbs getReq mgr
    102 ┃       let us = decode $ responseBody getResp :: Maybe [User]
    103 ┃       return (status200 == responseStatus getResp, us)
    104 ┃
    105 ┃     r (State m) (GetUser i) = i `elem` M.keys m
    106 ┃
    107 ┃     e _ _ (GetUser _) (r, us) = do
    108 ┃       r === True
    109 ┃       assert $ isJust us
    110 ┃       (length &lt;$&gt; us) === Just 1
        ┃       ^^^^^^^^^^^^^^^^^^^^^^^^^^
        ┃       │ Failed (- lhs =/= + rhs)
        ┃       │ - Just 0
        ┃       │ + Just 1

        ┏━━ tst/test-01.hs ━━━
    118 ┃ prop_seq :: Property
    119 ┃ prop_seq = property $ do
    120 ┃   actions &lt;- forAll $ Gen.sequential (Range.linear 1 10) initialState [addUser, deleteUser, getUser]
        ┃   │ Var 0 = AddUser ""
        ┃   │ Var 1 = GetUser 1
    121 ┃   resetWS
    122 ┃   executeSequential initialState actions

    This failure can be reproduced by running:
    &gt; recheck (Size 12) (Seed 6041776208714975061 (-2279196309322888437)) sequential

  ✗ 1 failed.
</pre>

<p>
My goodness, that is pretty output!
</p>

<p>
Anyway, I'd say that the failing program has been shrunk to be minimal so I'd
say that all in all this is a big step up from what I had earlier. Sure, using
the <i>hedgehog</i> state machine API is slightly involved, but once worked out I
find it fairly straight-forward and it most likely is written by people much
more knowledgable than me and better than anything I could produce. Having to
use generators explicitly (the <i>hedgehog</i> way) is neither easier nor more
complicated than defining a few type class instances (the <i>QuickCheck</i> way).
Finally, the integrated shrinking is rather brilliant and <i>not</i> having to
implement that myself is definitely a big benefit.
</p>

<p>
Now I only have to fix the errors in the web service that the test reveal. This
post is already rather long, so I'll keep that for a future post.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
There is still one thing that's unclear to me though, and that's how to
get to the output in an update function.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Put another way, programs will never test how the web service behaves
when asking for non-existing users. I think that, if I want to test that, I'll
opt for using a separate API call type for it.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
At least that's my understanding of the impact of <code>Range.linear 1 10</code>.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hedgehog.html">hedgehog</a> <a href="https://magnus.therning.org/tag-testing.html">testing</a> </div>]]></description>
  <category><![CDATA[haskell]]></category>
  <category><![CDATA[hedgehog]]></category>
  <category><![CDATA[testing]]></category>
  <link>https://magnus.therning.org/2019-05-30-000-hedgehog-on-a-rest-api.html</link>
  <pubDate>Thu, 30 May 2019 12:34:00 +0200</pubDate>
</item>
</channel>
</rss>
