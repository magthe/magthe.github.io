<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://magnus.therning.org/feed.xml"
      title="RSS feed for https://magnus.therning.org/">
<title>Magnus web site</title>
<meta name="author" content="Magnus Therning"><meta name="referrer" content="no-referrer"><link href= "static/style.css" rel="stylesheet" type="text/css" /><link href= "static/htmlize.css" rel="stylesheet" type="text/css" /><link href= "static/extra_style.css" rel="stylesheet" type="text/css" /></head>
<body>
<div id="preamble" class="status"><div class="nav-bar"><a class="nav-link" href="./index.html">Top</a><a class="nav-link" href="./archive.html">Archive</a><a class="nav-link align-right" href="./feed.xml"><img src="static/rss-feed-icon.png" style="height: 24px;" /></a></div></div>
<div id="content">
<header class="site-header" role="banner"><h1 class="title">Magnus web site</h1><h2 class="subtitle">Random stuff</h2></header>
<div class="post-date">30 Mar 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-03-30-more-on-tree-sitter-and-consult.html">More on tree-sitter and consult</a></h1>
<p>
Here's a few things that I've gotten help with figuring out during the last few
days. Both things are related to my playing with tree-sitter that I've written
about earlier, <a href="https://magnus.therning.org/2023-03-22-making-an-emacs-major-mode-for-cabal-using-tree-sitter.html">here</a> and <a href="https://magnus.therning.org/2023-03-27-cabal,-tree-sitter,-and-consult.html">here</a>.
</p>

<p>
You might also be interested in the two repositories where the full code
is. (I've linked to the specific commits as of this writing.)
</p>

<ul class="org-ul">
<li><a href="https://gitlab.com/magus/my-emacs-pkgs/-/tree/e739d1035f3d505f2495309126d891ca6b18cab8/my-cabal-mode">My Cabal mode</a></li>
<li><a href="https://gitlab.com/magus/tree-sitter-cabal/-/tree/7d5fa6887ae05a0b06d046f1e754c197c8ad869b">tree-sitter-cabal</a></li>
</ul>

<div id="outline-container-org8a27db9" class="outline-2">
<h2 id="org8a27db9">Anonymous nodes and matching in tree-sitter</h2>
<div class="outline-text-2" id="text-org8a27db9">
<p>
In the grammar for Cabal I have a rule for sections that like this
</p>

<div class="org-src-container">
<pre class="src src-javascript">sections: $ =&gt; repeat1<span class="org-rainbow-delimiters-depth-1">(</span>choice<span class="org-rainbow-delimiters-depth-2">(</span>
    $.benchmark,
    $.common,
    $.executable,
    $.flag,
    $.library,
    $.source_repository,
    $.test_suite,
<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>,
</pre>
</div>

<p>
where each section followed this pattern
</p>

<div class="org-src-container">
<pre class="src src-javascript">benchmark: $ =&gt; seq<span class="org-rainbow-delimiters-depth-1">(</span>
    repeat<span class="org-rainbow-delimiters-depth-2">(</span>$.comment<span class="org-rainbow-delimiters-depth-2">)</span>,
    <span class="org-string">'benchmark'</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'name'</span>, $.section_name<span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'properties'</span>, $.property_block<span class="org-rainbow-delimiters-depth-2">)</span>,
<span class="org-rainbow-delimiters-depth-1">)</span>,
</pre>
</div>

<p>
This made it a little bit difficult to capture the relevant parts of each
section to implement <code>consult-cabal</code>. I thought a pattern like this ought to
work
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>cabal
 <span class="org-rainbow-delimiters-depth-2">(</span>sections
  <span class="org-rainbow-delimiters-depth-3">(</span>_ _ @type
     name: <span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span>? @name<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
but it didn't; I got way too many things captured in <code>type</code>. Clearly I had
misunderstood something about the wildcards, or the query syntax. I attempted to
add a field name to the anonymous node, i.e. change the sections rules like this
</p>

<div class="org-src-container">
<pre class="src src-javascript">benchmark: $ =&gt; seq<span class="org-rainbow-delimiters-depth-1">(</span>
    repeat<span class="org-rainbow-delimiters-depth-2">(</span>$.comment<span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'type'</span>, <span class="org-string">'benchmark'</span><span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'name'</span>, $.section_name<span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'properties'</span>, $.property_block<span class="org-rainbow-delimiters-depth-2">)</span>,
<span class="org-rainbow-delimiters-depth-1">)</span>,
</pre>
</div>

<p>
It was accepted by <code>tree-sitter generate</code>, but the field <code>type</code> was nowhere to
be found in the parse tree.
</p>

<p>
Then I changed the query to list the anonymous nodes explicitly, like this
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>cabal
 <span class="org-rainbow-delimiters-depth-2">(</span>sections
  <span class="org-rainbow-delimiters-depth-3">(</span>_ [<span class="org-string">"benchmark"</span> <span class="org-string">"common"</span> <span class="org-string">"executable"</span> ...] @type
     name: <span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span>? @name<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That worked, but listing all the sections like that in the query didn't sit
right with me.
</p>

<p>
Luckily there's a <a href="https://github.com/tree-sitter/tree-sitter/discussions">discussions area in tree-sitters GitHub</a> so a <a href="https://github.com/tree-sitter/tree-sitter/discussions/2161">fairly short
discussion</a> later I had answers to why my query behaved like it did and a
solution that would allow me to not list all the section types in the query. The
trick is to wrap the string in a call to <code>alias</code> to make it a named node. After
that it works to add a field name to it as well, of course. The section rules
now look like this
</p>

<div class="org-src-container">
<pre class="src src-javascript">benchmark: $ =&gt; seq<span class="org-rainbow-delimiters-depth-1">(</span>
    repeat<span class="org-rainbow-delimiters-depth-2">(</span>$.comment<span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'type'</span>, alias<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">'benchmark'</span>, $.section_type<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'name'</span>, $.section_name<span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'properties'</span>, $.property_block<span class="org-rainbow-delimiters-depth-2">)</span>,
<span class="org-rainbow-delimiters-depth-1">)</span>,
</pre>
</div>

<p>
and the final query looks like this
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>cabal
 <span class="org-rainbow-delimiters-depth-2">(</span>sections
  <span class="org-rainbow-delimiters-depth-3">(</span>_
   type: <span class="org-rainbow-delimiters-depth-4">(</span>section_type<span class="org-rainbow-delimiters-depth-4">)</span> @type
   name: <span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span>? @name<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
With that in place I could improve on the function that collects all the items
for <code>consult-cabal</code> so it now show the section's type and name instead of the
string representation of the tree-sitter node.
</p>
</div>
</div>

<div id="outline-container-orgf3cee92" class="outline-2">
<h2 id="orgf3cee92">State in a <code>consult</code> source for preview of lines in a buffer</h2>
<div class="outline-text-2" id="text-orgf3cee92">
<p>
I was struggling with figuring out how to make a good <i>state</i> function in order
to preview the items in <code>consult-cabal</code>. The <a href="https://github.com/minad/consult">GitHub repo for <code>consult</code></a> doesn't
have discussions enabled, but after a <a href="https://github.com/minad/consult/issues/780">discussion in an issue</a> I'd arrived at a
<i>state</i> function that works very well.
</p>

<p>
The state function makes use of functions in <code>consult</code> and looks like this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">consult-cabal--state</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Create a state function for previewing sections."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>state <span class="org-rainbow-delimiters-depth-5">(</span>consult--jump-state<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>action cand<span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">when</span> cand
        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-rainbow-delimiters-depth-7">(</span>pos <span class="org-rainbow-delimiters-depth-8">(</span>get-text-property 0 'section-pos cand<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
          <span class="org-rainbow-delimiters-depth-6">(</span>funcall state action pos<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The trick here was to figure out how the function returned by
<code>consult--jump-state</code> actually works. On the surface it looks like it takes an
<i>action</i> and a <i>candidate</i>, <code>(lambda (action cand) ...)</code>. However, the argument
<code>cand</code> shouldn't be the currently selected item, but rather a postion (ideally a
<code>marker</code>), so I had to attach another text property on the items (<code>section-pos</code>,
which is fetched in the inner lambda). This position is then what's passed to
the function returned by <code>consult--jump-state</code>.
</p>

<p>
In hindsight it seems so easy, but I was struggling with this for an entire
evening before finally asking the question the morning after.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-consult.html">consult</a> <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-tree-sitter.html">tree-sitter</a> </div>

<div class="post-date">27 Mar 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-03-27-cabal,-tree-sitter,-and-consult.html">Cabal, tree-sitter, and consult</a></h1>
<p>
After my <a href="https://magnus.therning.org/2023-03-22-making-an-emacs-major-mode-for-cabal-using-tree-sitter.html">last post</a> I thought I'd move on to implement the rest of the functions
in <a href="https://github.com/haskell/haskell-mode">haskell-mode</a>'s major mode for Cabal, functions like
<code>haskell-cabal-goto-library-section</code> and
<code>haskell-cabal-goto-executable-section</code>.  Then I realised that what <i>I</i> really
want is a way to quickly jump to any section, that is, I want <code>consult-cabal</code>!
</p>

<p>
What follows is very much a work-in-progress, but hopefully it'll show enough
promise.
</p>

<div id="outline-container-org31e7014" class="outline-2">
<h2 id="org31e7014">Listing the sections</h2>
<div class="outline-text-2" id="text-org31e7014">
<p>
As I have a <code>tree-sitter</code> parse tree to hand it is fairly easy to fetch all the
nodes corresponding to sections.  Since the <a href="https://magnus.therning.org/2023-03-22-making-an-emacs-major-mode-for-cabal-using-tree-sitter.html">last post</a> I've made some
improvements to the parser and now the parse tree looks like this (I can
recommend the function <code>treesit-explore-mode</code> to expore the parse tree, I've
found it invaluable ever since I realised it existed)
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>cabal
 ...
 <span class="org-rainbow-delimiters-depth-2">(</span>properties ...<span class="org-rainbow-delimiters-depth-2">)</span>
 <span class="org-rainbow-delimiters-depth-2">(</span>sections
  <span class="org-rainbow-delimiters-depth-3">(</span>common common <span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span> ...<span class="org-rainbow-delimiters-depth-3">)</span>
  <span class="org-rainbow-delimiters-depth-3">(</span>library library ...<span class="org-rainbow-delimiters-depth-3">)</span>
  <span class="org-rainbow-delimiters-depth-3">(</span>executable executable <span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span> ...<span class="org-rainbow-delimiters-depth-3">)</span>
  ...<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That is, all the <i>sections</i> are children of the node called <code>sections</code>.
</p>

<p>
The function to use for fetching all the nodes is <code>treesit-query-capture</code>, it
needs a node to start on, which this case should be the full parse tree,
i.e. <code>(treesit-buffer-root-node 'cabal)</code> and a query string.  Given the
structure of the parse tree, and that I want to capture all children of
<code>sections</code>, a query string like this one works
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-string">"(cabal (sections (_)* @section))"</span>
</pre>
</div>

<p>
Finally, by default <code>treesit-query-capture</code> returns a list of tuples of the form
<code>(&lt;capture&gt; . &lt;node&gt;)</code>, but in this case I only want the list of nodes, so the
full call will look like this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>treesit-query-capture <span class="org-rainbow-delimiters-depth-2">(</span>treesit-buffer-root-node 'cabal<span class="org-rainbow-delimiters-depth-2">)</span>
                       <span class="org-string">"(cabal (sections (_)* @section))"</span>
                       nil nil t<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcead32c" class="outline-2">
<h2 id="orgcead32c">Hooking it up to consult</h2>
<div class="outline-text-2" id="text-orgcead32c">
<p>
As I envision adding more things to jump to in the future, I decided to make use
of <code>consult--multi</code>. That in turn means I need to define a "source" for the
sections. After a bit of digging and rummaging in the <a href="https://github.com/minad/consult/">consult source</a> I put
together this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defvar</span> <span class="org-variable-name">consult-cabal--source-section</span>
  `<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-builtin">:name</span> <span class="org-string">"Sections"</span>
    <span class="org-builtin">:category</span> location
    <span class="org-builtin">:action</span> ,#'consult-cabal--section-action
    <span class="org-builtin">:items</span> ,#'consult-cabal--section-items<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Definition of source for Cabal sections."</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
which means I need two functions, <code>consult-cabal--section-action</code> and
<code>consult-cabal--section-items</code>. I started with the latter.
</p>
</div>

<div id="outline-container-org72b3791" class="outline-3">
<h3 id="org72b3791">Getting section nodes as items for consult</h3>
<div class="outline-text-3" id="text-org72b3791">
<p>
It took me a while to work understand how this would ever be able to work. The
function that <code>:items</code> point to must return a list of strings, but how would I
ever be able to use just a string to jump to the correct location?
</p>

<p>
The solution is in a comment in the documentation of <code>consult--multi</code>:
</p>

<blockquote>
<p>
:items - List of strings to select from or function returning
 list of strings.  Note that the strings can use text properties
 to carry metadata, which is then available to the :annotate,
 :action and :state functions.
</p>
</blockquote>

<p>
I'd never come across <i>text properties</i> in Emacs before, so at first I
completely missed those two words. Once I'd looked up the concept in the
documentation everything fell into place. The function
<code>consult-cabal--section-items</code> would simply attach the relevant node as a text
property to the strings in the list.
</p>

<p>
My current version, obviously a work-in-progress, takes a list of nodes and
turns them naïvely into a string and attaches the node. I split it into two functions, like this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">consult-cabal--section-to-string</span> <span class="org-rainbow-delimiters-depth-2">(</span>section<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Convert a single SECTION node to a string."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>propertize <span class="org-rainbow-delimiters-depth-3">(</span>format <span class="org-string">"%S"</span> section<span class="org-rainbow-delimiters-depth-3">)</span>
              <span class="org-builtin">:treesit-node</span> section<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">consult-cabal--section-items</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Fetch all sections as a list of strings ."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>section-nodes <span class="org-rainbow-delimiters-depth-5">(</span>treesit-query-capture <span class="org-rainbow-delimiters-depth-6">(</span>treesit-buffer-root-node 'cabal<span class="org-rainbow-delimiters-depth-6">)</span>
                                              <span class="org-string">"(cabal (sections (_)* @section))"</span>
                                              nil nil t<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>mapcar #'consult-cabal--section-to-string section-nodes<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org83dad10" class="outline-3">
<h3 id="org83dad10">Implementing the action</h3>
<div class="outline-text-3" id="text-org83dad10">
<p>
The action function is called with the selected item, i.e. with the string and
its properties. That means, to jump to the selected section the function needs
to extract the node property, <code>:treesit-node</code>, and jump to the start of it. the
function to use is <code>get-text-property</code>, and as all characters in the string will
have to property I just picked the first one. The jumping itself I copied from
the navigation functions I'd written before.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">consult-cabal--section-action</span> <span class="org-rainbow-delimiters-depth-2">(</span>item<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Go to the section referenced by ITEM."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when-let*</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>node <span class="org-rainbow-delimiters-depth-5">(</span>get-text-property 0 <span class="org-builtin">:treesit-node</span> item<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>new-pos <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-start node<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>goto-char new-pos<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb0e4e64" class="outline-3">
<h3 id="orgb0e4e64">Tying it together with <code>consult--multi</code></h3>
<div class="outline-text-3" id="text-orgb0e4e64">
<p>
The final function, <code>consult-cabal</code>, looks like this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">consult-cabal</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Choose a Cabal construct and jump to it."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">interactive</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>consult--multi '<span class="org-rainbow-delimiters-depth-3">(</span>consult-cabal--source-section<span class="org-rainbow-delimiters-depth-3">)</span>
                  <span class="org-builtin">:sort</span> nil<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8f2653b" class="outline-2">
<h2 id="org8f2653b">Conclusions and where to find the code</h2>
<div class="outline-text-2" id="text-org8f2653b">
<p>
The end result works as intended, but it's very rough. I'll try to improve it a
bit more. In particular I want
</p>

<ol class="org-ol">
<li>better strings - <code>(format "%S" node)</code> is all right to start with, but in the
long run I want strings that describe the sections, and</li>
<li>preview as I navigate between items - AFAIU this is what the <code>:state</code> field
is for, but I still haven't looked into how it works.</li>
</ol>

<p>
The source can be found <a href="https://gitlab.com/magus/my-emacs-pkgs/-/blob/main/my-cabal-mode/consult-cabal.el">here</a>.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-cabal.html">cabal</a> <a href="https://magnus.therning.org/tag-consult.html">consult</a> <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-tree-sitter.html">tree-sitter</a> </div>

<div class="post-date">22 Mar 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-03-22-making-an-emacs-major-mode-for-cabal-using-tree-sitter.html">Making an Emacs major mode for Cabal using tree-sitter</a></h1>
<p>
A few days ago I <a href="https://www.reddit.com/r/haskell/comments/11uvhsk/cabal_grammar_for_treesitter_at_least_the/">posted on r/haskell</a> that I'm attempting to put together a <a href="https://cabal.readthedocs.io/en/stable/index.html">Cabal</a>
grammar for <a href="https://tree-sitter.github.io/tree-sitter/">tree-sitter</a>.  Some things are still missing, but it covers enough to
start doing what I initially intended: experiment with writing an alternative
Emacs major mode for Cabal.
</p>

<p>
The documentation for the tree-sitter integration is very nice, and several of
the major modes already have tree-sitter variants, called <code>X-ts-mode</code> where <code>X</code>
is e.g. <code>python</code>, so putting together the beginning of a major mode wasn't too
much work.
</p>

<div id="outline-container-orgaa93cd2" class="outline-2">
<h2 id="orgaa93cd2">Configuring Emacs</h2>
<div class="outline-text-2" id="text-orgaa93cd2">
<p>
First off I had to make sure the parser for Cabal was installed. The snippet for
that looks like this<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">use-package</span> <span class="org-constant">treesit</span>
  <span class="org-builtin">:straight</span> nil
  <span class="org-builtin">:ensure</span> nil
  <span class="org-builtin">:commands</span> <span class="org-rainbow-delimiters-depth-2">(</span>treesit-install-language-grammar<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-builtin">:init</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq</span> treesit-language-source-alist
        '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>cabal . <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"https://gitlab.com/magus/tree-sitter-cabal.git"</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
With that in place the parser is installed using <code>M-x
treesit-install-language-grammar</code> and choosing <code>cabal</code>.
</p>

<p>
After that I removed my configuration for <code>haskell-mode</code> and added the following
snippet to get my own major mode into my setup.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">use-package</span> <span class="org-constant">my-cabal-mode</span>
  <span class="org-builtin">:straight</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-builtin">:type</span> git
             <span class="org-builtin">:repo</span> <span class="org-string">"git@gitlab.com:magus/my-emacs-pkgs.git"</span>
             <span class="org-builtin">:branch</span> <span class="org-string">"main"</span>
             <span class="org-builtin">:files</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-builtin">:defaults</span> <span class="org-string">"my-cabal-mode/*el"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge3a4a9a" class="outline-2">
<h2 id="orge3a4a9a">The major mode and font-locking</h2>
<div class="outline-text-2" id="text-orge3a4a9a">
<p>
The built-in elisp documentation actually has a section on writing a major mode
with tree-sitter, so it was easy to get started. Setting up the font-locking
took a bit of trial-and-error, but once I had comments looking the way I wanted
it was easy to add to the setup. Oh, and yes, there's a section on font-locking
with tree-sitter in the documentation too. At the moment it looks like this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defvar</span> <span class="org-variable-name">cabal--treesit-font-lock-setting</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>treesit-font-lock-rules
   <span class="org-builtin">:feature</span> 'comment
   <span class="org-builtin">:language</span> 'cabal
   '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>comment<span class="org-rainbow-delimiters-depth-4">)</span> @font-lock-comment-face<span class="org-rainbow-delimiters-depth-3">)</span>

   <span class="org-builtin">:feature</span> 'cabal-version
   <span class="org-builtin">:language</span> 'cabal
   '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>cabal_version _<span class="org-rainbow-delimiters-depth-4">)</span> @font-lock-constant-face<span class="org-rainbow-delimiters-depth-3">)</span>

   <span class="org-builtin">:feature</span> 'field-name
   <span class="org-builtin">:language</span> 'cabal
   '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>field_name<span class="org-rainbow-delimiters-depth-4">)</span> @font-lock-keyword-face<span class="org-rainbow-delimiters-depth-3">)</span>

   <span class="org-builtin">:feature</span> 'section-name
   <span class="org-builtin">:language</span> 'cabal
   '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span> @font-lock-variable-name-face<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Tree-sitter font-lock settings."</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter">;;;</span><span class="org-comment">###</span><span class="org-comment"><span class="org-warning">autoload</span></span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">define-derived-mode</span> <span class="org-function-name">my-cabal-mode</span> fundamental-mode <span class="org-string">"My Cabal"</span>
  <span class="org-doc">"My mode for Cabal files"</span>

  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when</span> <span class="org-rainbow-delimiters-depth-3">(</span>treesit-ready-p 'cabal<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>treesit-parser-create 'cabal<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">set up treesit</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">setq-local</span> treesit-font-lock-feature-list
                '<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-rainbow-delimiters-depth-5">(</span>comment field-name section-name<span class="org-rainbow-delimiters-depth-5">)</span>
                  <span class="org-rainbow-delimiters-depth-5">(</span>cabal-version<span class="org-rainbow-delimiters-depth-5">)</span>
                  <span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">setq-local</span> treesit-font-lock-settings cabal--treesit-font-lock-setting<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>treesit-major-mode-setup<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter">;;;</span><span class="org-comment">###</span><span class="org-comment"><span class="org-warning">autoload</span></span>
<span class="org-rainbow-delimiters-depth-1">(</span>add-to-list 'auto-mode-alist '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\\.cabal\\'"</span> . my-cabal-mode<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5251e68" class="outline-2">
<h2 id="org5251e68">Navigation</h2>
<div class="outline-text-2" id="text-org5251e68">
<p>
One of the reasons I want to experiment with tree-sitter is to use it for code
navigation. My first attempt is to translate <code>haskell-cabal-section-beginning</code>
(in <code>haskell-mode</code>, <a href="https://github.com/haskell/haskell-mode/blob/master/haskell-cabal.el#L395">the source</a>) to using tree-sitter. First a convenience
function to recognise if a node is a section or not
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">cabal--node-is-section-p</span> <span class="org-rainbow-delimiters-depth-2">(</span>n<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Predicate to check if treesit node N is a Cabal section."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>member <span class="org-rainbow-delimiters-depth-3">(</span>treesit-node-type n<span class="org-rainbow-delimiters-depth-3">)</span>
          '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"benchmark"</span> <span class="org-string">"common"</span> <span class="org-string">"executable"</span> <span class="org-string">"flag"</span> <span class="org-string">"library"</span> <span class="org-string">"test_suite"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That makes it possible to use <code>treesit-parent-until</code> to traverse the nodes until
hitting a section node
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">cabal-goto-beginning-of-section</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Go to the beginning of the current section."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">interactive</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when-let*</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>node-at-point <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-at <span class="org-rainbow-delimiters-depth-6">(</span>point<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>section-node <span class="org-rainbow-delimiters-depth-5">(</span>treesit-parent-until node-at-point #'cabal--node-is-section-p<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>start-pos <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-start section-node<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>goto-char start-pos<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
And the companion function, to go to the end of a section is very similar
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">cabal-goto-end-of-section</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Go to the end of the current section."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">interactive</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when-let*</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>node-at-point <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-at <span class="org-rainbow-delimiters-depth-6">(</span>point<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>section-node <span class="org-rainbow-delimiters-depth-5">(</span>treesit-parent-until node-at-point #'cabal--node-is-section-p<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>end-pos <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-end section-node<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>goto-char end-pos<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I'm using <a href="https://github.com/radian-software/straight.el">straight.el</a> and <code>use-package</code> in my setup, but hopefully the
snippets can easily be converted to other ways of configuring Emacs.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-cabal.html">cabal</a> <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-tree-sitter.html">tree-sitter</a> </div>

<div class="post-date">03 Mar 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-03-03-per-project-xref-history-in-emacs.html">Per-project xref history in Emacs</a></h1>
<p>
When I write code I jump around in the code quite a bit, as I'm sure many other
developers do. The ability to jump to the definition of a function, or a type,
is invaluable when trying to understand code. In Emacs the built-in <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Xref.html">xref package</a>
provides the basic functionality for this, with many other packages providing
their custom functions for looking up identifiers. This works beautifully except
for one thing, there's only one global stack for keeping track of how you've
jumped around.
</p>

<p>
Well, that used to be the case.
</p>

<p>
As I tend to have multiple projects open at a time I used to find it very
confusing when I pop positions off the <code>xref</code> stack and all of a sudden find
myself in another project. It would be so much nicer to have a per-project
stack.
</p>

<p>
I've only known of one solution for this, the <a href="https://github.com/nex3/perspective-el">perspective package</a>, but as I've
been building <a href="https://magnus.therning.org/2022-07-09-playing-with-setting-up-emacs.html">my own Emacs config</a> I wanted to see if there were other options.
It turns out there is one (almost) built into Emacs 29.
</p>

<p>
In Emacs 29 there's built-in support for having per-window <code>xref</code> stacks, and
the way that's done allows one to extend it further. There's now a variable,
<code>xref-history-storage</code>, that controls access to the <code>xref</code> stack. The default is
still a global stack (when the variable is set to <code>#'xref-global-history</code>), but
to get per-window stacks one sets it to <code>#'xref-window-local-history</code>.
</p>

<p>
After finding this out I thought I'd try to write my own, implementing
per-project <code>xref</code> stacks (for <a href="https://github.com/bbatsov/projectile">projectile</a>).
</p>

<p>
The function should take one optional argument, <code>new-value</code>, if it's provided
the stack should be updated and if not, it should be returned. That is,
something like this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">projectile-param-xref-history</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">&amp;optional</span> new-value<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Return project-local xref history for the current projectile.</span>

<span class="org-doc">Override existing value with NEW-VALUE if it's set."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">if</span> new-value
      <span class="org-rainbow-delimiters-depth-3">(</span>projectile-param-set-parameter 'xref--history new-value<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">or</span> <span class="org-rainbow-delimiters-depth-4">(</span>projectile-param-get-parameter 'xref--history<span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">(</span>projectile-param-set-parameter 'xref--history <span class="org-rainbow-delimiters-depth-5">(</span>xref--make-xref-history<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Now I only had to write the two functions <code>projectile-param-get-parameter</code> and
<code>projectile-param-set-parameter</code>. I thought a rather straight forward option
would be to use a hashtable and store values under a tuple comprising the
project name and the parameter passed in.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defvar</span> <span class="org-variable-name">projectile-params--store</span> <span class="org-rainbow-delimiters-depth-2">(</span>make-hash-table <span class="org-builtin">:test</span> 'equal<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"The store of project parameters."</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">projectile-param-get-parameter</span> <span class="org-rainbow-delimiters-depth-2">(</span>param<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Return project parameter PARAM, or nil if unset."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>key <span class="org-rainbow-delimiters-depth-5">(</span>cons <span class="org-rainbow-delimiters-depth-6">(</span>projectile-project-name<span class="org-rainbow-delimiters-depth-6">)</span> param<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>gethash key projectile-params--store nil<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">projectile-param-set-parameter</span> <span class="org-rainbow-delimiters-depth-2">(</span>param value<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Set the project parameter PARAM to VALUE."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>key <span class="org-rainbow-delimiters-depth-5">(</span>cons <span class="org-rainbow-delimiters-depth-6">(</span>projectile-project-name<span class="org-rainbow-delimiters-depth-6">)</span> param<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>puthash key value projectile-params--store<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  value<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Then I tried it out by setting <code>xref-history-storage</code>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">setq</span> xref-history-storage #'projectile-param-xref-history<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
and so far it's been working well.
</p>

<p>
The full code is <a href="https://gitlab.com/magus/my-emacs-pkgs/-/blob/main/my-projectile-params/my-projectile-params.el">here</a>.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-xref.html">xref</a> <a href="https://magnus.therning.org/tag-projectile.html">projectile</a> </div>

<div class="post-date">08 Feb 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-02-08-logging-with-class.html">Logging with class</a></h1>
<p>
In two previous posts I've described how I currently compose <a href="https://magnus.therning.org/2023-01-29-a-take-on-log-messages.html">log messages</a> and
how I do the actual <a href="https://magnus.therning.org/2023-02-04-a-take-on-logging.html">logging</a>. This post wraps up this particular topic for now
with a couple of typeclasses, a default implementation, and an example showing
how I use them.
</p>

<div id="outline-container-org9c277ac" class="outline-2">
<h2 id="org9c277ac">The typeclasses</h2>
<div class="outline-text-2" id="text-org9c277ac">
<p>
First off I want a monad for the logging itself. It's just a collection of
functions taking a <code>LogMsg</code> and returning unit (in a monad).
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">class</span> <span class="org-tree-sitter-hl-faceXtype">Monad</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtype">LoggerActions</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">debug</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">info</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">warn</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">err</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">fatal</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LogMsg</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
</pre>
</div>

<p>
In order to provide a default implementation I also need a way to extract the
logger itself.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">class</span> <span class="org-tree-sitter-hl-faceXtype">Monad</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtype">HasLogger</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXtype">Logger</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfc9e191" class="outline-2">
<h2 id="orgfc9e191">Default implementation</h2>
<div class="outline-text-2" id="text-orgfc9e191">
<p>
Using the two typeclasses above it's now possible to define a type with an
implementation of <code>LoggerActions</code> that is usable with <a href="https://magnus.therning.org/2023-01-15-composing-instances-using-~deriving-via~.html"><code>deriving
via</code></a>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">newtype</span> <span class="org-tree-sitter-hl-faceXtype">StdLoggerActions</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXtypeXargument">a</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXconstructor">MkStdZLA</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXtypeXargument">a</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Functor</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Applicative</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Monad</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">HasLogger</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>

<p>
And its implementattion of <code>LoggerActions</code> looks like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">instance</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">HasLogger</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtype">LoggerActions</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">StdLoggerActions</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">debug</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">&gt;&gt;=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">flip</span></span> <span class="org-tree-sitter-hl-faceXvariable">debugIO</span> <span class="org-tree-sitter-hl-faceXvariable">msg</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">info</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">&gt;&gt;=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">flip</span></span> <span class="org-tree-sitter-hl-faceXvariable">infoIO</span> <span class="org-tree-sitter-hl-faceXvariable">msg</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">warn</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">&gt;&gt;=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">flip</span></span> <span class="org-tree-sitter-hl-faceXvariable">warnIO</span> <span class="org-tree-sitter-hl-faceXvariable">msg</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">err</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">&gt;&gt;=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">flip</span></span> <span class="org-tree-sitter-hl-faceXvariable">errIO</span> <span class="org-tree-sitter-hl-faceXvariable">msg</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">fatal</span></span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXvariableXparameter">msg</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">&gt;&gt;=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">flip</span></span> <span class="org-tree-sitter-hl-faceXvariable">fatalIO</span> <span class="org-tree-sitter-hl-faceXvariable">msg</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org985e509" class="outline-2">
<h2 id="org985e509">An example</h2>
<div class="outline-text-2" id="text-org985e509">
<p>
Using the definitions above is fairly straight forward. First a type the derives
its implementaiton of <code>LoggerActions</code> from <code>StdLoggerActions</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">newtype</span> <span class="org-tree-sitter-hl-faceXtype">EnvT</span> <span class="org-tree-sitter-hl-faceXtypeXargument">a</span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXconstructor">EnvT</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">{</span></span><span class="org-tree-sitter-hl-faceXvariable">runEnvT</span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">ReaderT</span> <span class="org-tree-sitter-hl-faceXtype">Logger</span> <span class="org-tree-sitter-hl-faceXtype">IO</span> <span class="org-tree-sitter-hl-faceXtypeXargument">a</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">}</span></span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXkeyword">newtype</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">Functor</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Applicative</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">Monad</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">MonadIO</span><span class="org-tree-sitter-hl-faceXpunctuationXdelimiter">,</span> <span class="org-tree-sitter-hl-faceXtype">MonadReader</span> <span class="org-tree-sitter-hl-faceXtype">Logger</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
    <span class="org-tree-sitter-hl-faceXkeyword">deriving</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">LoggerActions</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXkeyword">via</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXtype">StdLoggerActions</span> <span class="org-tree-sitter-hl-faceXtype">EnvT</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span>
</pre>
</div>

<p>
In order for it to work, and compile, it needs an implementation of <code>HasLogger</code> too.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXkeyword">instance</span> <span class="org-tree-sitter-hl-faceXtype">HasLogger</span> <span class="org-tree-sitter-hl-faceXtype">EnvT</span> <span class="org-tree-sitter-hl-faceXkeyword">where</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">getLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable">ask</span>
</pre>
</div>

<p>
All that's left is a function using a constraint on <code>LoggerActions</code> (<code>doStuff</code>)
and a <code>main</code> function creating a logger, constructing an <code>EnvT</code>, and then
running <code>doStuff</code> in it.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">doStuff</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">LoggerActions</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXoperator">=&gt;</span> <span class="org-tree-sitter-hl-faceXtypeXargument">m</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">doStuff</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXkeyword">do</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">debug</span></span> <span class="org-tree-sitter-hl-faceXstring">"a log line"</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">info</span></span> <span class="org-tree-sitter-hl-faceXoperator">$</span> <span class="org-tree-sitter-hl-faceXstring">"another log line"</span> <span class="org-tree-sitter-hl-faceXoperator">#+</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">[</span></span><span class="org-tree-sitter-hl-faceXstring">"extras"</span> <span class="org-tree-sitter-hl-faceXoperator">.=</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">(</span></span><span class="org-tree-sitter-hl-faceXnumber">42</span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">Int</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-2">)</span></span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">]</span></span>

<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunction">main</span></span> <span class="org-tree-sitter-hl-faceXoperator">::</span> <span class="org-tree-sitter-hl-faceXtype">IO</span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">main</span></span> <span class="org-tree-sitter-hl-faceXoperator">=</span> <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXproperty">withLogger</span></span> <span class="org-tree-sitter-hl-faceXoperator">$</span> <span class="org-tree-sitter-hl-faceXoperator">\</span><span class="org-tree-sitter-hl-faceXvariable">logger</span> <span class="org-tree-sitter-hl-faceXoperator">-&gt;</span>
    <span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">runReaderT</span></span> <span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">(</span></span><span class="org-tree-sitter-hl-faceXvariable"><span class="org-tree-sitter-hl-faceXfunctionXcall">runEnvT</span></span> <span class="org-tree-sitter-hl-faceXvariable">doStuff</span><span class="org-tree-sitter-hl-faceXpunctuationXbracket"><span class="org-rainbow-delimiters-depth-1">)</span></span> <span class="org-tree-sitter-hl-faceXvariable">logger</span>
</pre>
</div>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-logging.html">logging</a> </div>
<div id="archive">
<a href="https://magnus.therning.org/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><!-- org-static-blog-page-postamble --></div>
</body>
</html>
