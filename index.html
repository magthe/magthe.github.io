<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://magnus.therning.org/feed.xml"
      title="RSS feed for https://magnus.therning.org/">
<title>Magnus web site</title>
<meta name="author" content="Magnus Therning"><meta name="referrer" content="no-referrer"><link href= "static/style.css" rel="stylesheet" type="text/css" /><link href= "static/htmlize.css" rel="stylesheet" type="text/css" /><link href= "static/extra_style.css" rel="stylesheet" type="text/css" /></head>
<body>
<div id="preamble" class="status"><div class="nav-bar"><a class="nav-link" href="./index.html">Top</a><a class="nav-link" href="./archive.html">Archive</a><a class="nav-link align-right" href="./feed.xml"><img src="static/rss-feed-icon.png" style="height: 24px;" /></a></div></div>
<div id="content">
<header class="site-header" role="banner"><h1 class="title">Magnus web site</h1><h2 class="subtitle">Random stuff</h2></header>
<div class="post-date">09 Jul 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-07-09-general.el-and-two-ways-to-define-keybindings.html">general.el and two ways to define keybindings</a></h1>
<p>
When I abandoned <a href="https://www.spacemacs.org/">spacemacs</a> I really wanted to duplicate its keybindings using
<code>SPC</code> as leader key and per-mode bindings available by pressing <code>,</code>. I found a
nice setup using <a href="https://github.com/noctuid/general.el">general.el</a> in <a href="https://github.com/tshu-w/.emacs.d/">Tianshu Wang's Emacs config</a>. I made only minor
modification and ended up with the following setup.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">use-package</span> <span class="org-constant">general</span>
  <span class="org-builtin">:after</span> <span class="org-rainbow-delimiters-depth-2">(</span>evil evil-easymotion<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-builtin">:config</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>general-evil-setup<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>general-auto-unbind-keys<span class="org-rainbow-delimiters-depth-2">)</span>

  <span class="org-rainbow-delimiters-depth-2">(</span>general-define-key
   <span class="org-builtin">:states</span> '<span class="org-rainbow-delimiters-depth-3">(</span>normal insert motion visual emacs<span class="org-rainbow-delimiters-depth-3">)</span>
   <span class="org-builtin">:keymaps</span> 'override
   <span class="org-builtin">:prefix-map</span> 'tyrant-map
   <span class="org-builtin">:prefix</span> <span class="org-string">"SPC"</span>
   <span class="org-builtin">:non-normal-prefix</span> <span class="org-string">"M-SPC"</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">general-create-definer</span> mes/tyrant-def <span class="org-builtin">:keymaps</span> 'tyrant-map<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">mes/tyrant-def</span> <span class="org-string">""</span> nil<span class="org-rainbow-delimiters-depth-2">)</span>

  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">general-create-definer</span> mes/despot-def
    <span class="org-builtin">:states</span> '<span class="org-rainbow-delimiters-depth-3">(</span>normal insert motion visual emacs<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-builtin">:keymaps</span> 'override
    <span class="org-builtin">:major-modes</span> t
    <span class="org-builtin">:prefix</span> <span class="org-string">","</span>
    <span class="org-builtin">:non-normal-prefix</span> <span class="org-string">"M-,"</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">mes/despot-def</span> <span class="org-string">""</span> nil<span class="org-rainbow-delimiters-depth-2">)</span>

  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">general-def</span> universal-argument-map
    <span class="org-string">"SPC u"</span> 'universal-argument-more<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
One slightly surprising thing I found out is that two different ways to define
keybindings can be used, one seems to work on both top and mode level, the other
only on mode level.
</p>

<div id="outline-container-orgcb12477" class="outline-2">
<h2 id="orgcb12477">Top-level keybindings (<code>SPC</code>)</h2>
<div class="outline-text-2" id="text-orgcb12477">
<p>
At the top-level, i.e. when using <code>mes/tyrant-def</code>, I need to use a <code>cons</code> based
configuration. This is part of my top-level keybindings:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">mes/tyrant-def</span>
  <span class="org-string">"SPC"</span> '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"M-x"</span> . execute-extended-command<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-string">"TAB"</span> '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"latest buffer"</span> . mode-line-other-buffer<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-string">"!"</span> 'shell-command
  <span class="org-string">"/"</span> '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"search"</span> . consult-ripgrep<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-string">"u"</span> 'universal-argument

  <span class="org-string">"b"</span> <span class="org-rainbow-delimiters-depth-2">(</span>cons <span class="org-string">"bufs"</span> <span class="org-rainbow-delimiters-depth-3">(</span>make-sparse-keymap<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-string">"bb"</span> '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"switch"</span> . consult-buffer<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-string">"bc"</span> '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"close"</span> . kill-this-buffer<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-string">"be"</span> '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"erase"</span> . erase-buffer<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-string">"bs"</span> '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"scratch"</span> . scratch-buffer<span class="org-rainbow-delimiters-depth-2">)</span>

  <span class="org-comment-delimiter">;; </span><span class="org-comment">....</span>
  <span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
When it's done this way <a href="https://github.com/justbur/emacs-which-key">which-key</a> picks up the descriptive strings.
</p>

<p>
It did take me a while to figure out that this config style was necessary. Again
<a href="https://github.com/tshu-w/.emacs.d/">Tianshu Wang's Emacs config</a> was what led me right.
</p>
</div>
</div>

<div id="outline-container-org7f651e5" class="outline-2">
<h2 id="org7f651e5">Mode-level keybindings (<code>,</code>)</h2>
<div class="outline-text-2" id="text-org7f651e5">
<p>
At the mode-level, i.e. using <code>mes/despot-def</code>, I've found that I can, almost
always, define keybindings following the documentation of <a href="https://github.com/noctuid/general.el">general.el</a>. Here's the
keybindings I have for <code>nix-mode</code>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">mes/despot-def</span> nix-mode-map
  <span class="org-string">"="</span> '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-builtin">:ignore</span> t <span class="org-builtin">:wk</span> <span class="org-string">"format"</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-string">"=b"</span> '<span class="org-rainbow-delimiters-depth-2">(</span>nix-format-buffer <span class="org-builtin">:wk</span> <span class="org-string">"buffer"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Just the other day I found that AUCTeX must be doing something with it's keymaps
and I have to use the <code>cons</code>-based configuration style for its keymaps.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> </div>

<div class="post-date">26 Apr 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-04-26-some-practical-haskell.html">Some practical Haskell</a></h1>
<p>
As I'm nearing the end of my time with my current employer I thought I'd put
together some bits of practical Haskell that I've put into production. We only
have a few services in Haskell, and basically I've had to sneak them into
production. I'm hoping someone will find something useful. I'd be even happier
if I get pointers on how to do this even better.
</p>

<div id="outline-container-org3790afb" class="outline-2">
<h2 id="org3790afb">Logging</h2>
<div class="outline-text-2" id="text-org3790afb">
<p>
I've written about that earlier in three posts:
</p>

<ol class="org-ol">
<li><a href="https://magnus.therning.org/2023-01-29-a-take-on-log-messages.html">A take on log messages</a></li>
<li><a href="https://magnus.therning.org/2023-02-04-a-take-on-logging.html">A take on logging</a></li>
<li><a href="https://magnus.therning.org/2023-02-08-logging-with-class.html">Logging with class</a></li>
</ol>
</div>
</div>

<div id="outline-container-org377fbff" class="outline-2">
<h2 id="org377fbff">Final exception handler</h2>
<div class="outline-text-2" id="text-org377fbff">
<p>
After reading about the <i>uncaught exception handler</i> in <a href="https://serokell.io/blog/uncaught-exception-handling">Serokell's article</a> I've
added the following snippet to all the services.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    <span class="org-haskell-operator">...</span>
    originalHandler <span class="org-haskell-operator">&lt;-</span> getUncaughtExceptionHandler
    setUncaughtExceptionHandler <span class="org-haskell-operator">$</span> handle originalHandler <span class="org-haskell-operator">.</span> lastExceptionHandler logger
    <span class="org-haskell-operator">...</span>

<span class="org-haskell-definition">lastExceptionHandler</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Logger</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">SomeException</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">lastExceptionHandler</span> logger e <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    fatalIO logger <span class="org-haskell-operator">$</span> lm <span class="org-haskell-operator">$</span> <span class="org-string">"uncaught exception: "</span> <span class="org-haskell-operator">&lt;&gt;</span> displayException e
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc085bc5" class="outline-2">
<h2 id="orgc085bc5">Handling signals</h2>
<div class="outline-text-2" id="text-orgc085bc5">
<p>
To make sure the platform we're running our services on is happy with a service
it needs to handle <code>SIGTERM</code>, and when running it locally during development,
e.g. for manual testing, it's nice if it also handles <code>SIGINT</code>.
</p>

<p>
The following snippet comes from a service that needs to make sure that every
iteration of its processing is completed before shutting down, hence the <code>IORef</code>
that's used to signal whether procession should continue or not.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">main</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    <span class="org-haskell-operator">...</span>
    cont <span class="org-haskell-operator">&lt;-</span> newIORef <span class="org-haskell-constructor">True</span>
    void <span class="org-haskell-operator">$</span> installHandler softwareTermination <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Catch</span> <span class="org-haskell-operator">$</span> sigHandler logger cont<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">Nothing</span>
    void <span class="org-haskell-operator">$</span> installHandler keyboardSignal <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Catch</span> <span class="org-haskell-operator">$</span> sigHandler logger cont<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">Nothing</span>
    <span class="org-haskell-operator">...</span>

<span class="org-haskell-definition">sigHandler</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Logger</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IORef</span> <span class="org-haskell-type">Bool</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">sigHandler</span> logger cont <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
    infoIO logger <span class="org-string">"got a signal, shutting down"</span>
    writeIORef cont <span class="org-haskell-constructor">False</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0553b14" class="outline-2">
<h2 id="org0553b14">Probes</h2>
<div class="outline-text-2" id="text-org0553b14">
<p>
Due to some details about how networking works in our platform it's currently
not possible to use network-based probing. Instead we have to use files. There
are two probes that are of interest
</p>

<ul class="org-ul">
<li>A startup probe, existance of the file signals that the service has started as
is about being processing.</li>
<li>A progress probe, a timestamp signals the time the most recent iteration of
processing finished<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.</li>
</ul>

<p>
I've written a little bit about the latter before in <a href="https://magnus.therning.org/2022-05-08-a-little-haskell:-epoch-timestamp.html">A little Haskell: epoch
timestamp</a>, but here I'm including both functions.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">createPidFile</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">FilePath</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">createPidFile</span> fn <span class="org-haskell-operator">=</span> getProcessID <span class="org-haskell-operator">&gt;&gt;=</span> writeFile fn <span class="org-haskell-operator">.</span> show

<span class="org-haskell-definition">writeTimestampFile</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">MonadIO</span> m <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">FilePath</span> <span class="org-haskell-operator">-&gt;</span> m <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">()</span></span>
<span class="org-haskell-definition">writeTimestampFile</span> fn <span class="org-haskell-operator">=</span> liftIO <span class="org-haskell-operator">$</span> <span class="org-haskell-keyword">do</span>
    getPOSIXTime <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-rainbow-delimiters-depth-1">(</span>writeFile fn <span class="org-haskell-operator">.</span> show<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">.</span> truncate <span class="org-haskell-operator">@</span><span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">@</span><span class="org-haskell-constructor">Int64</span> <span class="org-haskell-operator">.</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">*</span> 1000<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
The actual probing is then done using a command that compares the saved
timestamp with the current time. As long as the difference is smaller than a
threshold the probe succeeds.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>

<div class="post-date">30 Mar 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-03-30-more-on-tree-sitter-and-consult.html">More on tree-sitter and consult</a></h1>
<p>
Here's a few things that I've gotten help with figuring out during the last few
days. Both things are related to my playing with tree-sitter that I've written
about earlier, <a href="https://magnus.therning.org/2023-03-22-making-an-emacs-major-mode-for-cabal-using-tree-sitter.html">here</a> and <a href="https://magnus.therning.org/2023-03-27-cabal,-tree-sitter,-and-consult.html">here</a>.
</p>

<p>
You might also be interested in the two repositories where the full code
is. (I've linked to the specific commits as of this writing.)
</p>

<ul class="org-ul">
<li><a href="https://gitlab.com/magus/my-emacs-pkgs/-/tree/e739d1035f3d505f2495309126d891ca6b18cab8/my-cabal-mode">My Cabal mode</a></li>
<li><a href="https://gitlab.com/magus/tree-sitter-cabal/-/tree/7d5fa6887ae05a0b06d046f1e754c197c8ad869b">tree-sitter-cabal</a></li>
</ul>

<div id="outline-container-org8a27db9" class="outline-2">
<h2 id="org8a27db9">Anonymous nodes and matching in tree-sitter</h2>
<div class="outline-text-2" id="text-org8a27db9">
<p>
In the grammar for Cabal I have a rule for sections that like this
</p>

<div class="org-src-container">
<pre class="src src-javascript">sections: $ =&gt; repeat1<span class="org-rainbow-delimiters-depth-1">(</span>choice<span class="org-rainbow-delimiters-depth-2">(</span>
    $.benchmark,
    $.common,
    $.executable,
    $.flag,
    $.library,
    $.source_repository,
    $.test_suite,
<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>,
</pre>
</div>

<p>
where each section followed this pattern
</p>

<div class="org-src-container">
<pre class="src src-javascript">benchmark: $ =&gt; seq<span class="org-rainbow-delimiters-depth-1">(</span>
    repeat<span class="org-rainbow-delimiters-depth-2">(</span>$.comment<span class="org-rainbow-delimiters-depth-2">)</span>,
    <span class="org-string">'benchmark'</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'name'</span>, $.section_name<span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'properties'</span>, $.property_block<span class="org-rainbow-delimiters-depth-2">)</span>,
<span class="org-rainbow-delimiters-depth-1">)</span>,
</pre>
</div>

<p>
This made it a little bit difficult to capture the relevant parts of each
section to implement <code>consult-cabal</code>. I thought a pattern like this ought to
work
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>cabal
 <span class="org-rainbow-delimiters-depth-2">(</span>sections
  <span class="org-rainbow-delimiters-depth-3">(</span>_ _ @type
     name: <span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span>? @name<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
but it didn't; I got way too many things captured in <code>type</code>. Clearly I had
misunderstood something about the wildcards, or the query syntax. I attempted to
add a field name to the anonymous node, i.e. change the sections rules like this
</p>

<div class="org-src-container">
<pre class="src src-javascript">benchmark: $ =&gt; seq<span class="org-rainbow-delimiters-depth-1">(</span>
    repeat<span class="org-rainbow-delimiters-depth-2">(</span>$.comment<span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'type'</span>, <span class="org-string">'benchmark'</span><span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'name'</span>, $.section_name<span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'properties'</span>, $.property_block<span class="org-rainbow-delimiters-depth-2">)</span>,
<span class="org-rainbow-delimiters-depth-1">)</span>,
</pre>
</div>

<p>
It was accepted by <code>tree-sitter generate</code>, but the field <code>type</code> was nowhere to
be found in the parse tree.
</p>

<p>
Then I changed the query to list the anonymous nodes explicitly, like this
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>cabal
 <span class="org-rainbow-delimiters-depth-2">(</span>sections
  <span class="org-rainbow-delimiters-depth-3">(</span>_ [<span class="org-string">"benchmark"</span> <span class="org-string">"common"</span> <span class="org-string">"executable"</span> ...] @type
     name: <span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span>? @name<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That worked, but listing all the sections like that in the query didn't sit
right with me.
</p>

<p>
Luckily there's a <a href="https://github.com/tree-sitter/tree-sitter/discussions">discussions area in tree-sitters GitHub</a> so a <a href="https://github.com/tree-sitter/tree-sitter/discussions/2161">fairly short
discussion</a> later I had answers to why my query behaved like it did and a
solution that would allow me to not list all the section types in the query. The
trick is to wrap the string in a call to <code>alias</code> to make it a named node. After
that it works to add a field name to it as well, of course. The section rules
now look like this
</p>

<div class="org-src-container">
<pre class="src src-javascript">benchmark: $ =&gt; seq<span class="org-rainbow-delimiters-depth-1">(</span>
    repeat<span class="org-rainbow-delimiters-depth-2">(</span>$.comment<span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'type'</span>, alias<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">'benchmark'</span>, $.section_type<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'name'</span>, $.section_name<span class="org-rainbow-delimiters-depth-2">)</span>,
    field<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'properties'</span>, $.property_block<span class="org-rainbow-delimiters-depth-2">)</span>,
<span class="org-rainbow-delimiters-depth-1">)</span>,
</pre>
</div>

<p>
and the final query looks like this
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>cabal
 <span class="org-rainbow-delimiters-depth-2">(</span>sections
  <span class="org-rainbow-delimiters-depth-3">(</span>_
   type: <span class="org-rainbow-delimiters-depth-4">(</span>section_type<span class="org-rainbow-delimiters-depth-4">)</span> @type
   name: <span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span>? @name<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
With that in place I could improve on the function that collects all the items
for <code>consult-cabal</code> so it now show the section's type and name instead of the
string representation of the tree-sitter node.
</p>
</div>
</div>

<div id="outline-container-orgf3cee92" class="outline-2">
<h2 id="orgf3cee92">State in a <code>consult</code> source for preview of lines in a buffer</h2>
<div class="outline-text-2" id="text-orgf3cee92">
<p>
I was struggling with figuring out how to make a good <i>state</i> function in order
to preview the items in <code>consult-cabal</code>. The <a href="https://github.com/minad/consult">GitHub repo for <code>consult</code></a> doesn't
have discussions enabled, but after a <a href="https://github.com/minad/consult/issues/780">discussion in an issue</a> I'd arrived at a
<i>state</i> function that works very well.
</p>

<p>
The state function makes use of functions in <code>consult</code> and looks like this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">consult-cabal--state</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Create a state function for previewing sections."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>state <span class="org-rainbow-delimiters-depth-5">(</span>consult--jump-state<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>action cand<span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">when</span> cand
        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-rainbow-delimiters-depth-7">(</span>pos <span class="org-rainbow-delimiters-depth-8">(</span>get-text-property 0 'section-pos cand<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
          <span class="org-rainbow-delimiters-depth-6">(</span>funcall state action pos<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The trick here was to figure out how the function returned by
<code>consult--jump-state</code> actually works. On the surface it looks like it takes an
<i>action</i> and a <i>candidate</i>, <code>(lambda (action cand) ...)</code>. However, the argument
<code>cand</code> shouldn't be the currently selected item, but rather a postion (ideally a
<code>marker</code>), so I had to attach another text property on the items (<code>section-pos</code>,
which is fetched in the inner lambda). This position is then what's passed to
the function returned by <code>consult--jump-state</code>.
</p>

<p>
In hindsight it seems so easy, but I was struggling with this for an entire
evening before finally asking the question the morning after.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-consult.html">consult</a> <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-tree-sitter.html">tree-sitter</a> </div>

<div class="post-date">27 Mar 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-03-27-cabal,-tree-sitter,-and-consult.html">Cabal, tree-sitter, and consult</a></h1>
<p>
After my <a href="https://magnus.therning.org/2023-03-22-making-an-emacs-major-mode-for-cabal-using-tree-sitter.html">last post</a> I thought I'd move on to implement the rest of the functions
in <a href="https://github.com/haskell/haskell-mode">haskell-mode</a>'s major mode for Cabal, functions like
<code>haskell-cabal-goto-library-section</code> and
<code>haskell-cabal-goto-executable-section</code>.  Then I realised that what <i>I</i> really
want is a way to quickly jump to any section, that is, I want <code>consult-cabal</code>!
</p>

<p>
What follows is very much a work-in-progress, but hopefully it'll show enough
promise.
</p>

<div id="outline-container-org31e7014" class="outline-2">
<h2 id="org31e7014">Listing the sections</h2>
<div class="outline-text-2" id="text-org31e7014">
<p>
As I have a <code>tree-sitter</code> parse tree to hand it is fairly easy to fetch all the
nodes corresponding to sections.  Since the <a href="https://magnus.therning.org/2023-03-22-making-an-emacs-major-mode-for-cabal-using-tree-sitter.html">last post</a> I've made some
improvements to the parser and now the parse tree looks like this (I can
recommend the function <code>treesit-explore-mode</code> to expore the parse tree, I've
found it invaluable ever since I realised it existed)
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>cabal
 ...
 <span class="org-rainbow-delimiters-depth-2">(</span>properties ...<span class="org-rainbow-delimiters-depth-2">)</span>
 <span class="org-rainbow-delimiters-depth-2">(</span>sections
  <span class="org-rainbow-delimiters-depth-3">(</span>common common <span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span> ...<span class="org-rainbow-delimiters-depth-3">)</span>
  <span class="org-rainbow-delimiters-depth-3">(</span>library library ...<span class="org-rainbow-delimiters-depth-3">)</span>
  <span class="org-rainbow-delimiters-depth-3">(</span>executable executable <span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span> ...<span class="org-rainbow-delimiters-depth-3">)</span>
  ...<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That is, all the <i>sections</i> are children of the node called <code>sections</code>.
</p>

<p>
The function to use for fetching all the nodes is <code>treesit-query-capture</code>, it
needs a node to start on, which this case should be the full parse tree,
i.e. <code>(treesit-buffer-root-node 'cabal)</code> and a query string.  Given the
structure of the parse tree, and that I want to capture all children of
<code>sections</code>, a query string like this one works
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-string">"(cabal (sections (_)* @section))"</span>
</pre>
</div>

<p>
Finally, by default <code>treesit-query-capture</code> returns a list of tuples of the form
<code>(&lt;capture&gt; . &lt;node&gt;)</code>, but in this case I only want the list of nodes, so the
full call will look like this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>treesit-query-capture <span class="org-rainbow-delimiters-depth-2">(</span>treesit-buffer-root-node 'cabal<span class="org-rainbow-delimiters-depth-2">)</span>
                       <span class="org-string">"(cabal (sections (_)* @section))"</span>
                       nil nil t<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcead32c" class="outline-2">
<h2 id="orgcead32c">Hooking it up to consult</h2>
<div class="outline-text-2" id="text-orgcead32c">
<p>
As I envision adding more things to jump to in the future, I decided to make use
of <code>consult--multi</code>. That in turn means I need to define a "source" for the
sections. After a bit of digging and rummaging in the <a href="https://github.com/minad/consult/">consult source</a> I put
together this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defvar</span> <span class="org-variable-name">consult-cabal--source-section</span>
  `<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-builtin">:name</span> <span class="org-string">"Sections"</span>
    <span class="org-builtin">:category</span> location
    <span class="org-builtin">:action</span> ,#'consult-cabal--section-action
    <span class="org-builtin">:items</span> ,#'consult-cabal--section-items<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Definition of source for Cabal sections."</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
which means I need two functions, <code>consult-cabal--section-action</code> and
<code>consult-cabal--section-items</code>. I started with the latter.
</p>
</div>

<div id="outline-container-org72b3791" class="outline-3">
<h3 id="org72b3791">Getting section nodes as items for consult</h3>
<div class="outline-text-3" id="text-org72b3791">
<p>
It took me a while to work understand how this would ever be able to work. The
function that <code>:items</code> point to must return a list of strings, but how would I
ever be able to use just a string to jump to the correct location?
</p>

<p>
The solution is in a comment in the documentation of <code>consult--multi</code>:
</p>

<blockquote>
<p>
:items - List of strings to select from or function returning
 list of strings.  Note that the strings can use text properties
 to carry metadata, which is then available to the :annotate,
 :action and :state functions.
</p>
</blockquote>

<p>
I'd never come across <i>text properties</i> in Emacs before, so at first I
completely missed those two words. Once I'd looked up the concept in the
documentation everything fell into place. The function
<code>consult-cabal--section-items</code> would simply attach the relevant node as a text
property to the strings in the list.
</p>

<p>
My current version, obviously a work-in-progress, takes a list of nodes and
turns them na√Øvely into a string and attaches the node. I split it into two functions, like this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">consult-cabal--section-to-string</span> <span class="org-rainbow-delimiters-depth-2">(</span>section<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Convert a single SECTION node to a string."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>propertize <span class="org-rainbow-delimiters-depth-3">(</span>format <span class="org-string">"%S"</span> section<span class="org-rainbow-delimiters-depth-3">)</span>
              <span class="org-builtin">:treesit-node</span> section<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">consult-cabal--section-items</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Fetch all sections as a list of strings ."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>section-nodes <span class="org-rainbow-delimiters-depth-5">(</span>treesit-query-capture <span class="org-rainbow-delimiters-depth-6">(</span>treesit-buffer-root-node 'cabal<span class="org-rainbow-delimiters-depth-6">)</span>
                                              <span class="org-string">"(cabal (sections (_)* @section))"</span>
                                              nil nil t<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>mapcar #'consult-cabal--section-to-string section-nodes<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org83dad10" class="outline-3">
<h3 id="org83dad10">Implementing the action</h3>
<div class="outline-text-3" id="text-org83dad10">
<p>
The action function is called with the selected item, i.e. with the string and
its properties. That means, to jump to the selected section the function needs
to extract the node property, <code>:treesit-node</code>, and jump to the start of it. the
function to use is <code>get-text-property</code>, and as all characters in the string will
have to property I just picked the first one. The jumping itself I copied from
the navigation functions I'd written before.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">consult-cabal--section-action</span> <span class="org-rainbow-delimiters-depth-2">(</span>item<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Go to the section referenced by ITEM."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when-let*</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>node <span class="org-rainbow-delimiters-depth-5">(</span>get-text-property 0 <span class="org-builtin">:treesit-node</span> item<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>new-pos <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-start node<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>goto-char new-pos<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb0e4e64" class="outline-3">
<h3 id="orgb0e4e64">Tying it together with <code>consult--multi</code></h3>
<div class="outline-text-3" id="text-orgb0e4e64">
<p>
The final function, <code>consult-cabal</code>, looks like this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">consult-cabal</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Choose a Cabal construct and jump to it."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">interactive</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>consult--multi '<span class="org-rainbow-delimiters-depth-3">(</span>consult-cabal--source-section<span class="org-rainbow-delimiters-depth-3">)</span>
                  <span class="org-builtin">:sort</span> nil<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8f2653b" class="outline-2">
<h2 id="org8f2653b">Conclusions and where to find the code</h2>
<div class="outline-text-2" id="text-org8f2653b">
<p>
The end result works as intended, but it's very rough. I'll try to improve it a
bit more. In particular I want
</p>

<ol class="org-ol">
<li>better strings - <code>(format "%S" node)</code> is all right to start with, but in the
long run I want strings that describe the sections, and</li>
<li>preview as I navigate between items - AFAIU this is what the <code>:state</code> field
is for, but I still haven't looked into how it works.</li>
</ol>

<p>
The source can be found <a href="https://gitlab.com/magus/my-emacs-pkgs/-/blob/main/my-cabal-mode/consult-cabal.el">here</a>.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-cabal.html">cabal</a> <a href="https://magnus.therning.org/tag-consult.html">consult</a> <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-tree-sitter.html">tree-sitter</a> </div>

<div class="post-date">22 Mar 2023</div><h1 class="post-title"><a href="https://magnus.therning.org/2023-03-22-making-an-emacs-major-mode-for-cabal-using-tree-sitter.html">Making an Emacs major mode for Cabal using tree-sitter</a></h1>
<p>
A few days ago I <a href="https://www.reddit.com/r/haskell/comments/11uvhsk/cabal_grammar_for_treesitter_at_least_the/">posted on r/haskell</a> that I'm attempting to put together a <a href="https://cabal.readthedocs.io/en/stable/index.html">Cabal</a>
grammar for <a href="https://tree-sitter.github.io/tree-sitter/">tree-sitter</a>.  Some things are still missing, but it covers enough to
start doing what I initially intended: experiment with writing an alternative
Emacs major mode for Cabal.
</p>

<p>
The documentation for the tree-sitter integration is very nice, and several of
the major modes already have tree-sitter variants, called <code>X-ts-mode</code> where <code>X</code>
is e.g. <code>python</code>, so putting together the beginning of a major mode wasn't too
much work.
</p>

<div id="outline-container-orgaa93cd2" class="outline-2">
<h2 id="orgaa93cd2">Configuring Emacs</h2>
<div class="outline-text-2" id="text-orgaa93cd2">
<p>
First off I had to make sure the parser for Cabal was installed. The snippet for
that looks like this<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">use-package</span> <span class="org-constant">treesit</span>
  <span class="org-builtin">:straight</span> nil
  <span class="org-builtin">:ensure</span> nil
  <span class="org-builtin">:commands</span> <span class="org-rainbow-delimiters-depth-2">(</span>treesit-install-language-grammar<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-builtin">:init</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq</span> treesit-language-source-alist
        '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>cabal . <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"https://gitlab.com/magus/tree-sitter-cabal.git"</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
With that in place the parser is installed using <code>M-x
treesit-install-language-grammar</code> and choosing <code>cabal</code>.
</p>

<p>
After that I removed my configuration for <code>haskell-mode</code> and added the following
snippet to get my own major mode into my setup.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">use-package</span> <span class="org-constant">my-cabal-mode</span>
  <span class="org-builtin">:straight</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-builtin">:type</span> git
             <span class="org-builtin">:repo</span> <span class="org-string">"git@gitlab.com:magus/my-emacs-pkgs.git"</span>
             <span class="org-builtin">:branch</span> <span class="org-string">"main"</span>
             <span class="org-builtin">:files</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-builtin">:defaults</span> <span class="org-string">"my-cabal-mode/*el"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge3a4a9a" class="outline-2">
<h2 id="orge3a4a9a">The major mode and font-locking</h2>
<div class="outline-text-2" id="text-orge3a4a9a">
<p>
The built-in elisp documentation actually has a section on writing a major mode
with tree-sitter, so it was easy to get started. Setting up the font-locking
took a bit of trial-and-error, but once I had comments looking the way I wanted
it was easy to add to the setup. Oh, and yes, there's a section on font-locking
with tree-sitter in the documentation too. At the moment it looks like this
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defvar</span> <span class="org-variable-name">cabal--treesit-font-lock-setting</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>treesit-font-lock-rules
   <span class="org-builtin">:feature</span> 'comment
   <span class="org-builtin">:language</span> 'cabal
   '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>comment<span class="org-rainbow-delimiters-depth-4">)</span> @font-lock-comment-face<span class="org-rainbow-delimiters-depth-3">)</span>

   <span class="org-builtin">:feature</span> 'cabal-version
   <span class="org-builtin">:language</span> 'cabal
   '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>cabal_version _<span class="org-rainbow-delimiters-depth-4">)</span> @font-lock-constant-face<span class="org-rainbow-delimiters-depth-3">)</span>

   <span class="org-builtin">:feature</span> 'field-name
   <span class="org-builtin">:language</span> 'cabal
   '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>field_name<span class="org-rainbow-delimiters-depth-4">)</span> @font-lock-keyword-face<span class="org-rainbow-delimiters-depth-3">)</span>

   <span class="org-builtin">:feature</span> 'section-name
   <span class="org-builtin">:language</span> 'cabal
   '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>section_name<span class="org-rainbow-delimiters-depth-4">)</span> @font-lock-variable-name-face<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Tree-sitter font-lock settings."</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter">;;;</span><span class="org-comment">###</span><span class="org-comment"><span class="org-warning">autoload</span></span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">define-derived-mode</span> <span class="org-function-name">my-cabal-mode</span> fundamental-mode <span class="org-string">"My Cabal"</span>
  <span class="org-doc">"My mode for Cabal files"</span>

  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when</span> <span class="org-rainbow-delimiters-depth-3">(</span>treesit-ready-p 'cabal<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>treesit-parser-create 'cabal<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">set up treesit</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">setq-local</span> treesit-font-lock-feature-list
                '<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-rainbow-delimiters-depth-5">(</span>comment field-name section-name<span class="org-rainbow-delimiters-depth-5">)</span>
                  <span class="org-rainbow-delimiters-depth-5">(</span>cabal-version<span class="org-rainbow-delimiters-depth-5">)</span>
                  <span class="org-rainbow-delimiters-depth-5">()</span> <span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">setq-local</span> treesit-font-lock-settings cabal--treesit-font-lock-setting<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>treesit-major-mode-setup<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter">;;;</span><span class="org-comment">###</span><span class="org-comment"><span class="org-warning">autoload</span></span>
<span class="org-rainbow-delimiters-depth-1">(</span>add-to-list 'auto-mode-alist '<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\\.cabal\\'"</span> . my-cabal-mode<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5251e68" class="outline-2">
<h2 id="org5251e68">Navigation</h2>
<div class="outline-text-2" id="text-org5251e68">
<p>
One of the reasons I want to experiment with tree-sitter is to use it for code
navigation. My first attempt is to translate <code>haskell-cabal-section-beginning</code>
(in <code>haskell-mode</code>, <a href="https://github.com/haskell/haskell-mode/blob/master/haskell-cabal.el#L395">the source</a>) to using tree-sitter. First a convenience
function to recognise if a node is a section or not
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">cabal--node-is-section-p</span> <span class="org-rainbow-delimiters-depth-2">(</span>n<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Predicate to check if treesit node N is a Cabal section."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>member <span class="org-rainbow-delimiters-depth-3">(</span>treesit-node-type n<span class="org-rainbow-delimiters-depth-3">)</span>
          '<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"benchmark"</span> <span class="org-string">"common"</span> <span class="org-string">"executable"</span> <span class="org-string">"flag"</span> <span class="org-string">"library"</span> <span class="org-string">"test_suite"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
That makes it possible to use <code>treesit-parent-until</code> to traverse the nodes until
hitting a section node
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">cabal-goto-beginning-of-section</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Go to the beginning of the current section."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">interactive</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when-let*</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>node-at-point <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-at <span class="org-rainbow-delimiters-depth-6">(</span>point<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>section-node <span class="org-rainbow-delimiters-depth-5">(</span>treesit-parent-until node-at-point #'cabal--node-is-section-p<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>start-pos <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-start section-node<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>goto-char start-pos<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
And the companion function, to go to the end of a section is very similar
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">cabal-goto-end-of-section</span> <span class="org-rainbow-delimiters-depth-2">()</span>
  <span class="org-doc">"Go to the end of the current section."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">interactive</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">when-let*</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>node-at-point <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-at <span class="org-rainbow-delimiters-depth-6">(</span>point<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>section-node <span class="org-rainbow-delimiters-depth-5">(</span>treesit-parent-until node-at-point #'cabal--node-is-section-p<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
              <span class="org-rainbow-delimiters-depth-4">(</span>end-pos <span class="org-rainbow-delimiters-depth-5">(</span>treesit-node-end section-node<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>goto-char end-pos<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I'm using <a href="https://github.com/radian-software/straight.el">straight.el</a> and <code>use-package</code> in my setup, but hopefully the
snippets can easily be converted to other ways of configuring Emacs.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-cabal.html">cabal</a> <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-tree-sitter.html">tree-sitter</a> </div>
<div id="archive">
<a href="https://magnus.therning.org/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><!-- org-static-blog-page-postamble --></div>
</body>
</html>
