<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://magnus.therning.org/feed.xml"
      title="RSS feed for https://magnus.therning.org/">
<title>Magnus web site</title>
<meta name="author" content="Magnus Therning"><meta name="referrer" content="no-referrer"><link href= "static/style.css" rel="stylesheet" type="text/css" /><link href= "static/htmlize.css" rel="stylesheet" type="text/css" /><link href= "static/extra_style.css" rel="stylesheet" type="text/css" /></head>
<body>
<div id="preamble" class="status"><div class="nav-bar"><a class="nav-link" href="./index.html">Top</a><a class="nav-link" href="./archive.html">Archive</a><a class="nav-link align-right" href="./feed.xml"><img src="static/rss-feed-icon.png" style="height: 24px;" /></a></div></div>
<div id="content">
<header class="site-header" role="banner"><h1 class="title">Magnus web site</h1><h2 class="subtitle">Random stuff</h2></header>
<div class="post-date">21 Apr 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-04-21-first-contribution-to-nixpkgs.haskellpackages.html">First contribution to nixpkgs.haskellPackages</a></h1>
<p>
Nothing much to be proud of, but yesterday I found out that <a href="https://hackage.haskell.org/package/servant-docs">servant-docs</a> was
marked broken in <span class="underline">nixpkgs</span> even though it builds just fine and this morning I
decided to do something about it.
</p>

<p>
So, with the help of a <a href="https://discourse.nixos.org/t/call-to-action-for-updating-haskell-packages-after-bump-to-lts-15/6071">post on the NixOS discourse</a> I put together my first <a href="https://github.com/NixOS/nixpkgs/pull/120026">PR</a>.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-nix.html">nix</a> <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> </div>
<div class="post-date">13 Apr 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-04-13-nix-shell,-direnv-and-xdg_data_dirs.html">Nix shell, direnv and XDG_DATA_DIRS</a></h1>
<p>
A few weeks ago I noticed that I no longer could use
<code>haskell-hoogle-lookup-from-website</code> in Emacs. After a bit of experimentation I
found that the reason was that I couldn't use <code>xdg-open</code> in a Nix shell.
Yesterday I finally got around to look into further.
</p>

<p>
It's caused by <code>direnv</code> overwriting <code>XDG_DATA_DIRS</code> rather than appending to it.
Of course someone already reported <a href="https://github.com/direnv/direnv/issues/785">a bug</a> already.
</p>

<p>
The workaround is to use
</p>

<div class="org-src-container">
<pre class="src src-shell">use nix --keep XDG_DATA_DIRS
</pre>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-nix.html">nix</a> <a href="https://magnus.therning.org/tag-direnv.html">direnv</a> </div>
<div class="post-date">21 Mar 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-03-21-todo-items-in-org-roam,-an-update.html">Todo items in org-roam, an update</a></h1>
<p>
I got an email from Mr Z with a nice modification to the code in my post on
<a href="2021-03-14-keeping-todo-items-in-org-roam.html">keeping todo items in org-roam</a>.
</p>

<p>
He already had a bunch of agenda files that he wanted to keep using (I had so
few of them that I'd simply converted them to roam files). Here's the solution
he shared with me:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defvar</span> <span class="org-variable-name">roam-extra-original-org-agenda-files</span> nil
  <span class="org-doc">"Original value of  `</span><span class="org-doc"><span class="org-constant">org-agenda-files</span></span><span class="org-doc">'."</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">roam-extra:update-todo-files</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">&amp;rest</span> _<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-doc">"Update the value of `</span><span class="org-doc"><span class="org-constant">org-agenda-files</span></span><span class="org-doc">'."</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">unless</span> roam-extra-original-org-agenda-files
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">setq</span> roam-extra-original-org-agenda-files org-agenda-files<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">setq</span> org-agenda-files
        <span class="org-rainbow-delimiters-depth-3">(</span>append roam-extra-original-org-agenda-files
                <span class="org-rainbow-delimiters-depth-4">(</span>roam-extra:todo-files<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
It's a rather nice modification I think. Thanks to Mr Z for agreeing to let me
share it here.
</p>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-emacs.html">emacs</a> <a href="https://magnus.therning.org/tag-org-mode.html">org-mode</a> <a href="https://magnus.therning.org/tag-org-roam.html">org-roam</a> </div>
<div class="post-date">20 Mar 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-03-20-barbie-and-json.html">Barbie and <strike>Ken</strike>JSON</a></h1>
<p>
After higher-kinded data (HKD) and <a href="https://hackage.haskell.org/package/barbies">barbies</a> were mentioned in <a href="https://haskellweekly.news/episode/35.html">episode 35 of
Haskell Weekly</a> I've been wondering if it could be used in combination with <a href="https://hackage.haskell.org/package/aeson">aeson</a>
to do validation when implementing web services.
</p>

<p>
TLDR; I think it'd work, but I have a feeling I'd have to spend some more time
on it to get an API with nice ergonomics.
</p>

<div id="outline-container-orga9a9fc9" class="outline-2">
<h2 id="orga9a9fc9">Defining a type to play with</h2>
<div class="outline-text-2" id="text-orga9a9fc9">
<p>
I opted to use <a href="https://hackage.haskell.org/package/barbies-th">barbies-th</a> to save on the typing a bit. Defining a simple type
holding a name and an age can then look like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">declareBareB</span>
  <span class="org-rainbow-delimiters-depth-1">[</span>d<span class="org-haskell-operator">|</span>
   <span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Person</span> <span class="org-rainbow-delimiters-depth-2">{</span>name <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Text</span>, age <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Int</span><span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-haskell-operator">|</span><span class="org-rainbow-delimiters-depth-1">]</span>

<span class="org-haskell-keyword">deriving</span> <span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Show</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">deriving</span> <span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Show</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-keyword">deriving</span> <span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Show</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The two functions from the <code>Barbies</code> module documentation, <code>addDefaults</code> and
<code>check</code>, can then be written like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">addDefaults</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span>
<span class="org-haskell-definition">addDefaults</span> <span class="org-haskell-operator">=</span> bzipWith trans
  <span class="org-haskell-keyword">where</span>
    trans m d <span class="org-haskell-operator">=</span> maybe d pure m

<span class="org-haskell-definition">check</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Either</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">check</span> pe <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> btraverse <span class="org-rainbow-delimiters-depth-1">(</span>either <span class="org-rainbow-delimiters-depth-2">(</span>const <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Just</span> <span class="org-haskell-operator">.</span> <span class="org-haskell-constructor">Identity</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> pe <span class="org-haskell-keyword">of</span>
  <span class="org-haskell-constructor">Just</span> pin <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Right</span> pin
  <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Left</span> <span class="org-haskell-operator">$</span> bfoldMap <span class="org-rainbow-delimiters-depth-1">(</span>either <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-3">[]</span></span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>const <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-3">[]</span></span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> pe
</pre>
</div>

<p>
I found it straight forward to define some instances and play with those
functions a bit.
</p>
</div>
</div>

<div id="outline-container-orgc68301e" class="outline-2">
<h2 id="orgc68301e">Adding in JSON</h2>
<div class="outline-text-2" id="text-orgc68301e">
<p>
The bit that wasn't immediately obvious to me was how to use aeson to parse into
a type like <code>Person Covered (Either Text)</code>.
</p>

<p>
First off I needed some data to test things out with.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">bs0, bs1</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span>
<span class="org-haskell-definition">bs0</span> <span class="org-haskell-operator">=</span> <span class="org-string">"{\"name\": \"the name\", \"age\": 17}"</span>
<span class="org-haskell-definition">bs1</span> <span class="org-haskell-operator">=</span> <span class="org-string">"{\"name\": \"the name\", \"age\": true}"</span>
</pre>
</div>

<p>
To keep things simple I took baby steps, first I tried parsing into <code>Person
Covered Identity</code>. It turns out that the <code>FromJSON</code> instance from that doesn't
need much thought at all. (It's a bit of a pain to have to specify types in GHCi
all the time, so I'm throwing in a specialised decoding function for each type
too.)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">FromJSON</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  parseJSON <span class="org-haskell-operator">=</span> withObject <span class="org-string">"Person"</span> <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">\</span>o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Person</span> <span class="org-haskell-operator">&lt;$&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"name"</span>
      <span class="org-haskell-operator">&lt;*&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"age"</span>

<span class="org-haskell-definition">decodePI</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Identity</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">decodePI</span> <span class="org-haskell-operator">=</span> decode
</pre>
</div>

<p>
Trying it out on the test data gives the expected results
</p>

<pre class="example" id="orgbe631ca">
λ&gt; let i0 = decodePI bs0
λ&gt; i0
Just (Person {name = Identity "the name", age = Identity 17})
λ&gt; let i1 = decodePI bs1
λ&gt; i1
Nothing
</pre>

<p>
So far so good! Moving onto <code>Person Covered Maybe</code>. I spent some time trying to
use the combinators in <code>Data.Aeson</code> for dealing with parser failures, but in the
end I had to resort to using <code>&lt;|&gt;</code> from <code>Alternative</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">FromJSON</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  parseJSON <span class="org-haskell-operator">=</span> withObject <span class="org-string">"Person"</span> <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">\</span>o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Person</span> <span class="org-haskell-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>o <span class="org-haskell-operator">.:</span> <span class="org-string">"name"</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-operator">&lt;*&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>o <span class="org-haskell-operator">.:</span> <span class="org-string">"age"</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-haskell-constructor">Nothing</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">decodePM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-haskell-type">Maybe</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">decodePM</span> <span class="org-haskell-operator">=</span> decode
</pre>
</div>

<p>
Trying that out I saw exactly the behaviour I expected, i.e. that parsing won't
fail. (Well, at least not as long as it's a valid JSON object to being with.)
</p>

<pre class="example" id="orgec185e3">
λ&gt; let m0 = decodePM bs0
λ&gt; m0
Just (Person {name = Just "the name", age = Just 17})
λ&gt; let m1 = decodePM bs1
λ&gt; m1
Just (Person {name = Just "the name", age = Nothing})
</pre>

<p>
With that done I found that the instance for <code>Person Covered (Either Text)</code>
followed quite naturally. I had to spend a little time on getting the types
right to parse the fields properly. Somewhat disappointingly I didn't get type
errors when the behaviour of the code turned out to be wrong. I'm gussing
aeson's <code>Parser</code> was a little too willing to give me parser failures. Anyway, I
ended up with this instance
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">FromJSON</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">where</span>
  parseJSON <span class="org-haskell-operator">=</span> withObject <span class="org-string">"Person"</span> <span class="org-haskell-operator">$</span>
    <span class="org-haskell-operator">\</span>o <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-constructor">Person</span> <span class="org-haskell-operator">&lt;$&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">&lt;$&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"name"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Left</span> <span class="org-string">"A name is most needed"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-haskell-operator">&lt;*&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Right</span> <span class="org-haskell-operator">&lt;$&gt;</span> o <span class="org-haskell-operator">.:</span> <span class="org-string">"age"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">&lt;|&gt;</span> pure <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Left</span> <span class="org-string">"An integer age is needed"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">decodePE</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">BSL.ByteString</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Maybe</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Person</span> <span class="org-haskell-type">Covered</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">Text</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">decodePE</span> <span class="org-haskell-operator">=</span> decode
</pre>
</div>

<p>
That does exhibit the behaviour I want
</p>

<pre class="example" id="orgb5a080b">
λ&gt; let e0 = decodePE bs0
λ&gt; e0
Just (Person {name = Right "the name", age = Right 17})
λ&gt; let e1 = decodePE bs1
λ&gt; e1
Just (Person {name = Right "the name", age = Left "An integer age is needed"})
</pre>
</div>
</div>

<div id="outline-container-orgcfdacc1" class="outline-2">
<h2 id="orgcfdacc1">In closing</h2>
<div class="outline-text-2" id="text-orgcfdacc1">
<p>
I think everyone will agree that the <code>FromJSON</code> instances are increasingly
messy. I think that can be fixed by putting some thought into what a more
pleasing API should look like.
</p>

<p>
I'd also like to mix in validation beyond what aeson offers out-of-the-box,
which really only is "is the field present?" and "does the value have the
correct type?". For instance, Once we know there is a field called <code>age</code>, and
that it's an <code>Int</code>, then we might want to make sure it's non-negitive, or that
the person is at least 18. I'm guessing that wouldn't be too difficult.
</p>

<p>
Finally, I'd love to see examples of using HKDs for parsing/validation in the
wild. It's probably easiest to reach me at <a href="https://mastodon.technology/@magthe">@magthe@mastodon.technology</a>.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-hkd.html">hkd</a> <a href="https://magnus.therning.org/tag-json.html">json</a> </div>
<div class="post-date">19 Mar 2021</div><h1 class="post-title"><a href="https://magnus.therning.org/2021-03-19-custom-monad-with-servant-and-throwing-errors.html">Custom monad with servant and throwing errors</a></h1>
<p>
In the past I've always used <a href="https://hackage.haskell.org/package/scotty">scotty</a> when writing web services. This was mostly
due to laziness, I found working out how to use scotty a lot easier than
<a href="https://hackage.haskell.org/package/servant">servant</a>, so basically I was being lazy. Fairly quickly I bumped into some
limitations in scotty, but at first the workarounds didn't add too much
complexity and were acceptable. A few weeks ago they started weighing on me
though and I decided to look into servant and since I really liked what I found
I've started moving all projects to use servant.
</p>

<p>
In several of the projects I've used tagless final style and defined a type
based on <code>ReaderT</code> holding configuration over <code>IO</code>, that is something like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unAppM <span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor">ReaderT</span> <span class="org-haskell-constructor">Config</span> <span class="org-haskell-constructor">IO</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span>
    <span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-haskell-constructor">Functor</span>,
      <span class="org-haskell-constructor">Applicative</span>,
      <span class="org-haskell-constructor">Monad</span>,
      <span class="org-haskell-constructor">MonadIO</span>,
      <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Config</span>
    <span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> a
<span class="org-haskell-definition">runAppM</span> app <span class="org-haskell-operator">=</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
I found that servant is very well suited to this style through <a href="https://hoogle.haskell.org/?hoogle=hoistServer%20is%3Aexact&amp;scope=set:stackage"><code>hoistServer</code></a> and
there are several examples on how to use it with a <code>ReaderT</code>-based type like
above. The first one I found is in the <a href="https://docs.servant.dev/en/stable/cookbook/using-custom-monad/UsingCustomMonad.html">servant cookbook</a>. However, as I realised
a bit later, using a simple type like this doesn't make it easy to trigger
responses with status other than <code>200 OK</code>. When I looked at the definition of
the type for writing handlers that ships with servant, <a href="https://hoogle.haskell.org/?hoogle=Handler%20package%3Aservant-server%20is%3Aexact&amp;scope=set:stackage"><code>Handler</code></a>, I decided to
try to use the following type in my service
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">{</span>unAppM <span class="org-haskell-constructor">:</span> <span class="org-haskell-constructor">ReaderT</span> <span class="org-haskell-constructor">Config</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">ExceptT</span> <span class="org-haskell-constructor">ServerError</span> <span class="org-haskell-constructor">IO</span><span class="org-rainbow-delimiters-depth-2">)</span> a<span class="org-rainbow-delimiters-depth-1">}</span>
  <span class="org-haskell-keyword">deriving</span>
    <span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-haskell-constructor">Functor</span>,
      <span class="org-haskell-constructor">Applicative</span>,
      <span class="org-haskell-constructor">Monad</span>,
      <span class="org-haskell-constructor">MonadIO</span>,
      <span class="org-haskell-constructor">MonadReader</span> <span class="org-haskell-constructor">Config</span>
    <span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">runAppM</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Config</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">IO</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Either</span> <span class="org-haskell-type">ServerError</span> a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-haskell-definition">runAppM</span> app <span class="org-haskell-operator">=</span> runExceptT <span class="org-haskell-operator">.</span> runReaderT <span class="org-rainbow-delimiters-depth-1">(</span>unAppM app<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The natural transformation required by <code>hoistServer</code> can then be written like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">nt</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Handler</span> a
<span class="org-haskell-definition">nt</span> x <span class="org-haskell-operator">=</span>
  liftIO <span class="org-rainbow-delimiters-depth-1">(</span>runAppM x cfg<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;&gt;=</span> <span class="org-haskell-operator">\</span><span class="org-haskell-keyword">case</span>
    <span class="org-haskell-constructor">Right</span> v <span class="org-haskell-operator">-&gt;</span> pure v
    <span class="org-haskell-constructor">Left</span> err <span class="org-haskell-operator">-&gt;</span> throwError err
</pre>
</div>

<p>
I particularly like how clearly this suggests a way to add custom errors if I
want that.
</p>

<ol class="org-ol">
<li>Swap out <code>ServerError</code> for my custom error type in <code>AppM</code>.</li>
<li>Write a function to transform my custom error type into a <code>ServerError</code>,
<code>transformCustomError :: CustomError -&gt; ServerError</code>.</li>
<li>use <code>throwError $ transformCustomError err</code> in the <code>Left</code> branch of <code>nt</code>.</li>
</ol>

<div id="outline-container-org656a1f3" class="outline-2">
<h2 id="org656a1f3">A slight complication with <code>MonadUnliftIO</code></h2>
<div class="outline-text-2" id="text-org656a1f3">
<p>
I was using <a href="https://hackage.haskell.org/package/unliftio">unliftio</a> in my service, and as long as I based my monad stack only
on <code>ReaderT</code> that worked fine. I even got the <code>MonadUnliftIO</code> instance for free
through automatic deriving. <code>ExceptT</code> isn't a stateless monad though, so using
unliftio is out of the question, instead I had to switch to <a href="https://hoogle.haskell.org/?hoogle=MonadBaseControl%20package%3Amonad-control&amp;scope=set:stackage"><code>MonadBaseControl</code></a>
and the packages that work with it. Defining and instance of <code>MonadBaseControl</code>
looked a bit daunting, but luckily <code>Handler</code> has an instance of it that I used
as inspiration.
</p>

<p>
First off <code>MonadBaseControl</code> requires the type to also be an instance of
<code>MonadBase</code>. There's an explicit implementation for <code>Handler</code>, but I found that
it can be derived automatically, so I took the lazy route.
</p>

<p>
The instance of <code>MonadBaseControl</code> for <code>AppM</code> ended up looking like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">MonadBaseControl</span> <span class="org-haskell-type">IO</span> <span class="org-haskell-type">AppM</span> <span class="org-haskell-keyword">where</span>
  <span class="org-haskell-keyword">type</span> <span class="org-haskell-type">StM</span> <span class="org-haskell-type">AppM</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-type">Either</span> <span class="org-haskell-type">ServerError</span> a

  liftBaseWith f <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-rainbow-delimiters-depth-1">(</span>liftBaseWith <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>g <span class="org-haskell-operator">-&gt;</span> f <span class="org-rainbow-delimiters-depth-3">(</span>g <span class="org-haskell-operator">.</span> unAppM<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
  restoreM <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">AppM</span> <span class="org-haskell-operator">.</span> restoreM
</pre>
</div>

<p>
I can't claim to really understand what's going on in that definition, but I
have Alexis King's article on <a href="https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/">Demystifying MonadBaseControl</a> on my list of things
to read.
</p>
</div>
</div>
<div class="taglist"><a href="https://magnus.therning.org/tags.html">Tags</a>: <a href="https://magnus.therning.org/tag-haskell.html">haskell</a> <a href="https://magnus.therning.org/tag-servant.html">servant</a> </div><div id="archive">
<a href="https://magnus.therning.org/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><!-- org-static-blog-page-postamble --></div>
</body>
</html>
